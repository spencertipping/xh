BEGIN {xh::defmodule('bootunit.xh', <<'_')}
def test {
  def perltime {perl {use Time::HiRes qw/time/; time}}
  def start-time $(perltime)
  $'[$_ @/1!]
  def end-time $(perltime)
  print tested $[$_ @/0] in $(math* 1000 $(math- $end-time $start-time)) ms
}

test everything {
  # This is a comment and should work properly.
  # {
    This is a block comment and should also work.
  }
  #== 1 1

  test basic-interpolation {
    def foo bar
    #== $@foo         bar
    #== $@foo         {bar}
    #== $@foo         (bar)
    #== $@foo         [bar]
    #== $foo          bar
    #== $(echo $foo)  bar
    #== $@(echo $foo) bar
  }

  test subroutines {
    def greet {
      echo hi there, $_
    }
    #== $@(greet spencer)         {hi there, spencer}
    #== $@(greet spencer tipping) {hi there, spencer tipping}

    # Also anonymous functions:
    #== $@($greet spencer)       {hi there, spencer}
    #== $@({echo hi $_} spencer) {hi spencer}
  }

  test scoping {
    def newdef {
      # Define stuff within the calling scope; should be equivalent to
      # using def.
      echo $^(def $@_)
    }
    newdef x 5
    #== $@x 5
  }

  test line-interpolation {
    def x 5
    def two-statements {
      def x 10
      echo $x
    }
    #== $@x 5
    $'two-statements
    #== $@x 10
  }

  test outer-interpolation {
    def get-5-plus {
      echo $(math+ $[$_ @/0] 5)
    }
    def inner {
      echo $^(get-5-plus 10)
    }
    #== $(inner) 15
  }

  test list-accessors {
    def xs (foo bar bif baz)
    #== $@(@ 0 $xs) foo
    #== $@(@ 1 $xs) bar
    #== $@(@ 2 $xs) bif
    #== $@(@ 3 $xs) baz
    #== $@(@ ^foo $xs) foo

    def ys ({foo} {bar bif} [baz] (bok))
    #== $@(@% 0 $ys) {{foo}}
    #== $@(@  0 $ys) foo
    #== $@(@% 1 $ys) {{bar bif}}
    #== $@(@  1 $ys) {{bar bif}}
    #== $@(@% 2 $ys) {[baz]}
    #== $@(@  2 $ys) baz
    #== $@(@% 3 $ys) {(bok)}
    #== $@(@  3 $ys) bok

    test {$[]-expansion} {
      #== $@[there echo/hi]              {hi there}
      #== $@[spencer echo/there echo/hi] {hi there spencer}

      #== $@[$^xs @/0]   foo
      #== $@[$^xs @/-1]  baz
      #== $@[$^xs @/-2]  bif
      #== $@[$^xs @/:]   {{foo bar bif baz}}
      #== $@[$^xs @/1:]  {{bar bif baz}}
      #== $@[$^xs @/:1]  {{foo bar}}
      #== $@[$^xs @/:-2] {{foo bar bif}}
      #== $@[$^xs @/3:1] {{baz bif bar}}

      #== $@[$^xs @/^bar] bar
      #== $@[$^xs @/^bif] bif
      #== $@[$^xs @/^notfound] {}

      #== $@[$^xs @{0 2}]    {{foo bif}}
      #== $@[$^xs @{0 2:}]   {{foo {bif baz}}}
      #== $@[$^xs @{0 {2:}}] {{foo {{bif baz}}}}
    }
  }

  test list-updaters {
    def xs (a b c d)
    #== $@[$xs @=/0/b  !] {b b c d}
    #== $@[$xs @=/-1/a !] {a b c a}
  }

  test associative-maps {
    def associative {
      foo bar
      bif baz
    }
    #== $@[$associative '/^foo @(0 1)] {{foo bar}}
    #== $@[$associative '/^foo @/1] bar
    #== $@[$associative '/^bif @/1] baz
    #== $@[$associative '/^bok] {}

    #== $@[$associative '/#] 4
    #== $@[$associative @/#] 4

    #== $@[$associative '=/^foo[FOO BAR] '/^FOO @/1] BAR
  }

  test byte-lists {
    #== $@[abcd "/0] 97
    #== $@[abcd "/1:3] {{98 99 100}}
  }

  test path-lists {
    #== $@[/usr/bin/bash :(^/bin)] /bin
    #== $@[../.. :/^..] ..
  }

  test macro-definition {
    def #-> {echo #== \$@($@[$_ @/0]) $[$_ @/1]}
    #-> {echo hi} hi
  }

  test equality-comparison {
    def x 10
    #== $(== $x 10) {{10}}
    #== $(== {} {}) {{}}
    #== $(== $x 9)  {}

    #== $(not $(== $x 9))  {{}}
    #== $(not $(== $x 10)) {}
  }

  test conditions {
    def x 5
    if $(== $x 5) {def x 6} {def x 7}
    #== $x 6
    if $(== $x 5) {def x 8} {def x 9}
    #== $x 9
  }

  test iteration {
    def i     0
    def count 0
    while {not $(== $i 10)} {
      def i     $(math+ $i     1)
      def count $(math+ $count 1)
    }
    #== $count 10
    #== $i     10
  }

  test float-math {
    #== $(math+ 0 1) 1
    #== $(math/ 4 8) 0.5
    #== $(math< 3 4) 1
    #== $(math< 5 4) {}
  }
}
_
