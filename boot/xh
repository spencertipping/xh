#!/usr/bin/env perl
BEGIN {eval(our $xh_bootstrap = q{
# xh | https://github.com/spencertipping/xh
# Copyright (C) 2014, Spencer Tipping
# Licensed under the terms of the MIT source code license

# For the benefit of HTML viewers (long story):
# <body style='display:none'>
# <script src='http://spencertipping.com/xh/page.js'></script>
use 5.014;
package xh;
our %modules;
our @module_ordering;
our %eval_numbers = (1 => '$xh_bootstrap');

sub with_eval_rewriting(&) {
  my @result = eval {$_[0]->(@_[1..$#_])};
  $@ =~ s/\(eval (\d+)\)/$eval_numbers{$1}/eg if $@;
  die $@ if $@;
  @result;
}

sub named_eval {
  my ($name, $code) = @_;
  $eval_numbers{$1 + 1} = $name if eval('__FILE__') =~ /\(eval (\d+)\)/;
  with_eval_rewriting {eval $code};
}

our %compilers = (pl => sub {
  my $package = $_[0] =~ s/\./::/gr;
  named_eval $_[0], "{package ::$package;\n$_[1]\n}";
  die "error compiling module $_[0]: $@" if $@;
});

sub defmodule {
  my ($name, $code, @args) = @_;
  chomp($modules{$name} = $code);
  push @module_ordering, $name;
  my ($base, $extension) = split /\.(\w+$)/, $name;
  die "undefined module extension '$extension' for $name"
    unless exists $compilers{$extension};
  $compilers{$extension}->($base, $code, @args);
}

chomp($modules{bootstrap} = $::xh_bootstrap);
undef $::xh_bootstrap;
sub image {
  my @pieces = "#!/usr/bin/env perl";
  push @pieces, "BEGIN {eval(our \$xh_bootstrap = <<'_')}",
                $modules{bootstrap},
                '_';
  push @pieces, "BEGIN {xh::defmodule('$_', <<'_')}",
                $modules{$_},
                '_' for @module_ordering;
  push @pieces, "xh::main::main;\n__DATA__";
  join "\n", @pieces;
}
})}
BEGIN {xh::defmodule('xh::fabric.pl', <<'_')}
use Sys::Hostname;
use Time::HiRes qw/time/;
use Digest::SHA qw/sha256/;
# Mutable state space definition for the routing fabric. You should create
# one of these for every separate xh network you plan to interface with.

sub fabric_client {
  my ($name, $bindings) = @_;
  $name //= $ENV{USER} . '@' . hostname . '.local';
  return {rpc_bindings     => $bindings // {},
          instance_name    => $name,
          instance_id      => 0,
          edge_pipes       => {},
          network_topology => {},
          send_queue       => [],
          blocked_rpcs     => {},
          routing_cache    => {},
          packet_timings   => {}};
}

sub fabric_rpc_bind {
  my ($state, %bindings) = @_;
  my $bindings = $state->{rpc_bindings};
  $bindings->{$_} = $bindings{$_} for keys %bindings;
  $state;
}
use constant header_pack_format        => 'C32 N N d n C C n';
use constant signed_header_pack_format => 'C32 ' . header_pack_format;

use constant signed_header_length    => 32 + 32+4+4+8+2+1+1+2;
use constant header_signature_length => 32;

our $nonce_state = sha256(time . hostname);
sub packet_nonce {$nonce_state = sha256(time . $nonce_state)}

sub encode_packet {
  my ($state, $destination_name, $message_type, $priority, $deadline)
    = @_;
  die "data is too long: " . length($_[5]) . " (max is 65535 bytes)"
    if length $_[5] >= 65536;

  my $destination_id = $state->{routing_cache}{$destination_name};
  return undef unless defined $destination_id;

  my $header = pack header_pack_format, packet_nonce,
                                        $state->{instance_id},
                                        $destination_id->{endpoint_id},
                                        time,
                                        length $_[5],
                                        $message_type,
                                        $priority,
                                        $deadline;
  my $packet = $header . $_[5];
  sha256($packet) . $packet;
}

sub decode_packet_header {
  unpack signed_header_pack_format, $_[0];
}

sub signature_is_valid {
  my $sha = substr $_[0], 0, header_signature_length;
  $sha eq sha256(substr $_[0], header_signature_length);
}
use constant {forgetful_rpc  => 0,
              functional_rpc => 1,
              rpc_reply      => 2,
              rpc_error      => 3,
              routing_error  => 4};
use constant {realtime_priority => 0,
              high_priority     => 16,
              normal_priority   => 256,
              low_priority      => 32768};

use constant {realtime_deadline          => 0,
              imperceptible_deadline     => 20,
              short_interactive_deadline => 50,
              long_interactive_deadline  => 100,
              process_blocking_deadline  => 250,
              background_deadline        => 2000,
              far_deadline               => 32768};
sub recompute_routing_cache {
  my ($state) = @_;
}
_


xh::main::main;
__DATA__
