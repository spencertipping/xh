#!/usr/bin/env perl
BEGIN {
print STDERR q{
NOTE: Development image

If you see this note after installing the shell, it's probably because
you're running a version that has not yet rebuilt itself (maybe you got the
wrong file from the Git repo?). You can do this, but it will be really
slow and may use a lot of memory. There are two ways to fix this:

1. Download the standard image from http://spencertipping.com/xh
2. Have this image recompile itself by running xh.recompile-in-place (this
   will take some time because it stress-tests your Perl runtime)

Note also that bootstrapping requires Perl 5.14 or later, whereas running a
compiled image just requires Perl 5.10.

};
}

BEGIN {eval(our $xh_bootstrap = q{
# xh: the X shell | https://github.com/spencertipping/xh
# Copyright (C) 2014, Spencer Tipping
# Licensed under the terms of the MIT source code license

# For the benefit of HTML viewers (long story):
# <body style='display:none'>
# <script src='http://spencertipping.com/xh/page.js'></script>
use 5.014;
package xh;
our %modules;
our @module_ordering;

our %compilers = (pl => sub {
  my $package = $_[0] =~ s/\./::/gr;
  eval "{package ::$package;\n$_[1]\n}";
  die "error compiling module $_[0]: $@" if $@;
});

sub defmodule {
  my ($name, $code, @args) = @_;
  chomp($modules{$name} = $code);
  push @module_ordering, $name;
  my ($base, $extension) = split /\.(\w+$)/, $name;
  die "undefined module extension '$extension' for $name"
    unless exists $compilers{$extension};
  $compilers{$extension}->($base, $code, @args);
}

chomp($modules{bootstrap} = $::xh_bootstrap);
undef $::xh_bootstrap;
sub image {
  my @pieces = "#!/usr/bin/env perl";
  push @pieces, "BEGIN {eval(our \$xh_bootstrap = <<'_')}",
                $modules{bootstrap},
                '_';
  push @pieces, "BEGIN {xh::defmodule('$_', <<'_')}",
                $modules{$_},
                '_' for @module_ordering;
  push @pieces, "xh::main::main;\n__DATA__";
  join "\n", @pieces;
}
})}
BEGIN {xh::defmodule('xh::v.pl', <<'_')}
sub unbox;

sub parse_with_quoted {
  my ($events_to_split, $split_sublists, $s) = @_;
  my @result;
  my $current_item  = '';
  my $sublist_depth = 0;

  for my $piece (split /(\v+|\s+|\/|\\.|[\[\](){}])/, $s) {
    next unless length $piece;
    my $depth_before_piece = $sublist_depth;
    $sublist_depth += $piece =~ /^[\[({]$/;
    $sublist_depth -= $piece =~ /^[\])}]$/;

    if ($split_sublists && !$sublist_depth != !$depth_before_piece) {
      # Two possibilities. One is that we just closed an item, in which
      # case we take the piece, concatenate it to the item, and continue.
      # The other is that we just opened one, in which case we emit what we
      # have and start a new item with the piece.
      if ($sublist_depth) {
        # Just opened one; kick out current item and start a new one.
        push @result, unbox $current_item if length $current_item;
        $current_item = $piece;
      } else {
        # Just closed a list; concat and kick out the full item.
        push @result, unbox "$current_item$piece";
        $current_item = '';
      }
    } elsif (!$sublist_depth && $piece =~ /$events_to_split/) {
      # If the match produces a group, then treat it as a part of the next
      # item. Otherwise throw it away.
      push @result, unbox $current_item if length $current_item;
      $current_item = $1;
    } else {
      $current_item .= $piece;
    }
  }

  push @result, unbox $current_item if length $current_item;
  @result;
}

sub parse_lines {parse_with_quoted '\v+', 0, @_}
sub parse_words {parse_with_quoted '\s+', 0, @_}
sub parse_path  {parse_with_quoted '(/)', 1, @_}

sub brace_balance {my $without_escapes = $_[0] =~ s/\\.//gr;
                   length($without_escapes =~ s/[^\[({]//gr) -
                   length($without_escapes =~ s/[^\])}]//gr)}

sub escape_braces_in {$_[0] =~ s/([\\\[\](){}])/\\$1/gr}

sub quote_as_multiple_lines {
  return escape_braces_in $_[0] if brace_balance $_[0];
  $_[0];
}

sub brace_wrap {"{" . quote_as_multiple_lines($_[0]) . "}"}

sub quote_as_line {parse_lines(@_) > 1 ? brace_wrap $_[0] : $_[0]}
sub quote_as_word {parse_words(@_) > 1 ? brace_wrap $_[0] : $_[0]}
sub quote_as_path {parse_path(@_)  > 1 ? brace_wrap $_[0] : $_[0]}

sub quote_default {brace_wrap $_[0]}

sub split_by_interpolation {
  # Splits a value into constant and interpolated pieces, where
  # interpolated pieces always begin with $. Adjacent constant pieces may
  # be split across items. Any active backslash-escapes will be placed on
  # their own.

  my @result;
  my $current_item        = '';
  my $sublist_depth       = 0;
  my $blocker_count       = 0;      # number of open-braces
  my $interpolating       = 0;
  my $interpolating_depth = 0;

  my $closed_something    = 0;
  my $opened_something    = 0;

  for my $piece (split /([\[\](){}]|\\.|\/|\$|\s+)/, $_[0]) {
    $sublist_depth += $opened_something = $piece =~ /^[\[({]$/;
    $sublist_depth -= $closed_something = $piece =~ /^[\])}]$/;
    $blocker_count += $piece eq '{';
    $blocker_count -= $piece eq '}';

    if (!$interpolating) {
      # Not yet interpolating, but see if we can find a reason to change
      # that.
      if (!$blocker_count && $piece eq '$') {
        # Emit current item and start interpolating.
        push @result, $current_item if length $current_item;
        $current_item = $piece;
        $interpolating = 1;
        $interpolating_depth = $sublist_depth;
      } elsif (!$blocker_count && $piece =~ /^\\/) {
        # The backslash should be interpreted, so emit it as its own piece.
        push @result, $current_item if length $current_item;
        push @result, $piece;
        $current_item = '';
      } else {
        # Collect the piece and continue.
        $current_item .= $piece;
      }
    } else {
      # Grab everything until:
      #
      # 1. We close the list in which the interpolation occurred.
      # 2. We close a list to get back out to the interpolation depth.
      # 3. We observe whitespace.
      # 4. We observe a path separator.

      if ($sublist_depth < $interpolating_depth
          or $sublist_depth == $interpolating_depth
             and $piece eq '/' || $piece =~ /^\s/) {
        # No longer interpolating because of what we just saw, so emit
        # current item and start a new constant piece.
        push @result, $current_item if length $current_item;
        $current_item  = $piece;
        $interpolating = 0;
      } elsif ($sublist_depth == $interpolating_depth
               && $closed_something) {
        push @result, "$current_item$piece";
        $current_item  = '';
        $interpolating = 0;
      } else {
        # Still interpolating, so collect the piece.
        $current_item .= $piece;
      }
    }
  }

  push @result, $current_item if length $current_item;
  @result;
}

sub undo_backslash_escape {
  return "\n" if $_[0] eq '\n';
  return "\t" if $_[0] eq '\t';
  return "\\" if $_[0] eq '\\\\';
  substr $_[0], 1;
}

sub unbox {
  my ($s) = @_;
  my $depth      = 0;
  my $last_depth = 1;
  for my $piece (grep length, split /(\\.|[\[\](){}])/, $s) {
    $depth += $piece =~ /^[\[({]/;
    $depth -= $piece =~ /^[\])}]/;
    return $s if $last_depth <= 0;
    $last_depth = $depth;
  }
  $s =~ s/^\s*[\[({](.*)[\])}]\s*$/$1/sgr;
}
_

BEGIN {xh::defmodule('xh::e.pl', <<'_')}
sub evaluate;
sub interpolate;
sub call;

sub interpolate_wrap {
  my ($prefix, $unquoted) = @_;
  return xh::v::quote_as_multiple_lines $unquoted if $prefix =~ /'$/;
  return xh::v::quote_as_line           $unquoted if $prefix =~ /\@$/;
  return xh::v::quote_as_word           $unquoted if $prefix =~ /:$/;
  return xh::v::quote_as_path           $unquoted if $prefix =~ /"$/;
  xh::v::quote_default $unquoted;
}

sub scope_index_for {
  my ($carets) = $_[0] =~ /^\$(\^*)/g;
  -(1 + length $carets);
}

sub truncated_stack {
  my ($stack, $index) = @_;
  return $stack if $index == -1;
  [@$stack[0 .. @$stack + $index]];
}

sub interpolate_dollar {
  my ($binding_stack, $term) = @_;

  # First things first: strip off any prefix operator, then interpolate the
  # result. We do this because $ is right-associative.
  my ($prefix, $rhs) = $term =~ /^(\$\^*[@"':]?)(.*)$/sg;

  # Do we have a compound form? If so, then we need to treat the whole
  # thing as a unit.
  if ($rhs =~ /^\(/) {
    # The exact semantics here are a little subtle. Because the RHS is just
    # ()-boxed, it should be expanded within the current scope. The actual
    # evaluation, however, might be happening within a parent scope; we'll
    # know by looking at the $prefix to check for ^s.

    my $interpolated_rhs = interpolate $binding_stack, xh::v::unbox $rhs;
    my $index            = scope_index_for $prefix;
    my $new_stack        = truncated_stack $binding_stack, $index;

    return interpolate_wrap $prefix,
                            evaluate $new_stack, $interpolated_rhs;
  } elsif ($rhs =~ /^\[/) {
    # $[] is a way to call a series of functions on a value, just like
    # Clojure's (-> x y z). Like $(), we always interpolate the terms of
    # the [] list in the current environment; but any ^s you use (e.g.
    # $^[]) cause the inner functions to be called from a parent scope.
    # This can be relevant in certain pathological cases that you should
    # probably never use.

    my ($initial, @fns) = map {interpolate $binding_stack, $_}
                              xh::v::parse_words xh::v::unbox $rhs;
    my $index           = scope_index_for $prefix;
    my $calling_stack   = truncated_stack $binding_stack, $index;

    # You can use paths as a curried notation within $[] interpolation. For
    # example:
    #
    # > echo $[foo echo/hi]
    # hi foo
    #
    # Lists also work, but there is no difference between () and [], which
    # is a horrible oversight that should probably be addressed at some
    # point.
    $initial = call $calling_stack,
                    (map {s/^\///r} xh::v::parse_path($_)),
                    xh::v::parse_words $initial
    for @fns;

    return interpolate_wrap $prefix, $initial;
  } elsif ($rhs =~ /^\{/) {
    $rhs = xh::v::unbox $rhs;
  } else {
    # It's either a plain word or another $-term. Either way, go ahead and
    # interpolate it so that it's ready for this operator.
    $rhs = xh::v::unbox interpolate $binding_stack, $rhs;
  }

  # Try to unwrap any layers around the RHS. Any braces at this point mean
  # that it's artificially quoted, or that the RHS is unusable.
  while ($rhs =~ /^\{/) {
    my $new_rhs = xh::v::unbox $rhs;
    die "illegal interpolation: $rhs" if $new_rhs eq $rhs;
    $rhs = $new_rhs;
  }

  my $index = scope_index_for $prefix;
  interpolate_wrap $prefix,
    $$binding_stack[$index]{$rhs}
    // $$binding_stack[0]{$rhs}
    // die "unbound var: $rhs (bound vars are ["
           . join(' ', sort keys %{$$binding_stack[$index]})
           . "] locally, ["
           . join(' ', sort keys %{$$binding_stack[0]})
           . "] globally)";
}

sub interpolate {
  my ($binding_stack, $x) = @_;
  join '', map {$_ =~ /^\$/ ? interpolate_dollar $binding_stack, $_
              : $_ =~ /^\\/ ? xh::v::undo_backslash_escape $_
              : $_ } xh::v::split_by_interpolation $x;
}

sub call {
  my ($binding_stack, $f, @args) = @_;
  my $fn = $$binding_stack[-1]{$f}
        // $$binding_stack[0]{$f}
        // die "unbound function: $f";

  # Special case: if it's a builtin Perl sub, then just call that directly.
  return &$fn($binding_stack, @args) if ref $fn eq 'CODE';

  # Otherwise use xh calling convention.
  push @$binding_stack,
       {_ => join ' ', map xh::v::quote_default($_), @args};

  my $result = eval {evaluate $binding_stack, $fn};
  my $error  = "$@ in $f "
             . join(' ', map xh::v::quote_default($_), @args)
             . ' at calling stack depth ' . @$binding_stack
             . " with locals:\n"
             . join("\n", map "  $_ -> $$binding_stack[-1]{$_}",
                              sort keys %{$$binding_stack[-1]}) if $@;
  pop @$binding_stack;
  die $error if $error;
  $result;
}

sub evaluate {
  my ($binding_stack, $body) = @_;
  my @statements             = xh::v::parse_lines $body;
  my $result                 = '';

  for my $s (@statements) {
    my $original = $s;

    # Step 1: Do we have a macro? If so, macroexpand before calling
    # anything. (NOTE: technically incorrect; macros should receive their
    # arguments with whitespace intact)
    my @words;
    while ((@words = xh::v::parse_words $s)[0] =~ /^#/) {
      $s = eval {call $binding_stack, @words};
      die "$@ in @words (while macroexpanding $original)" if $@;
    }

    # Step 2: Interpolate the whole command once. Note that we can't wrap
    # each word at this point, since that would block interpolation
    # altogether.
    my $new_s = eval {interpolate $binding_stack, $s};
    die "$@ in $s (while interpolating from $original)" if $@;
    $s = $new_s;

    # If that killed our value, then we have nothing to do.
    next unless length $s;

    # Step 3: See if the interpolation produced multiple lines. If so, we
    # need to re-expand. Otherwise we can do a single function call.
    if (xh::v::parse_lines($s) > 1) {
      $result = evaluate $binding_stack, $s;
    } else {
      # Just one line, so continue normally. At this point we look up the
      # function and call it. If it's Perl native, then we're set; we just
      # call that on the newly-parsed arg list. Otherwise delegate to
      # create a new call frame and locals.
      $result = eval {call $binding_stack, xh::v::parse_words $s};
      die "$@ in $s (while evaluating $original)" if $@;
    }
  }
  $result;
}
_

BEGIN {xh::defmodule('xh::globals.pl', <<'_')}
sub def {
  my ($binding_stack, %args) = @_;
  $$binding_stack[-1]{$_} = $args{$_} for keys %args;
  join ' ', keys %args;
}

sub echo {
  my ($binding_stack, @args) = @_;
  join ' ', @args;
}

sub comment       {''}
sub print_from_xh {print STDERR join(' ', @_[1 .. $#_]), "\n"}

sub perl_eval {
  my $result = eval $_[1];
  die "$@ while evaluating $_[1]" if $@;
  $result;
}

sub assert_eq_macro {
  my ($binding_stack, $lhs, $rhs) = @_;

  # We should get the same result by evaluating the LHS and RHS; otherwise
  # expand into a print statement describing the error.
  my $expanded_lhs = xh::e::interpolate $binding_stack, $lhs;
  my $expanded_rhs = xh::e::interpolate $binding_stack, $rhs;

  $expanded_lhs eq $expanded_rhs
    ? ''
    : 'print ' . xh::v::quote_default("$lhs (-> $expanded_lhs)")
               . ' != '
               . xh::v::quote_default("$rhs (-> $expanded_rhs)");
}

# Create an interpreter instance that lets us interpret modules written in
# XH-script.
our $globals = [{def   => \&def,
                 echo  => \&echo,
                 print => \&print_from_xh,
                 perl  => \&perl_eval,
                 '#'   => \&comment,
                 '#==' => \&assert_eq_macro}];

sub defglobals {
  my %vals = @_;
  $$globals[0]{$_} = $vals{$_} for keys %vals;
}

$xh::compilers{xh} = sub {
  my ($module_name, $code) = @_;
  eval {xh::e::evaluate $globals, $code};
  die "error running $module_name: $@" if $@;
}
_

BEGIN {xh::defmodule('xh::bootlist.pl', <<'_')}
sub wrap_negative {
  my ($i, $n) = @_;
  return undef unless length $i;
  return $n + $i if $i < 0;
  $i;
}

sub flexible_range {
  my ($lower, $upper) = @_;
  return reverse $upper .. $lower if $upper < $lower;
  $lower .. $upper;
}

sub expand_subscript;
sub expand_subscript {
  my ($subscript, $n) = @_;

  my @words = xh::v::parse_words $subscript;
  return [map expand_subscript($_, $n), @words] if @words > 1;

  return [flexible_range wrap_negative($1, $n) // 0,
                         wrap_negative($2, $n) // $n - 1]
  if $subscript =~ /^(-?\d*):(-?\d*)$/;

  return wrap_negative $subscript, $n if $subscript =~ /^-/;
  $subscript;
}

sub dereference_one;
sub dereference_one {
  my ($subscript, $boxed_list) = @_;

  # List homomorphism of subscripts
  return join ' ',
         map xh::v::quote_as_word(dereference_one $_, $boxed_list),
             @$subscript if ref $subscript eq 'ARRAY';

  # Normal numeric lookup, with empty string for out-of-bounds
  return ''                             if $subscript =~ /^-/;
  return $$boxed_list[$subscript] // '' if $subscript =~ /^\d+/;

  # Hashtable lookup maybe?
  if ($subscript =~ s/^@//) {
    # In this case the boxed list should contain at least words, and
    # probably whole lines. We word-parse each entry looking for the
    # first subscript hit.
    $subscript = xh::v::unbox $subscript;
    for my $x (@$boxed_list) {
      my @words = xh::v::parse_words $x;
      return xh::v::quote_as_word $x if $words[0] eq $subscript;
    }
    return '';
  } else {
    die "unrecognized subscript form: $subscript";
  }
}

sub dereference {
  my ($subscript, $boxed_list) = @_;
  dereference_one expand_subscript($subscript, scalar(@$boxed_list)),
                  $boxed_list;
}

sub index_lines {dereference $_[1], [xh::v::parse_lines $_[2]]}
sub index_words {dereference $_[1], [xh::v::parse_words $_[2]]}
sub index_path  {dereference $_[1], [xh::v::parse_path  $_[2]]}
sub index_bytes {dereference $_[1], [map ord, split //, $_[2]]}

xh::globals::defglobals "'"  => \&index_lines,
                        "@"  => \&index_words,
                        ":"  => \&index_path,
                        "\"" => \&index_bytes;
_

BEGIN {xh::defmodule('xh::main.pl', <<'_')}
sub main {
  # This keeps xh from blocking on stdin when we ask it to compile itself.
  /^--recompile$/ and return 0 for @ARGV;

  my $list_depth    = 0;
  my $expression    = '';
  my $binding_stack = $xh::globals::globals;

  print "xh\$ ";
  while (my $line = <STDIN>) {
    if (!($list_depth += xh::v::brace_balance $line)) {
      # Collect the line and evaluate everything we have.
      $expression .= $line;

      my $result = eval {xh::e::evaluate $binding_stack, "$expression"};
      print "error: $@\n" if length $@;
      print "$result\n"   if length $result;

      $expression = '';
      print "xh\$ ";
    } else {
      $expression .= $line;
      print '>   ' . '  ' x $list_depth;
    }
  }
}
_

BEGIN {xh::defmodule('bootunit.xh', <<'_')}
# This is a comment and should work properly.
# {
  This is a block comment and should also work.
}
#== 1 1

def foo bar
#== $@foo         bar
#== $@foo         {bar}
#== $@foo         (bar)
#== $@foo         [bar]
#== $foo          {{bar}}
#== $(echo $foo)  {{bar}}
#== $@(echo $foo) bar

def greet {
  echo hi there, $@_
}
#== $@(greet spencer)         {hi there, spencer}
#== $@(greet spencer tipping) {hi there, spencer tipping}

def newdef {
  # Define stuff within the calling scope; should be equivalent to using
  # def.
  echo $^(def $@_)
}
newdef x 5
#== $@x 5

def two-statements {
  def x 10
  echo $x
}
#== $@x 5
$'two-statements
#== $@x 10

#== $@[there echo/hi]              {hi there}
#== $@[spencer echo/there echo/hi] {hi there spencer}

def xs (foo bar bif baz)
#== $@(@ 0 $xs) foo
#== $@(@ 1 $xs) bar
#== $@(@ 2 $xs) bif
#== $@(@ 3 $xs) baz
#== $@(@ @foo $xs) foo

#== $@[$xs @/0] foo
#== $@[$xs @/-1] baz
#== $@[$xs @/-2] bif
#== $@[$xs @/:]   {foo bar bif baz}
#== $@[$xs @/1:]  {bar bif baz}
#== $@[$xs @/:1]  {foo bar}
#== $@[$xs @/:-2] {foo bar bif}
#== $@[$xs @/3:1] {baz bif bar}

#== $@[$xs @/@bar] bar
#== $@[$xs @/@bif] bif
#== $@[$xs @/@notfound] {}

def associative {
  foo bar
  bif baz
}
#== $@[$associative '/@foo] {{  foo bar}}
#== $@[$associative '/@foo @/1] bar
#== $@[$associative '/@bif @/1] baz
#== $@[$associative '/@bok] {}

#== $@[abcd "/0] 97
#== $@[abcd "/1:3] {98 99 100}

def #-> {echo #== \$@($@[$_ @/0]) $[$_ @/1]}
#-> {echo hi} hi
_

xh::main::main;
__DATA__
