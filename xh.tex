\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

% Shamelessly swiped from
% http://compgroups.net/comp.text.tex/using-ref-and-label-so-that-ref-points-to-the-l/245066
\makeatletter
\newcommand*{\Label}[2]{%
  \@bsphack
  \begingroup
    \label{#1-original}%
    \def\@currentlabel{#2}%
    \label{#1}%
  \endgroup
  \@esphack
}
\makeatother


\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}
\lstnewenvironment{pythoncode}    {\lstset{language=python}}{}

\lstnewenvironment{resourcecode}{}{}

\newcommand{\bs}{\textbackslash}
\setcounter{tocdepth}{0}
\lstnewenvironment{xhcode}{}{}

\newcommand{\initial}{{\em initial assumption}}
\newcommand{\refboth}[1]{{\em \ref{#1}} \ref{#1-original}}

\title{xh}
\author{Spencer Tipping}

\begin{document}
\maketitle{}
\tableofcontents{}


\part{design}\label{part:design}
\chapter{constraints}\label{chp:design-constraints}
  xh is designed to be a powerful and ergonomic interface to multiple systems,
  many of which are remote. As such, it's subject to programming language,
  shell, and distributed-systems constraints:

\begin{enumerate}
\item{}\Label{i:real-programming}{realprog}{\em\ref{i:real-programming}}
  xh will be used for real programming.
(\initial)
\item{}\Label{i:shell}{shell}{\em\ref{i:shell}}
  xh will be used as a shell.
(\initial)
\item{}\Label{i:distributed-computation}{distributed}{\em\ref{i:distributed-computation}}
  xh will be used to manage any machine on which you have a login, which
  could be hundreds or thousands.
(\initial)
\item{}\Label{i:no-root-access}{noroot}{\em\ref{i:no-root-access}}
  You will not always have root access to machines you want to use, and
  they may have different architectures.
(\initial)
\item{}\Label{i:ergonomic-limit}{ergonomic}{\em\ref{i:ergonomic-limit}}
  xh should approach the limit of ergonomic efficiency as it learns more
  about you.
(\initial)
\item{}\Label{i:security}{security}{\em\ref{i:security}}
  xh should never compromise your security, provided you understand what
  it's doing.
(\initial)

\item{}\Label{i:quick-webserver}{webserver}{\em\ref{i:quick-webserver}}
  It should be possible to write a ``hello world'' HTTP server on one line.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\end{itemize}
\item{}\Label{i:live-preview}{liveprev}{\em\ref{i:live-preview}}
  It should be possible to preview the evaluation of any well-formed
  expression without causing side-effects.
\begin{itemize}
\item \initial
\item \refboth{i:shell}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:trivial-debugging}
\end{itemize}
\item{}\Label{i:not-slow}{notslow}{\em\ref{i:not-slow}}
  xh should never cause an unresolvable performance problem that could be
  worked around by using a different language.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\item{}\Label{i:unreliable-connections}{unreliable}{\em\ref{i:unreliable-connections}}
  Connections between machines may die at any time, and remain down for
  arbitrarily long. xh must never become unresponsive when this happens,
  and any data coming from those machines should block until it is
  available again (i.e.~xh's behavior should be invariant with connection
  failures).
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\item \refboth{i:distributed-computation}
\end{itemize}
\item{}\Label{i:trivial-debugging}{nodebug}{\em\ref{i:trivial-debugging}}
  Debugging should require little or no effort; all error cases should be
  trivially obvious.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:distributed-computation}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\item{}\Label{i:trivial-database}{database}{\em\ref{i:trivial-database}}
  An xh instance should trivially function as a database; there should be
  no distinction between data in memory and data on disk.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:trivial-debugging}
\item \refboth{i:no-oome}
\item \refboth{i:not-slow}
\end{itemize}

\item{}\Label{i:universal-prediction}{prediction}{\em\ref{i:universal-prediction}}
  xh should use every keystroke to build/refine a model it uses to predict
  future keystrokes and commands.
(\refboth{i:ergonomic-limit})
\item{}\Label{i:forgetful-history}{history}{\em\ref{i:forgetful-history}}
  The likelihood that xh forgets anything from your command history should
  be inversely proportional to the amount of effort required to
  retype/recreate it.
(\refboth{i:ergonomic-limit}, \refboth{i:universal-prediction})
\item{}\Label{i:locally-anonymous}{anonymous}{\em\ref{i:locally-anonymous}}
  xh must provide a way to accept input and execute commands without
  updating its prediction model.
(\refboth{i:security})
\item{}\Label{i:http-client}{pastebin}{\em\ref{i:http-client}}
  xh should be able to submit an encrypted version of its current state to
  HTTP services like Github gists or pastebin.
\begin{itemize}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:security}
\item \refboth{i:unreliable-connections}
\item \refboth{i:transparent-self-install}
\item \refboth{i:www-initialization}
\end{itemize}

\item{}\Label{i:feel-like-shell}{likeshell}{\em\ref{i:feel-like-shell}}
  xh-script needs to feel like a regular shell for most purposes.
(\refboth{i:shell})
\item{}\Label{i:imperative}{imperative}{\em\ref{i:imperative}}
  xh-script should be fundamentally imperative.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\item \refboth{i:feel-like-shell}
\end{itemize}
\item{}\Label{i:no-oome}{no-oome}{\em\ref{i:no-oome}}
  xh must never run out of memory or swap pages to disk, regardless of what
  you tell it to do.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\item \refboth{i:not-slow}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\item{}\Label{i:nonblocking}{nonblock}{\em\ref{i:nonblocking}}
  xh must respond to every keystroke within 20ms; therefore, SSH must be
  used only for nonblocking RPC requests (i.e.~the shell always runs
  locally).
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:not-slow}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\item{}\Label{i:remote-resources}{remotestuff}{\em\ref{i:remote-resources}}
  All resources, local and remote, must be uniformly accessible;
  i.e.~autocomplete, filename substitution, etc, must all just work (up to
  random access, which is impossible without FUSE or similar).
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:distributed-computation}
\item \refboth{i:ergonomic-limit}
\end{itemize}

\item{}\Label{i:prefix-notation}{prefix}{\em\ref{i:prefix-notation}}
  xh-script uses prefix notation.
(\refboth{i:shell})
\item{}\Label{i:quasiquoting}{quasiquote}{\em\ref{i:quasiquoting}}
  xh-script quasiquotes values by default.
(\refboth{i:shell})
\item{}\Label{i:unquoting}{unquote}{\em\ref{i:unquoting}}
  xh-script defines an unquote operator.
(\refboth{i:shell}, \refboth{i:quasiquoting})

\item{}\Label{i:real-data-structures}{datastruct}{\em\ref{i:real-data-structures}}
  The xh runtime provides real, garbage-collected data structures.
(\refboth{i:real-programming})
\item{}\Label{i:data-structures-can-be-quoted}{quotestruct}{\em\ref{i:data-structures-can-be-quoted}}
  Every xh data structure has a quoted form.
\begin{itemize}
\item \refboth{i:real-data-structures}
\item \refboth{i:shell}
\item \refboth{i:trivial-debugging}
\item \refboth{i:live-preview}
\end{itemize}
\item{}\Label{i:data-structures-can-be-serialized}{printstruct}{\em\ref{i:data-structures-can-be-serialized}}
  Every xh data structure can be losslessly serialized by quoting it. In
  addition, every type of list can be losslessly serialized by coercing it
  to a string; the result can be unquoted to coerce it back to its original
  form.
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:distributed-computation}
\item \refboth{i:trivial-database}
\item \refboth{i:data-structures-can-be-quoted}
\item \refboth{i:settings-contain-variable-definitions}
\item \refboth{i:image-merging}
\end{itemize}
\item{}\Label{i:data-structures-are-immutable}{immutable}{\em\ref{i:data-structures-are-immutable}}
  Data structures have no identity and therefore are immutable. By
  extension, circular references can't be created except by indirection
  through a mutable value.
(\refboth{i:distributed-computation}, \refboth{i:data-structures-can-be-serialized})

\item{}\Label{i:opaque-resources}{opaques}{\em\ref{i:opaque-resources}}
  xh-script must have access to machine-specific opaque resources like PIDs
  and file handles.
(\refboth{i:real-programming}, \refboth{i:shell})
\item{}\Label{i:mutable-symbol-table}{mutablesyms}{\em\ref{i:mutable-symbol-table}}
  Each xh instance should implement a mutable symbol table with weak
  reference support, subject to safe distributed garbage collection.
\begin{itemize}
\item \refboth{i:data-structures-are-immutable}
\item \refboth{i:opaque-resources}
\item \refboth{i:no-oome}
\item \refboth{i:xh-heap}
\end{itemize}
\item{}\Label{i:state-ownership}{stateown}{\em\ref{i:state-ownership}}
  Every piece of mutable state, including symbol tables, must have at most
  one authoritative copy (mutable state ownership within xh is managed by a
  CP system, and the state itself is trivially CP).
\begin{itemize}
\item \refboth{i:unreliable-connections}
\item \refboth{i:opaque-resources}
\item \refboth{i:mutable-symbol-table}
\item \refboth{i:thread-mobility}
\end{itemize}
\item{}\Label{i:checkpointing}{checkpoint}{\em\ref{i:checkpointing}}
  An xh instance should be able to save checkpoints of itself in case of
  failure. If you do this, xh becomes an AP system.
(\refboth{i:unreliable-connections}, \refboth{i:state-ownership})

\item{}\Label{i:lazy-evaluation}{lazy}{\em\ref{i:lazy-evaluation}}
  xh's evaluator must support some kind of laziness.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:no-oome}
\item \refboth{i:remote-resources}
\item \refboth{i:not-slow}
\end{itemize}
\item{}\Label{i:laziness-serializable}{printlazy}{\em\ref{i:laziness-serializable}}
  Lazy values must have well-defined quoted forms and be losslessly
  serializable.
\begin{itemize}
\item \refboth{i:data-structures-can-be-quoted}
\item \refboth{i:data-structures-can-be-serialized}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:thread-mobility}
\item \refboth{i:xh-heap}
\end{itemize}
\item{}\Label{i:lazy-introspection}{introspectlazy}{\em\ref{i:lazy-introspection}}
  All lazy values can be subject to introspection to identify why they
  haven't been realized. This introspection must fully encode xh's
  knowledge about a value, modulo outstanding IO or CPU requests.
\begin{itemize}
\item \refboth{i:trivial-debugging}
\item \refboth{i:not-slow}
\item \refboth{i:unreliable-connections}
\item \refboth{i:nonblocking}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:priority-scheduler}
\end{itemize}
\item{}\Label{i:abstract-evaluation}{abstract}{\em\ref{i:abstract-evaluation}}
  xh must be able to partially evaluate expressions that contain unknown
  quantities.
\begin{itemize}
\item \refboth{i:live-preview}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:lazy-introspection}
\item \refboth{i:laziness-serializable}
\end{itemize}
\item{}\Label{i:code-as-data}{code=data}{\em\ref{i:code-as-data}}
  xh-script code should be a reasonable data storage format.
(\refboth{i:shell}, \refboth{i:abstract-evaluation})
\item{}\Label{i:parse-self}{selfparse}{\em\ref{i:parse-self}}
  xh-script must contain a library to parse itself.
(\refboth{i:code-as-data})
\item{}\Label{i:homoiconic}{homoiconic}{\em\ref{i:homoiconic}}
  xh-script must be homoiconic.
\begin{itemize}
\item \refboth{i:code-as-data}
\item \refboth{i:parse-self}
\item \refboth{i:self-hosting-runtime}
\item \refboth{i:representational-abstraction}
\end{itemize}

\item{}\Label{i:compile-to-c}{xh2c}{\em\ref{i:compile-to-c}}
  xh should be able to compile any function to C, compile it if the host
  has a C compiler, and transparently migrate execution into this process.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:thread-mobility}
\item \refboth{i:not-slow}
\end{itemize}
\item{}\Label{i:compile-to-perl}{xh2perl}{\em\ref{i:compile-to-perl}}
  xh should be able to compile any function to Perl rather than
  interpreting its execution.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:no-root-access}
\item \refboth{i:not-slow}
\end{itemize}
\item{}\Label{i:compile-to-js}{xh2js}{\em\ref{i:compile-to-js}}
  xh should be able to compile any function to Javascript so that browser
  sessions can transparently become computing nodes.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:distributed-computation}
\item \refboth{i:not-slow}
\end{itemize}
\item{}\Label{i:self-hosting-runtime}{selfhost}{\em\ref{i:self-hosting-runtime}}
  xh should follow a bootstrapped self-hosting runtime model.
\begin{itemize}
\item \refboth{i:compile-to-c}
\item \refboth{i:compile-to-perl}
\item \refboth{i:compile-to-js}
\item \refboth{i:representational-abstraction}
\end{itemize}
\item{}\Label{i:tracing-jit}{dynamiccompiler}{\em\ref{i:tracing-jit}}
  xh-script should be executed by a profiling/tracing dynamic compiler that
  automatically compiles certain pieces of code to alternative forms like
  Perl or C.
(\refboth{i:not-slow})
\item{}\Label{i:representational-abstraction}{abstractstruct}{\em\ref{i:representational-abstraction}}
  The xh compiler should optimize data structure representations for the
  backend being targeted.
\begin{itemize}
\item \refboth{i:not-slow}
\item \refboth{i:thread-mobility}
\item \refboth{i:tracing-jit}
\end{itemize}

\item{}\Label{i:xh-heap}{heap}{\em\ref{i:xh-heap}}
  xh needs to implement its own heap and memory manager, and swap values to
  disk without blocking.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:no-oome}
\item \refboth{i:trivial-database}
\item \refboth{i:written-in-perl}
\end{itemize}
\item{}\Label{i:xh-threading}{threading}{\em\ref{i:xh-threading}}
  xh should implement its own threading model to accommodate blocked IO
  requests.
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:distributed-computation}
\item \refboth{i:quick-webserver}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:xh-heap}
\end{itemize}
\item{}\Label{i:priority-scheduler}{threadscheduler}{\em\ref{i:priority-scheduler}}
  xh threads should be subject to scheduling that reflects the user's
  priorities.
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:distributed-computation}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:xh-threading}
\end{itemize}
\item{}\Label{i:thread-mobility}{threadmobility}{\em\ref{i:thread-mobility}}
  Running threads must be transparently portable between machines and
  compiled backends.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:xh-threading}
\item \refboth{i:tracing-jit}
\item \refboth{i:representational-abstraction}
\item \refboth{i:priority-scheduler}
\end{itemize}
\item{}\Label{i:reference-locality}{refaffinity}{\em\ref{i:reference-locality}}
  All machine-specific references must encode the machine for which they
  are defined.
(\refboth{i:opaque-resources}, \refboth{i:thread-mobility})
\item{}\Label{i:unique-ids}{uniqueid}{\em\ref{i:unique-ids}}
  Every xh instance must have a unique ID, ideally one that can be typed
  easily.
(\refboth{i:ergonomic-limit}, \refboth{i:reference-locality})

\item{}\Label{i:transparent-self-install}{selfinstall}{\em\ref{i:transparent-self-install}}
  xh needs to be able to self-install on remote machines with no
  intervention (assuming you have a passwordless SSH connection).
(\refboth{i:distributed-computation}, \refboth{i:no-root-access})
\item{}\Label{i:www-initialization}{wwwinit}{\em\ref{i:www-initialization}}
  You should be able to upload your xh image to a website and then install
  it with a command like this:~\verb+curl me.com/xh | perl+.
(\refboth{i:distributed-computation}, \refboth{i:no-root-access})
\item{}\Label{i:self-modifying-image}{selfmodifying}{\em\ref{i:self-modifying-image}}
  Your settings should be present as soon as you download your image, so
  the image must be self-modifying and contain your settings.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:universal-prediction}
\item \refboth{i:transparent-self-install}
\item \refboth{i:www-initialization}
\end{itemize}
\item{}\Label{i:settings-contain-variable-definitions}{varsinrc}{\em\ref{i:settings-contain-variable-definitions}}
  Your settings should be able to contain any value you can create from the
  REPL (with the caveat that some are defined only with respect to a
  specific machine).
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:real-data-structures}
\item \refboth{i:www-initialization}
\end{itemize}
\item{}\Label{i:written-in-perl}{inperl}{\em\ref{i:written-in-perl}}
  xh should probably be written in Perl 5.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:no-root-access}
\item \refboth{i:transparent-self-install}
\item \refboth{i:www-initialization}
\item \refboth{i:self-modifying-image}
\end{itemize}
\item{}\Label{i:no-perl-modules}{perlcoreonly}{\em\ref{i:no-perl-modules}}
  xh can't have any dependencies on CPAN modules, or anything else that
  isn't in the core library.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:no-root-access}
\item \refboth{i:transparent-self-install}
\end{itemize}
\item{}\Label{i:image-merging}{imagemerging}{\em\ref{i:image-merging}}
  It should be possible to address variables defined within xh images (as
  files or network locations).
(\refboth{i:self-modifying-image}, \refboth{i:settings-contain-variable-definitions})

\item{}\Label{i:rpc-via-ssh}{sshrpc}{\em\ref{i:rpc-via-ssh}}
  xh's RPC protocol must work via stdin/out communication over an SSH
  channel to a remote instance of itself.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:security}
\item \refboth{i:transparent-self-install}
\item \refboth{i:nonblocking}
\item \refboth{i:remote-resources}
\end{itemize}
\item{}\Label{i:rpc-multiplexing}{rpcmulti}{\em\ref{i:rpc-multiplexing}}
  xh's RPC protocol must support request multiplexing.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:not-slow}
\item \refboth{i:nonblocking}
\item \refboth{i:remote-resources}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:rpc-via-ssh}
\end{itemize}
\item{}\Label{i:xh-self-connection}{hostswitch}{\em\ref{i:xh-self-connection}}
  Two xh servers on the same host should automatically connect to each
  other. This allows a server-only machine to act as a VPN.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:no-root-access}
\item \refboth{i:rpc-via-ssh}
\item \refboth{i:transitive-topology}
\end{itemize}
\item{}\Label{i:domain-sockets}{domainsockets}{\em\ref{i:domain-sockets}}
  xh should create a UNIX domain socket to listen for other same-machine
  instances.
(\refboth{i:security}, \refboth{i:xh-self-connection})
\item{}\Label{i:transitive-topology}{transitive}{\em\ref{i:transitive-topology}}
  xh's network topology should forward requests transitively.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:no-root-access}
\item \refboth{i:rpc-via-ssh}
\end{itemize}
\item{}\Label{i:network-routing}{routing}{\em\ref{i:network-routing}}
  xh should implement a network optimizer that responds to observations it
  makes about latency and throughput.
\begin{itemize}
\item \refboth{i:not-slow}
\item \refboth{i:rpc-via-ssh}
\item \refboth{i:transitive-topology}
\end{itemize}
\end{enumerate}

\chapter{xh-script}\label{chp:design-xh-script}
  These constraints are based on the ones in
  \Ref{chapter}{chp:design-constraints}.

\begin{enumerate}
\item{}\Label{is:data-types}{xhs.datatypes}{\em\ref{is:data-types}}
  xh has two fundamental data types, lists and strings.
(\initial)
\item{}\Label{is:list-types}{xhs.listtypes}{\em\ref{is:list-types}}
  Lists have three types, {\tt list}, {\tt array}, and {\tt map},
  corresponding to \verb|()|, \verb|[]|, and \verb|{}|, respectively.
(\initial, \refboth{is:data-types})

\item{}\Label{is:evaluation-identities}{xhs.eval-identities}{\em\ref{is:evaluation-identities}}
  Evaluation of any expression may happen at any time; the only scheduling
  constraint is the realization of lazy expressions, whose status is
  visible by looking at their quoted forms. Therefore, the evaluator is, to
  some degree, associative, commutative, and idempotent.
\begin{itemize}
\item \initial
\item \refboth{i:distributed-computation} above
\item \refboth{i:trivial-debugging} above
\item \refboth{i:live-preview} above
\item \refboth{i:nonblocking} above
\item \refboth{i:lazy-evaluation} above
\item \refboth{i:lazy-introspection} above
\item \refboth{i:abstract-evaluation} above
\end{itemize}

\item{}\Label{is:relational-evaluation}{xhs.relational}{\em\ref{is:relational-evaluation}}
  Relational evaluation is possible by using {\tt amb}, which returns any
  of the given presumably-equivalent values. xh-script is relational and
  invertible, though inversion is not always lossless and may produce
  perpetually-unresolved unknowns representing degrees of freedom.
\begin{itemize}
\item \initial
\item \refboth{i:trivial-debugging} above
\item \refboth{i:lazy-evaluation} above
\item \refboth{i:lazy-introspection} above
\item \refboth{i:abstract-evaluation} above
\item \refboth{i:self-hosting-runtime} above
\item \refboth{i:representational-abstraction} above
\item \refboth{i:priority-scheduler} above
\item \refboth{is:evaluation-identities}
\end{itemize}
\item{}\Label{is:best-first-search}{xhs.bestfirst}{\em\ref{is:best-first-search}}
  Due to functions like {\tt amb}, evaluation proceeds as a best-first
  search through the space of values. You can influence this search by
  defining the {\tt abstraction} relation for a particular class of
  expressions.
(\refboth{i:not-slow} above, \refboth{is:relational-evaluation})
\item{}\Label{is:no-cut-operator}{xhs.nocut}{\em\ref{is:no-cut-operator}}
  Unlike Prolog, xh defines no cut primitive. You should use {\tt
  abstraction} to locally grade the search space instead.
\begin{itemize}
\item \refboth{i:trivial-debugging} above
\item \refboth{is:evaluation-identities}
\item \refboth{is:best-first-search}
\end{itemize}

\item{}\Label{is:unquote-structure-preserving}{xhs.unquote-structure}{\em\ref{is:unquote-structure-preserving}}
  Unquoting is structure-preserving with respect to parsing; that is, it
  will never force a reparse if its argument has already been parsed.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming} above
\item \refboth{i:unquoting} above
\item \refboth{i:not-slow} above
\item \refboth{i:abstract-evaluation} above
\end{itemize}
\item{}\Label{is:stack-local-scoping}{xhs.stackscope}{\em\ref{is:stack-local-scoping}}
  All scoping is done by passing a second argument to {\tt unquote}; this
  enables variable resolution during the unquoting operation.
\begin{itemize}
\item \initial
\item \refboth{i:unquoting} above
\item \refboth{i:mutable-symbol-table} above
\item \refboth{is:evaluation-identities}
\end{itemize}
\item{}\Label{is:no-variable-shadowing}{xhs.noshadow}{\em\ref{is:no-variable-shadowing}}
  Variable shadowing is impossible.
(\refboth{is:evaluation-identities}, \refboth{is:stack-local-scoping})
\item{}\Label{is:unquoting-vs-parsing}{xhs.unquote-parse}{\em\ref{is:unquoting-vs-parsing}}
  Unquoting and structural parsing are orthogonal operations provided by
  {\tt unquote} and {\tt read}, respectively.
\begin{itemize}
\item \refboth{i:data-structures-can-be-quoted} above
\item \refboth{i:lazy-introspection} above
\item \refboth{is:evaluation-identities}
\item \refboth{is:unquote-structure-preserving}
\end{itemize}

\item{}\Label{is:runtime-as-receiver}{xhs.runtimereceiver}{\em\ref{is:runtime-as-receiver}}
  Whether via RPC or locally, statements issued to an xh runtime can be
  interpreted as messages being sent to a receiver; the reply is sent along
  whatever continuation is specified. The runtime doesn't differentiate
  between local and remote requests, including those made by functions.
\begin{itemize}
\item \refboth{i:imperative} above
\item \refboth{i:xh-threading} above
\item \refboth{i:thread-mobility} above
\item \refboth{i:state-ownership} above
\end{itemize}
\item{}\Label{is:function-variable-namespaces}{xhs.namespaces}{\em\ref{is:function-variable-namespaces}}
  Functions and variables exist in separate namespaces.
\begin{itemize}
\item \refboth{i:feel-like-shell} above
\item \refboth{i:unquoting} above
\item \refboth{is:stack-local-scoping}
\item \refboth{is:runtime-as-receiver}
\end{itemize}
\item{}\Label{is:function-literals-as-messages}{xhs.fnliterals}{\em\ref{is:function-literals-as-messages}}
  Function literals are self-invoking when used as messages.
(\refboth{is:function-variable-namespaces})
\item{}\Label{is:no-real-continuations}{nocallcc}{\em\ref{is:no-real-continuations}}
  Continuations are simulated in terms of lazy evaluation, but are never
  first-class.
\begin{itemize}
\item \refboth{i:tracing-jit} above
\item \refboth{i:lazy-introspection} above
\item \refboth{i:abstract-evaluation} above
\item \refboth{is:runtime-as-receiver}
\end{itemize}
\item{}\Label{is:transient-definitions}{xhs.transientdefs}{\em\ref{is:transient-definitions}}
  Some definitions are ``transient,'' in which case they are used to
  resolve blocked lazy values but then may be discarded at any point.
\begin{itemize}
\item \refboth{i:distributed-computation} above
\item \refboth{i:no-oome} above
\item \refboth{i:lazy-evaluation} above
\item \refboth{is:runtime-as-receiver}
\end{itemize}
\item{}\Label{is:global-definition-universality}{xhs.globaldefs}{\em\ref{is:global-definition-universality}}
  Global definitions can apply to values at any time, and to values on
  different machines (i.e.~their existence is broadcast).
(\refboth{i:lazy-evaluation} above, \refboth{is:transient-definitions})

\item{}\Label{is:macros-cannot-exist}{xhs.nomacros}{\em\ref{is:macros-cannot-exist}}
  Syntactic macros cannot exist because invocation commutes with expansion,
  but functions may operate on terms whose values are undefined.
(\refboth{is:evaluation-identities}, \refboth{is:unquote-structure-preserving})
\item{}\Label{is:errors-cannot-exist}{xhs.noerrors}{\em\ref{is:errors-cannot-exist}}
  Errors cannot exist, but are represented by lazy values that contain
  undefined quantities that will never be realized. These undefined
  quantities are the unevaluated backtraces to the error-causing
  subexpressions.
\begin{itemize}
\item \refboth{i:trivial-debugging} above
\item \refboth{i:lazy-evaluation} above
\item \refboth{i:abstract-evaluation} above
\item \refboth{is:evaluation-identities}
\end{itemize}

\item{}\Label{is:arbitrary-destructuring}{xhs.destructuring}{\em\ref{is:arbitrary-destructuring}}
  Any value can be used as a destructuring bind pattern.
(\initial, \refboth{is:relational-evaluation})
\item{}\Label{is:amb-destructuring}{xhs.ambdestructure}{\em\ref{is:amb-destructuring}}
  \verb|(amb)| can be used to destructure values, and it behaves as a
  disjunction.
\begin{itemize}
\item \initial
\item \refboth{is:relational-evaluation}
\item \refboth{is:arbitrary-destructuring}
\end{itemize}
\item{}\Label{is:abstract-dof}{xhs.dof}{\em\ref{is:abstract-dof}}
  Degrees of freedom within an inversion are represented by abstract values
  that will prevent the result from being realized. They are visible as
  unevaluated expressions within the quoted form, usually taking the form
  of calls to \verb|(amb)|.
\begin{itemize}
\item \initial
\item \refboth{is:relational-evaluation}
\item \refboth{is:amb-destructuring}
\end{itemize}
\item{}\Label{is:no-bareword-synthesis}{xhs.nosynbareword}{\em\ref{is:no-bareword-synthesis}}
  Barewords are considered unique symbols; that is, xh will never try to
  synthesize a bareword using string-style semantics.
(\initial)

\item{}\Label{is:side-effects-as-axioms}{xhs.se-axioms}{\em\ref{is:side-effects-as-axioms}}
  Side effects and axioms are the same thing in xh. Once it commits to a
  side-effect, it must always assume that it happened (since it did). In
  particular, this means that imperative forms like {\tt (def)} are
  actually ways to assume new ground truths.
\begin{itemize}
\item \initial
\item \refboth{i:imperative}
\item \refboth{is:relational-evaluation}
\item \refboth{is:global-definition-universality}
\end{itemize}
\item{}\Label{is:hypotheses-are-virtualization}{xhs.virtualization}{\em\ref{is:hypotheses-are-virtualization}}
  Every side effect can be replaced by a temporary assumption that models
  the effect. If you do this, you're replacing an axiom with a hypothesis.
(\initial, \refboth{is:side-effects-as-axioms})
\item{}\Label{is:amb-side-effects}{xhs.amb-se}{\em\ref{is:amb-side-effects}}
  \verb|(amb)| hypothesizes all side effects until you commit to a branch
  using \verb|(def)|.

\item{}\Label{is:maps-as-relations}{xhs.mapsasrelations}{\em\ref{is:maps-as-relations}}
  Maps and relations are isomorphic, which means that \verb|(def)| is a
  stateful form of \verb|(assoc)|, and that map literals can be used as
  functions.
(\initial)
\item{}\Label{is:stable-values}{xhs.stablevalues}{\em\ref{is:stable-values}}
  Maps, arrays, and unquoted atoms are stable under unquoting (e.g.~there
  is no distributive property that would unquote individual values within
  these structures).
(\initial, \refboth{is:maps-as-relations})
\end{enumerate}

\chapter{xh-script syntax}\label{chp:xhs-syntax}
  Design constraints for the syntax in particular.

\begin{enumerate}
\item{}\Label{isyn:reversible-parsing}{syn.reversibleparsing}{\em\ref{isyn:reversible-parsing}}
  The parser for xh is losslessly reversible:~comment data, whitespace, and
  any other aspect of valid xh code is encoded in the parsed
  representation.
(\initial)
\item{}\Label{isyn:tags}{syn.tags}{\em\ref{isyn:tags}}
  Lists, vectors, and maps can each be tagged by immediately prefixing the
  opening brace with a word.
(\initial)
\item{}\Label{isyn:splicing}{syn.splice}{\em\ref{isyn:splicing}}
  A quoted form prefixed with \verb|@| causes list splicing to occur, just
  like Common Lisp's \verb|,@| and Clojure's \verb|~@|. Technically
  \verb|@| is a distributive, right-associative prefix expansion operator
  (sort of like \verb|$| in some ways), so you can layer it to expand
  multiple layers of lists. Any non-lists are treated as lists of a single
  item; \verb|@| is well-defined for all values.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\item{}\Label{isyn:escaping}{syn.escaping}{\em\ref{isyn:escaping}}
  Any character can be prefixed with {\tt \textbackslash} to cause it to be
  interpreted as a string. The only exception is that some escape sequences
  are interpreted, including \verb|\n|, \verb|\t|, and similar.
(\initial, \refboth{i:feel-like-shell})

\item{}\Label{isyn:hash-comments}{syn.hashcomments}{\em\ref{isyn:hash-comments}}
  Comments begin with \verb|#| preceded either by whitespace or the
  beginning of a line. Unlike in many languages, comment data is available
  in the parsed representation of xh source code.
(\refboth{i:feel-like-shell}, \refboth{isyn:reversible-parsing})
\item{}\Label{isyn:string-quoting}{syn.stringquoting}{\em\ref{isyn:string-quoting}}
  Single-quoted and double-quoted strings have exactly the semantics they
  do in Perl or bash; that is, single-quoted strings are oblivious to most
  unquoting features, whereas double-quoted strings are interpolated.
(\refboth{i:feel-like-shell})
\item{}\Label{isyn:expression-interpolation}{syn.stringexpressions}{\em\ref{isyn:expression-interpolation}}
  Within a double-quoted string, you need to prefix any interpolating
  \verb|()| group with a \verb|$| to make it active.
(\refboth{i:trivial-debugging}, \refboth{i:feel-like-shell})
\item{}\Label{isyn:toplevel-expressions}{syn.toplevelexpressions}{\em\ref{isyn:toplevel-expressions}}
  Outside words and quoted strings, \verb|()| does not require a \verb|$|
  prefix to interpolate. Put differently, the \verb|$| is required if and
  only if you are interpolating by same-word string concatenation.
(\refboth{i:real-programming}, \refboth{i:ergonomic-limit})

\item{}\Label{isyn:flat-toplevel-lists}{syn.flattoplevel}{\em\ref{isyn:flat-toplevel-lists}}
  xh's toplevel grammar is based on Tcl, not Lisp; this means that you
  don't need to wrap each statement in parentheses. Line breaks are
  significant unless preceded with {\tt \textbackslash} or inside a list.
  Unlike bash and tcl, all sub-lists are parsed as in Lisp; that is, this
  toplevel syntax applies only at the outermost level.
\begin{itemize}
\item \initial
\item \refboth{i:feel-like-shell}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\end{enumerate}

\chapter{runtime}\label{chp:runtime}
  xh-script operates within a hosting environment that manages things like
  memory allocation and thread/evaluation scheduling. Beyond this, we also need
  a quoted-value format that's more efficient than doing a bunch of string
  manipulation (\refboth{ir:expression-representation},
  \refboth{ir:flat-containers}, \refboth{ir:deduplication}).

\begin{enumerate}
\item{}\Label{ir:priority-queue}{xhr.priorityqueue}{\em\ref{ir:priority-queue}}
  Evaluation always happens as a process of pulling expressions from a
  priority queue.
\begin{itemize}
\item \initial
\item \refboth{is:relational-evaluation}
\item \refboth{is:best-first-search}
\end{itemize}
\item{}\Label{ir:priority-tracing}{xhr.prioritytracing}{\em\ref{ir:priority-tracing}}
  Every expression in the queue knows its ``origin'' for scheduling
  purposes.
(\refboth{is:best-first-search}, \refboth{ir:priority-queue})

\item{}\Label{ir:static-inlining}{xhr.staticinline}{\em\ref{ir:static-inlining}}
  Function compositions should be added as derived definitions to minimize
  the number of symbol-table lookups per unit rewriting distance.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{is:relational-evaluation}
\end{itemize}
\item{}\Label{ir:latency}{xhr.latency}{\em\ref{ir:latency}}
  The runtime should provide low enough latency that it can be used as the
  graph-solving backend for RPC routing.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{i:network-routing}
\end{itemize}
\item{}\Label{ir:value-caching}{xhr.valuecache}{\em\ref{ir:value-caching}}
  To guarantee low latency, the runtime should emit transient values for
  solutions it finds. These become cached bindings that can be kicked out
  under memory pressure, but reduce the load on the optimizer.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{ir:latency}
\end{itemize}

\item{}\Label{ir:expression-representation}{xhr.representation}{\em\ref{ir:expression-representation}}
  Every quasiquoted form with variant pieces should be represented as a
  separate instantiable class.
\begin{itemize}
\item \initial
\item \refboth{i:quasiquoting}
\item \refboth{i:not-slow}
\item \refboth{is:evaluation-identities}
\end{itemize}
\item{}\Label{ir:flat-containers}{xhr.flatcontainers}{\em\ref{ir:flat-containers}}
  Quasiquoted structures are profiled for the distributions of their
  children (upon expansion); for strongly nonuniform distributions,
  specialized flattened container types are generated.
\begin{itemize}
\item \initial
\item \refboth{i:quasiquoting}
\item \refboth{i:not-slow}
\item \refboth{is:evaluation-identities}
\item \refboth{ir:static-inlining}
\item \refboth{ir:expression-representation}
\end{itemize}
\item{}\Label{ir:flat-container-limit}{xhr.flatlimit}{\em\ref{ir:flat-container-limit}}
  Containers should be flattened until the type-encoding overhead is
  minimized for the given (possibly-contextful) distribution of values. In
  practice, this probably means using PPM and Huffman coding with an
  initial noise floor to prevent short-run overfitting.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{ir:flat-containers}
\end{itemize}
\item{}\Label{ir:deduplication}{xhr.deduplication}{\em\ref{ir:deduplication}}
  Every independent value within a quasiquoted form should be referred to
  by a structural signature, in our case SHA-256. This trivially causes
  strings, and by extension execution paths, to be deduplicated. Because we
  assume no hash collisions, xh string values have no defined instance
  affinity (apropos of \refboth{i:reference-locality}).
\begin{itemize}
\item \refboth{i:xh-heap}
\item \refboth{ir:static-inlining}
\item \refboth{ir:expression-representation}
\item \refboth{ir:hinting}
\end{itemize}
\item{}\Label{ir:pointer-entropy}{xhr.pointerentropy}{\em\ref{ir:pointer-entropy}}
  256 bits is sufficient to encode any pointer.
\begin{itemize}
\item \initial
\item \refboth{i:unique-ids}
\item \refboth{i:reference-locality}
\item \refboth{ir:deduplication}
\end{itemize}

\item{}\Label{ir:hinting}{xhr.hinting}{\em\ref{ir:hinting}}
  Expressions should be hinted with tags that track and influence their
  paths through the search space. The optimizer uses machine learning
  against these tags to predict successful search strategies.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{is:best-first-search}
\item \refboth{is:no-cut-operator}
\end{itemize}
\item{}\Label{ir:hashing}{xhr.hashing}{\em\ref{ir:hashing}}
  The runtime should use some type of masked hashing strategy (or other
  decision tree) to minimize the expected resolution time for each
  expression.
(\initial, \refboth{ir:hinting})
\item{}\Label{ir:transient-prediction}{xhr.transientprediction}{\em\ref{ir:transient-prediction}}
  Many functions will end up returning lazy values, and most of the time
  those lazy values will eventually be realized. The runtime should have
  some expectation of which lazy sub-values will be realized, and with what
  probability; this influences its search strategy in the future.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{is:transient-definitions}
\item \refboth{is:best-first-search}
\item \refboth{ir:hinting}
\end{itemize}

\item{}\Label{ir:override}{xhr.override}{\em\ref{ir:override}}
  The user must be able to completely override any strategy preferences the
  runtime has. The runtime can be arbitrarily wrong and the user can be
  arbitrarily right.
\begin{itemize}
\item \initial
\item \refboth{is:best-first-search}
\item \refboth{ir:hinting}
\item \refboth{ir:transient-prediction}
\end{itemize}
\item{}\Label{ir:external-strategy}{xhr.externalstrategy}{\em\ref{ir:external-strategy}}
  The xh runtime does not itself define the evaluation strategy, nor does
  it internally observe things; this is done as part of the evaluation
  functions in the standard library. The only thing the xh runtime provides
  is a scheduled/prioritized event loop.
\begin{itemize}
\item \initial
\item \refboth{i:abstract-evaluation}
\item \refboth{i:code-as-data}
\item \refboth{ir:override}
\end{itemize}
\item{}\Label{ir:evaluator-api}{xhr.evaluatorapi}{\em\ref{ir:evaluator-api}}
  Evaluator functions are straightforward to write, and the standard
  library includes several designed for different use cases (e.g.~local,
  distributed, profiling). Any significantly nontrivial aspect of it is
  factored off into an API.
\begin{itemize}
\item \initial
\item \refboth{ir:override}
\item \refboth{ir:external-strategy}
\end{itemize}
\item{}\Label{ir:evaluator-base}{xhr.evaluatorbase}{\em\ref{ir:evaluator-base}}
  The runtime is itself subject to evaluation (since it's self-hosting),
  and the base evaluator is implemented in Perl, C, or Javascript. This
  base evaluator runs locally; the distributed evaluator runs on top of it.
\begin{itemize}
\item \initial
\item \refboth{i:compile-to-perl}
\item \refboth{i:compile-to-c}
\item \refboth{i:compile-to-js}
\item \refboth{i:written-in-perl}
\item \refboth{i:self-hosting-runtime}
\item \refboth{ir:override}
\item \refboth{ir:evaluator-api}
\end{itemize}

\item{}\Label{ir:cryptographic-limit}{xhr.cryptographic}{\em\ref{ir:cryptographic-limit}}
  Any function can be modeled as a cipher and subject to forms of
  cryptanalysis to discover structure. The worst case is a truly random
  mapping that requires each permutation to be evaluated independently.
  (This is relevant for code synthesis, which is an inversion of the
  evaluator.)
(\initial, \refboth{is:relational-evaluation})
\item{}\Label{ir:uniformity-reduction}{xhr.uniformityreduction}{\em\ref{ir:uniformity-reduction}}
  Entropy can be reduced by biasing otherwise uniform distributions of
  \verb|(amb)| alternatives, possibly by looking at context. This can be
  done using real-world data, if any exists.
(\refboth{ir:cryptographic-limit})
\item{}\Label{ir:separability}{xhr.separability}{\em\ref{ir:separability}}
  Entropy can be reduced by identifying input separability or other such
  structure. This is done through cryptanalysis, which must ultimately be
  verified structurally even if observed empirically.\footnote{{\bf
  TODO:}~is this really true? If so, we're in an awkward place where
  inference is concerned.}
(\refboth{ir:cryptographic-limit})
\end{enumerate}

\chapter{computational abstraction}\label{chp:computational-abstraction}
\begin{enumerate}
\item{}\Label{ica:structured-programming}{ca.structured}{\em\ref{ica:structured-programming}}
  All compilation is run through a structured programming layer that has
  abstractions for numeric operations and basic control flow. Shortcuts for
  higher-level operations are provided to leverage platform-specific
  optimized libraries.
\begin{itemize}
\item \initial
\item \refboth{i:compile-to-c}
\item \refboth{i:compile-to-perl}
\item \refboth{i:compile-to-js}
\end{itemize}

\item{}\Label{ica:variable-width-integers}{ca.varwidthint}{\em\ref{ica:variable-width-integers}}
  Integer operations have signed and unsigned variants, and exist at any
  bit width. xh doesn't restrict to 32/64 bits (or other common values)
  because not all backends, e.g.~Perl and Javascript, support all bit
  widths natively.
(\initial, \refboth{i:written-in-perl})
\item{}\Label{ica:floating-point}{ca.float}{\em\ref{ica:floating-point}}
  Floating-point operations are defined for 32-bit and 64-bit floats. These
  are present on every sane platform.
(\initial)
\item{}\Label{ica:flat-memory}{ca.flatmemory}{\em\ref{ica:flat-memory}}
  We can't assume that the underlying backend provides any data structures
  for us; we just address memory as a flat bunch of bytes. It's necessary
  to do this because we implement our own memory paging.
(\refboth{i:not-slow}, \refboth{i:no-oome})

\item{}\Label{ica:harvard-architecture}{ca.harvard}{\em\ref{ica:harvard-architecture}}
  Data memory is separate from instructions; this abstraction has no
  homoiconicity at all. It's ok to do this here because all code at this
  level is backend-specific and machine generated. The only exception to
  this is that you can refer to function pointers, but they're assumed to
  be untyped and opaque.
\begin{itemize}
\item \initial
\item \refboth{i:compile-to-c}
\item \refboth{i:compile-to-perl}
\item \refboth{i:compile-to-js}
\item \refboth{ica:flat-memory}
\end{itemize}

\item{}\Label{ica:user-gc}{ca.usergc}{\em\ref{ica:user-gc}}
  All garbage collectors are implemented in xh-script and compiled into the
  flat memory model.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:imperative}
\item \refboth{i:compile-to-c}
\item \refboth{i:compile-to-perl}
\item \refboth{i:compile-to-js}
\item \refboth{ica:flat-memory}
\item \refboth{ica:harvard-architecture}
\end{itemize}
\item{}\Label{ica:lazy-gc}{ca.lazygc}{\em\ref{ica:lazy-gc}}
  Garbage collectors are lazy, since the heap is useful as a cache and is
  swapped to disk.
\begin{itemize}
\item \refboth{i:no-oome}
\item \refboth{is:relational-evaluation}
\item \refboth{is:best-first-search}
\item \refboth{is:transient-definitions}
\item \refboth{is:global-definition-universality}
\item \refboth{ica:flat-memory}
\end{itemize}
\item{}\Label{ica:gc-locality}{ca.gclocality}{\em\ref{ica:gc-locality}}
  GC is a strictly local process; all values sent over RPCs are quoted. The
  only exception is for mutable resources, which can be referred to
  remotely by acquiring a unique reference to it. When those references are
  no longer referred to, the remote instance notifies the owner. If the
  remote instance drops offline, any references it holds are invalidated.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:unreliable-connections}
\item \refboth{i:remote-resources}
\item \refboth{i:data-structures-can-be-serialized}
\item \refboth{i:data-structures-are-immutable}
\item \refboth{i:state-ownership}
\item \refboth{ica:user-gc}
\end{itemize}

\item{}\Label{ica:user-profiling}{ca.userprofiling}{\em\ref{ica:user-profiling}}
  Profiling is implemented as an xh-script library and is compiled into
  each backend automatically.
\begin{itemize}
\item \initial
\item \refboth{i:compile-to-c}
\item \refboth{i:compile-to-perl}
\item \refboth{i:compile-to-js}
\item \refboth{i:not-slow}
\item \refboth{is:relational-evaluation}
\end{itemize}

\item{}\Label{ica:user-relational}{ca.userrelational}{\em\ref{ica:user-relational}}
  Relational evaluation is implemented as an xh-script library that is then
  compiled into each backend automatically. Because of this self reference,
  the xh image contains two implementations of the relational evaluator.
\begin{itemize}
\item \initial
\item \refboth{i:compile-to-c}
\item \refboth{i:compile-to-perl}
\item \refboth{i:compile-to-js}
\item \refboth{is:relational-evaluation}
\end{itemize}
\item{}\Label{ica:backend-relational}{ca.backendrelational}{\em\ref{ica:backend-relational}}
  Because the computational abstraction is xh-script hosted, compiler
  backends assume a relational evaluator.
(\initial, \refboth{ica:user-relational})

\item{}\Label{ica:compiled-instances}{ca.compiledinstances}{\em\ref{ica:compiled-instances}}
  Every image compiled into a backend becomes a connected xh instance with
  an independently-managed heap, symbol table, etc. Communication is done
  via the usual RPC protocol. In a sense, the default xh image is one that
  has been precompiled into Perl.
\begin{itemize}
\item \initial
\item \refboth{i:distributed-computation}
\item \refboth{i:not-slow}
\end{itemize}
\item{}\Label{ica:compiled-instance-visibility}{ca.compiledvisibility}{\em\ref{ica:compiled-instance-visibility}}
  Compiled images are visible in the global xh network topology.
(\refboth{ica:compiled-instances})
\item{}\Label{ica:self-management}{ca.selfmanagement}{\em\ref{ica:self-management}}
  Compiled images don't have managing instances; that is, they are expected
  to recompile themselves in response to any profile-guided optimization.
(\refboth{ica:compiled-instances}, \refboth{ica:compiled-instance-visibility})
\item{}\Label{ica:no-speculative-multiplicity}{ca.nomultiplicity}{\em\ref{ica:no-speculative-multiplicity}}
  Images can't spontaneously multiply for the purpose of exploring the
  space of possible optimizations. This would require some kind of instance
  GC process, which is beyond the scope of xh. The only exception is that
  every compiler backend can create a new instance, obviously, since
  runtimes in different languages don't tend to work together trivially.
(\refboth{ica:self-management})
\item{}\Label{ica:multiple-instances-per-machine}{ca.mipermachine}{\em\ref{ica:multiple-instances-per-machine}}
  Even if xh is careful about the number of instances it creates, there
  will be multiple instances per physical machine.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{ica:compiled-instances}
\item \refboth{ica:compiled-instance-visibility}
\end{itemize}

\item{}\Label{ica:machine-id}{ca.machineid}{\em\ref{ica:machine-id}}
  xh instances need a way to unambiguously identify a machine, even when
  the topology spans multiple networks (so there may be hostname
  collisions).
\begin{itemize}
\item \refboth{i:remote-resources}
\item \refboth{i:opaque-resources}
\item \refboth{ica:multiple-instances-per-machine}
\end{itemize}
\item{}\Label{ica:uuid-machine-ids-are-ok}{ca.machineiduuid}{\em\ref{ica:uuid-machine-ids-are-ok}}
  Hostnames as aliases for machine UUIDs is an acceptable strategy for
  dealing with machine identification. It's important to make the names as
  human-friendly as possible.
(\refboth{i:ergonomic-limit}, \refboth{ica:machine-id})
\end{enumerate}

\chapter{feasibility of relational evaluation}\label{chp:relational-feasibility}
  Writing a compiler in a relational framework is slightly insane because
  there's a fine line between judiciously combining known strategies for things
  and synthesizing algorithms. The only way for the problem to be remotely
  tractable is for us to either use heuristics, or to cache solutions
  somewhere. xh does the latter.

  The idea of a ``solution'' deserves some discussion. xh doesn't need to know
  answers to questions, but it does need to have something that decreases the
  entropy of the search space. Specifically, xh most likely has a synthesis
  rate of 20 bits per minute if we're lucky, and that number goes up
  exponentially with additional bits (though not if the bits are separable,
  which xh can figure out using differential cryptanalysis).

  Using techniques like cryptanalysis is ideal because it allows the core
  relational evaluator to be unbiased; any optimizations it makes are
  empirically verified first. Verification is itself not quite trivial, since
  xh won't always have a predictive model to prove things (and proving things
  is hard in any case). To get around this, xh is allowed to assume that
  correlations it observes are reproducible.\footnote{This may be suggested by
    Occam's Razor, depending on how you look at it, though it's still a weak
    form of the causation-from-correlation inference fallacy.}

  More specifically, xh needs to deal with:

\begin{enumerate}
\item{Black-box systems (so no analytical solutions or proofs)}
\item{Time-variant systems}
\item{Noisy systems}
\end{enumerate}

  All of these can be mitigated to some extent by repeated observation. In
  particular, $H(\textrm{model}) \le H(\textrm{observations})$ obviously
  applies. In practice, this is unlikely to be a problem; it's fine if xh never
  fully understands the systems it's dealing with as long as it observes the
  most visible/important aspects.

  Fitting a model to observation data is itself subject to optimization; not
  all models are equally probable. xh is more about the expected than the worst
  case, so biasing the space of approximators to reduce modeling entropy is
  fair game.

  Modeling solutions is related to the representational optimization implied by
  \refboth{ir:flat-container-limit}, which gives us a convenient way to
  quantify optimization:~an optimal program has the highest computational
  throughput per unit time. In practical terms, this means that (1) the
  representations of data tend to be small/efficient, and (2) they are moved
  through components that can process them quickly (i.e.~no significant
  bottlenecks). Because this system is modeled as a throughput problem, the
  network routing logic from \refboth{i:network-routing} applies to algorithm
  optimization.

  Success/failure prediction is nontrivial because values don't have to be
  fully realized to be useful. For example, suppose we have two ways to
  generate the first 4KB of a string, one of which also produces the next 4KB
  quickly and one of which never realizes it. If all we need is the first 1KB,
  then the second 4KB of the string doesn't matter. So the question isn't what
  realizes the value as a whole, it's what ends up causing the value to block
  evaluation later on. We want to predict and minimize blocking.

  Another way to put it is that we want to minimize the time until a value can
  be garbage-collected. ({\bf TODO:}~is this true? What are the implications?)

\chapter{feasibility of representational abstraction}\label{chp:ra-feasibility}
  Given \refboth{i:data-structures-are-immutable}, representational abstraction
  is just a question of whole-value encoding; we don't have to worry about
  things like updating a value in place. The goal of representational
  abstraction is to generate value encodings that minimize the expected heap
  size, which can happen easily during garbage collection (since the heap gets
  copied in any case). There will end up being several such encodings for any
  given type of value, and the optimizer will choose different ones depending
  on the use case. The presence of such alternatives implies the existence of
  transcoding functions, which means that $n$ alternatives require $O(n^2)$
  code space (and possibly more because representations are sometimes mutually
  dependent). We can mitigate this slightly by generating these functions
  lazily.

  Concretely speaking, representational abstraction applies to strings and
  lists, which are the only two data types in xh (\refboth{is:data-types}).
  This makes analysis interesting because there isn't much of a distinction
  between types and values; for example, {\tt 3.141592} is a bare string that
  can be interpreted as a number. Most of the typeful semantics of xh are built
  around structured transformations of quoted values, so any type inference
  involves predicting which transformations will apply
  (\Ref{chapter}{chp:quoted-value-relations}).

  We also need to enable recursive abstraction to handle things like
  Church-encoded numbers. Generated representations are subject to exactly the
  same optimization strategies that apply to primitives.

\chapter{quoted value relations}\label{chp:quoted-value-relations}
  xh functions are implemented as string$\rightarrow$string relations whose
  operands bind in ways consistent with the fundamental structure of the
  language. That is, list forms are always fully matched; it isn't possible to
  match an unescaped open bracket alone, for example. Fundamental structure
  includes the following constructs:

\begin{verbatim}
(x1 x2 ... xN)      # paren-list
[x1 x2 ... xN]      # bracket-list
{x1 x2 ... xN}      # brace-list
"stuff"             # double-quoted string atom
'stuff'             # single-quoted string atom
word                # unquoted, untyped atom
\end{verbatim}

  Of these, lists, double-quoted atoms, and unquoted atoms are subject to
  interpolation:

\begin{verbatim}
$x                  # variable value as a single element
!x                  # quoted variable value
(f x y ...)         # function result interpolation
!(f x y ...)        # quoted function result
\end{verbatim}

\begin{enumerate}
\item{}\Label{iqvr:unwrap}{qvr.unwrap}{\em\ref{iqvr:unwrap}}
  \verb|@| is a right-associative prefix operator that unwraps one layer of
  lists. For example, if \verb|$x = [[1 2] [3 4]]|, then \verb|@@$x| would
  be \verb|1 2 3 4|. Any scalars are treated as single-element lists.
\item{}\Label{iqvr:quoted}{qvr.quoted}{\em\ref{iqvr:quoted}}
  \verb|!| and \verb|$| are two ways to dereference something; \verb|$|
  (implied if you use \verb|()|) may block until a complete value is
  available, whereas \verb|!| immediately quotes the value in whatever
  state of evaluation it happens to be in
  (\refboth{i:data-structures-can-be-quoted},
  \refboth{i:laziness-serializable}). You can use quoted-value
  introspection and evaluation functions to inspect and progress the state
  of such a value.
\item{}\Label{iqvr:unquote}{qvr.unquote}{\em\ref{iqvr:unquote}}
  \verb|$| is a prefix operator that unquotes things until they converge to
  their asymptotic value limit. \verb|()| is a special form that calls a
  function, returning its unquoted result (\refboth{is:maps-as-relations});
  function calls are different from general unquoting in that unquoting is
  a strictly static operation, whereas function calls cause values to be
  rerun through relations. Within a double-quoted string, \verb|()| must be
  written as \verb|$()| (\refboth{isyn:string-quoting}).
\end{enumerate}

  Destructuring constructs provide some degree of type selection. For example,
  lists are typeful:

\begin{verbatim}
[@$xs]              # matches [1 2 3], but not (1 2 3) or {1 2 3}
(amb [@$xs] {@$xs}) # matches [1 2 3] and {1 2 3}, but not (1 2 3)
\end{verbatim}

  Strings are structure-preserving, which means you can write parsers using
  destructuring notation. For example, the following parses $a^nb^nc$:

\begin{verbatim}
def (rep 0 $x) ''
def (rep $n $x) "$x$(rep (dec $n) $x)"
def (parse "$(rep $n a)$(rep $n b)c") ...
\end{verbatim}

  The same kind of logic applies to lists by the following isomorphism:

\begin{verbatim}
def (list->string []) ''
def (list->string [$x @$xs]) "$x$(list->string [@$xs])"
\end{verbatim}

\part{base implementation}\label{part:base-implementation}
\chapter{self-replication}\label{chp:self-replication}
\lstset{caption={boot/xh-header},name={boot/xh-header}}\begin{perlcode}
#!/usr/bin/env perl
#<body style='display:none'><script id='self' type='xh'>
BEGIN {eval($::xh_bootstrap = q{
# xh | https://github.com/spencertipping/xh
# Copyright (C) 2014, Spencer Tipping
# Licensed under the terms of the MIT source code license
use 5.014;
package xh;
our %modules;
our @module_ordering;
our %eval_numbers = (1 => '$xh_bootstrap');

sub with_eval_rewriting(&) {
  my @result = eval {$_[0]->(@_[1..$#_])};
  die $@ =~ s/\(eval (\d+)\)/$eval_numbers{$1}/egr if $@;
  @result;
}

sub named_eval {
  my ($name, $code) = @_;
  $eval_numbers{$1 + 1} = $name if eval('__FILE__') =~ /\(eval (\d+)\)/;
  with_eval_rewriting {eval $code; die $@ if $@};
}

our %compilers = (
  pl => sub {
    my $package = $_[0] =~ s/\./::/gr;
    eval {named_eval $_[0], "{package ::$package;\n$_[1]\n}"};
    die "error compiling module $_[0]: $@" if $@;
  },
  html => sub {});

sub defmodule {
  my ($name, $code, @args) = @_;
  chomp($modules{$name} = $code);
  push @module_ordering, $name;
  my ($base, $extension) = split /\.(\w+$)/, $name;
  die "undefined module extension '$extension' for $name"
    unless exists $compilers{$extension};
  $compilers{$extension}->($base, $code, @args);
}

chomp($modules{bootstrap} = $::xh_bootstrap);
undef $::xh_bootstrap; \end{perlcode}

  At this point we need a way to reproduce the image. Since the bootstrap code
  is already stored, we can just wrap it and each defined module into an
  appropriate \verb|BEGIN| block.

\lstset{caption={boot/xh-header (continued)},name={boot/xh-header}}\begin{perlcode}
sub serialize_module {
  my ($module)   = @_;
  my $contents   = $modules{$module};
  my $terminator = '_';
  $terminator .= '_' while $contents =~ /^$terminator$/m;
  join "\n", "BEGIN {xh::defmodule('$module', <<'$terminator')}",
             $contents,
             $terminator;
}

sub image {
  join "\n", "#!/usr/bin/env perl",
             "#<body style='display:none'><script type='xh'>",
             "BEGIN {eval(\$::xh_bootstrap = <<'_')}",
             $modules{bootstrap},
             '_',
             map(serialize_module($_), grep !/\.html$/, @module_ordering),
             "#</" . "script>",
             map(serialize_module($_), grep  /\.html$/, @module_ordering),
             "xh::main::main;\n__DATA__";
}
})} \end{perlcode}

  Here's a quick test implementation of \verb|xh::main::main|; its purpose is
  to make sure replication works. This won't be present in real images:

\lstset{caption={src/test/main.pl},name={src/test/main.pl}}\begin{perlcode}
BEGIN {xh::defmodule('xh::main.pl', <<'_')}
sub main {
  # TESTCODE (FIXME if in a real image)
  print ::xh::image if grep /^--recompile/, @ARGV;

  if (grep /^--repl/, @ARGV) {
    print STDERR "> ";
    while (<STDIN>) {
      chomp;
      if (length) {
        eval {
          my ($parsed) = xh::corescript::parse $_;
          my $result =
            eval {xh::corescript::evaluate($parsed,
                                           $xh::corescript::global_bindings,
                                           2)};
          print $@ ? "! $@\n"
                   : "= " . $result->str . "\n";
        };
        print "! $@\n" if $@;
      }
      print STDERR "> ";
    }
  }
}
_ \end{perlcode}

\chapter{xh-core script}\label{chp:xh-core-script}
  xh-script is complicated, and it would be overkill to write a complete parser
  in Perl considering that we'll end up needing a self-hosting parser later on.
  Instead, we define a sub-language called {\em xh-core script} that consists
  of assembly-level commands. This language is a syntactic subset of xh-script
  whose execution semantics are linear and imperative, and as such can be
  trivially compiled to Perl or Javascript (not C because we'll need a GC
  first).

  This sublanguage uses a simplified form of {\tt def} that produces
  traditional functions. As a result, defined things cannot use destructuring
  binds and are monomorphic under the symbol name. xh-core script also doesn't
  support any string interpolation or other magic syntax.

\lstset{caption={src/corescript.pl},name={src/corescript.pl}}\begin{perlcode}
BEGIN {xh::defmodule('xh::corescript.pl', <<'_')}
sub parse;
sub evaluate;

sub into_hash {
  my %result;
  for (my $i = 0; $i < @_; $i += 2) {
    my $k = ref($_[$i]) ? $_[$i]->str : $_[$i];
    $result{$k} = $_[$i + 1];
  }
  \%result;
}

sub xh::corescript::literal::new  {my ($c, $x) = @_; bless \$x, $c}
sub xh::corescript::var::new      {my ($c, $x) = @_; bless \$x, $c}
sub xh::corescript::list::new     {bless [@_[1..$#_]], $_[0]}
sub xh::corescript::array::new    {bless [@_[1..$#_]], $_[0]}
sub xh::corescript::hash::new     {bless into_hash(@_[1..$#_]), $_[0]}
sub xh::corescript::bindings::new {bless [$_[1], $_[2]], $_[0]}
sub xh::corescript::fn::new       {bless [$_[1], $_[2]], $_[0]}
sub xh::corescript::native::new   {bless [$_[1], $_[2]], $_[0]}
sub xh::corescript::delay::new    {bless [@_[1..$#_]], $_[0]}

sub xh::corescript::literal::concrete  {1}
sub xh::corescript::var::concrete      {0}
sub xh::corescript::list::concrete     {0}
sub xh::corescript::array::concrete    {1}
sub xh::corescript::hash::concrete     {1}
sub xh::corescript::bindings::concrete {1}
sub xh::corescript::fn::concrete       {1}
sub xh::corescript::native::concrete   {1}
sub xh::corescript::delay::concrete    {0}

sub xh::corescript::literal::true  { length ${$_[0]} && ${$_[0]} ne '0' }
sub xh::corescript::var::true      {1}
sub xh::corescript::list::true     {1}
sub xh::corescript::array::true    {1}
sub xh::corescript::hash::true     {1}
sub xh::corescript::bindings::true {1}
sub xh::corescript::fn::true       {1}
sub xh::corescript::native::true   {1}
sub xh::corescript::delay::true    {1}

sub strhash {
  my $h = 0;
  $h = $h * 33 ^ ord for split //, $_[0];
  $h;
}

sub arrayhash {
  my $h = 0;
  $h = $h * 65 ^ (ref($_) ? $_->hashcode : strhash($_)) for @_;
  $h;
}

sub hashhash {
  my @ks = sort keys %{$_[0]};
  arrayhash(@ks) ^ arrayhash(@{$_[0]}{@ks});
}

sub xh::corescript::literal::hashcode  { strhash ${$_[0]} }
sub xh::corescript::var::hashcode      { ~strhash ${$_[0]} }
sub xh::corescript::list::hashcode     { arrayhash @{$_[0]} }
sub xh::corescript::array::hashcode    { 1 + arrayhash @{$_[0]} }
sub xh::corescript::hash::hashcode     { hashhash $_[0] }

sub xh::corescript::bindings::hashcode {
  (defined ${$_[0]}[0] ? $$_[0]->hashcode : 0) ^ hashhash ${$_[0]}[1];
}

sub xh::corescript::fn::hashcode     { strhash(${$_[0]}[0])
                                     ^ ${$_[0]}[1]->hashcode }
sub xh::corescript::native::hashcode { 65 * strhash(${$_[0]}[0]) }
sub xh::corescript::delay::hashcode  { ${$_[0]}[0]->hashcode
                                     ^ arrayhash @{$_[0]}[1..$#{$_[0]}] }

# shorthands
use constant literal  => 'xh::corescript::literal';
use constant var      => 'xh::corescript::var';
use constant list     => 'xh::corescript::list';
use constant hash     => 'xh::corescript::hash';
use constant array    => 'xh::corescript::array';
use constant bindings => 'xh::corescript::bindings';
use constant fn       => 'xh::corescript::fn';
use constant native   => 'xh::corescript::native';
use constant delay    => 'xh::corescript::delay';

use constant REF_IDS => 0;

our $deadline = 0;
our %globals;
our $global_bindings = bindings->new(undef, \%globals);

our $apply = literal->new('apply');

sub quote_call {
  my ($f, $xs) = @_;
  ref($xs) eq array ? list->new($f, @$xs)
                    : list->new($apply, $f, $xs);
}

sub ref_id {
  return '' unless REF_IDS and time > $deadline;
  ($_[0] =~ s/^.*\(0x..(...).*$/$1/r) . ':';
}

sub xh::corescript::literal::str {
  my $s = ${$_[0]};
  ref_id($_[0]) .
  ($s =~ /['()[]{},\s]|^$/ ? "'" . (${$_[0]} =~ s/'/\\'/gr) . "'"
                           : $s);
}

sub xh::corescript::var::str   { ref_id($_[0]) . "\$${$_[0]}" }
sub xh::corescript::list::str  { ref_id($_[0]) .
                                 '(' . join(' ', map $_->str, @{$_[0]})
                                     . ')' }

sub xh::corescript::array::str { ref_id($_[0]) .
                                 '[' . join(' ', map $_->str, @{$_[0]})
                                     . ']' }

sub xh::corescript::hash::str {
  ref_id($_[0]) .
  '{' . join(', ', map $_ . ' ' . ${$_[0]}{$_}->str, sort keys %{$_[0]})
      . '}';
}

sub xh::corescript::bindings::str {
  my ($self) = @_;
  my ($parent, $h) = @$self;
  ref_id($_[0]) .
  '(bindings ' . ($parent ? $parent->str : "''")
         . ' ' . join(', ', map "$_ " . $$h{$_}->str, sort keys %$h) . ')';
}

sub xh::corescript::fn::str {
  my ($self) = @_;
  my ($formal, $body) = @$self;
  ref_id($_[0]) . "(fn* $formal " . $body->str . ')';
}

sub xh::corescript::native::str {
  my ($self) = @_;
  ref_id($_[0]) . "\$$$self[0]";
}

sub xh::corescript::delay::str {
  my ($self) = @_;
  ref_id($_[0]) . '(delay ' . join(' ', map $_->str, @$self) . ')';
}

sub xh::corescript::bindings::get {
  my ($self, $x) = @_;
  my ($parent, $h) = @$self;
  return undef unless ref($x) eq literal or ref($x) eq var;
  my $binding = $$h{$x->name} // ($parent && $parent->get($x));
  ref($binding) ? $binding : undef;
}

sub xh::corescript::bindings::contains {
  my ($self, $x) = @_;
  my ($parent, $h) = @$self;
  exists($$h{$x->name}) || $parent && $parent->contains($x);
}

sub xh::corescript::hash::get {
  my ($self, $x) = @_;
  $$self{$x->str};
}

sub xh::corescript::hash::contains {
  my ($self, $x) = @_;
  exists $$self{$x->str};
}

sub xh::corescript::array::get {
  my ($self, $x) = @_;
  return undef unless ref($x) eq literal;
  my $i = $x->name;
  die "array index must be number (got $i instead)" unless $i eq $i + 0;
  $$self[$i];
}

*xh::corescript::list::get = *xh::corescript::array::get;

sub xh::corescript::literal::get {
  my ($self, $x) = @_;
  return undef unless ref($x) eq literal;
  my $i = $x->name;
  die "literal index must be number (got $i instead)" unless $i eq $i + 0;
  literal->new(ord substr $$self, $i, 1);
}

sub xh::corescript::var::name     { ${$_[0]} }
sub xh::corescript::literal::name { ${$_[0]} }
sub xh::corescript::native::name  { ${$_[0]}[0] }

sub xh::corescript::literal::eval  { $_[0] }
sub xh::corescript::native::eval   { $_[0] }
sub xh::corescript::bindings::eval { $_[0] }

sub xh::corescript::var::eval { my ($self, $bindings) = @_;
                                $bindings->get($self) // $self }

sub xh::corescript::list::eval {
  my ($self, $bindings) = @_;
  my ($f, @xs) = @$self;
  my $r = $f->invoke($bindings, array->new(@xs));
  return $r if defined $r;
  my @e = map $_->eval($bindings), @$self;
  $e[0] = $bindings->get($e[0]) // $e[0]
    if ref($e[0]) eq literal or ref($e[0]) eq var;
  $$self[$_] eq $e[$_] or return list->new(@e) for 0..$#e;
  $self;
}

sub xh::corescript::array::eval {
  my ($self, $bindings) = @_;
  my @e = map $_->eval($bindings), @$self;
  $$self[$_] eq $e[$_] or return array->new(@e) for 0..$#e;
  $self;
}

sub xh::corescript::hash::eval {
  my ($self, $bindings) = @_;
  my %new;
  my $changed = 0;
  for (keys %$self) {
    my $v0 = $$self{$_};
    my $v  = $new{$_} = $v0->eval($bindings);
    last if $changed = $v ne $v0;
  }
  if ($changed) {
    $new{$_} //= $$self{$_}->eval($bindings) for keys %$self;
    hash->new(%new);
  } else {
    $self;
  }
}

sub xh::corescript::fn::eval {
  my ($self, $bindings) = @_;
  my ($formal, $body) = @$self;
  my $newbody = $body->eval(
    bindings->new($bindings, {$formal => 0}));
  $body eq $newbody ? $self
                    : fn->new($formal, $newbody);
}

sub xh::corescript::delay::eval {
  my ($self, $bindings) = @_;
  my ($values, @body) = @$self;
  for my $x (@$values) {
    if (!$x->concrete && $x eq $x->eval($bindings)) {
      my @e = map $_->eval($bindings), @body;
      $body[$_] eq $e[$_] or return delay->new($values, @e) for 0..$#e;
      return $self;
    }
  }
  list->new(@body)->eval($bindings);
}

sub xh::corescript::var::invoke {
  my ($self, $bindings, $args) = @_;
  my $e = $self->eval($bindings);
  return undef if $e eq $self;
  $e->invoke($bindings, $args);
}

sub xh::corescript::literal::invoke {
  my ($self, $bindings, $args) = @_;
  my $f = $bindings->get($self);
  return undef unless defined $f;
  $f->invoke($bindings, $args);
}

sub xh::corescript::list::invoke {
  my ($self, $bindings, $args) = @_;
  die quote_call($self, $args)->str . ': timeout expired'
    if $deadline and time > $deadline;

  my $evaled = $self->eval($bindings);
  return undef if $self eq $evaled;

  my $result = eval {$evaled->invoke($bindings, $args)};
  my $error = $@;
  if ($error) {
    print STDERR quote_call($self, $args)->str, ': ', $error, "\n";
    die $error;
  } else {
    $result;
  }
}

sub xh::corescript::delay::invoke {
  my ($self, $bindings, $args) = @_;
  die quote_call($self, $args)->str . ': timeout expired'
    if $deadline and time > $deadline;

  my $e = $self->eval($bindings);
  return undef if $e eq $self;
  my $result = eval {$e->invoke($bindings, $args)};
  my $error = $@;
  if ($error) {
    print STDERR quote_call($self, $args)->str, ': ', $error, "\n";
    die $error;
  } else {
    $result;
  }
}

sub xh::corescript::fn::invoke {
  my ($self, $bindings, $args) = @_;
  die quote_call($self, $args)->str . ': timeout expired'
    if $deadline and time > $deadline;

  my ($formal, $body) = @$self;
  my $result = eval {
    $body->eval(bindings->new($global_bindings,
                              {$formal => $args->eval($bindings)}));
  };
  my $error = $@;
  if ($error) {
    print STDERR quote_call($self, $args)->str, ': ', $error, "\n";
    die $error;
  } else {
    $result;
  }
}

sub xh::corescript::native::invoke {
  my ($self, $bindings, $args) = @_;
  die quote_call($self, $args)->str . ': timeout expired'
    if $deadline and time > $deadline;

  my (undef, $f) = @$self;
  $args = $args->eval($bindings);
  my $result = eval {$f->($bindings, @$args)};
  my $error  = $@;
  if ($error) {
    print STDERR quote_call($self, $args)->str, ': ', $error, "\n";
    die $error;
  } else {
    $result;
  }
}

our $y     = literal->new('y');
our $nil   = literal->new('');
our $quote = literal->new('quote');
our $fn    = literal->new('fn*');
our $if    = literal->new('if');

sub bool  { $_[0] ? $y : $nil }
sub quote { list->new($quote, $_[0]) }

our %brackets = (')' => list, ']' => array, '}' => hash);

# defines global natives that may or may not force their arguments
sub defglobal {
  my %bindings = @_;
  $globals{$_} = native->new($_, $bindings{$_}) for keys %bindings;
}

defglobal '==', sub {
  return undef unless $_[1]->concrete and $_[2]->concrete;
  bool($_[1]->str eq $_[2]->str);
};

defglobal apply => sub {
  my ($bindings, $f, @args) = @_;
  my $last = pop @args;
  return undef unless ref($last) eq array;
  $f->invoke($bindings, array->new(@args, @$last))
    // list->new($f, @args, @$last);
};

defglobal array => sub { array->new(@_[1..$#_]) };

defglobal assoc => sub {
  my ($bindings, $h, $k, $v) = @_;
  if (ref($h) eq hash) {
    return undef unless $k->concrete;
    my $result = hash->new(%$h);
    $$result{$k->str} = $v;
    $result;
  } elsif (ref($h) eq array) {
    return undef unless ref($k) eq literal;
    my $result = array->new(@$h);
    $$result[$k->name] = $v;
    $result;
  } else {
    return undef;
  }
};

defglobal bindings => sub {
  my ($bindings, $parent, @xs) = @_;
  my %h;
  for (my $i = 0; $i < @xs; $i += 2) {
    $h{$xs[$i]->name} = $xs[$i + 1];
  }
  bindings->new($parent, \%h);
};

defglobal concrete => sub { bool $_[1]->concrete };
defglobal contains => sub { bool $_[1]->contains($_[2]) };
defglobal count    => sub {
  my ($bindings, $x) = @_;
  ref($x) eq array   ? literal->new(scalar @{$_[1]})
: ref($x) eq literal ? literal->new(length $x->name)
                     : undef;
};

defglobal def => sub {
  my ($bindings, $var, $x) = @_;
  return undef unless ref($var) eq literal;
  $globals{$var->name} = $x;
  $var;
};

defglobal defs => sub { $_[0] };

defglobal delay => sub {
  my ($bindings, $exprs, @body) = @_;
  return undef unless ref($exprs) eq array;
  delay->new($exprs, @body);
};

defglobal do => sub {
  my ($bindings, @body) = @_;
  my $result;
  $result = $_->eval($bindings) for @body;
  $result;
};

defglobal empty => sub {
  return undef unless $_[1]->concrete;
  ref($_[1])->new;
};

defglobal 'fn*' => sub {
  my ($bindings, $formal, $body) = @_;
  $formal = $formal->eval($bindings);
  return undef unless ref($formal) eq literal;
  fn->new($formal->name, $body->eval($bindings));
};

defglobal get => sub {
  return undef unless $_[1]->concrete and $_[2]->concrete;
  $_[1]->get($_[2]);
};

defglobal globals => sub { $global_bindings };
defglobal hash    => sub { hash->new(@_[1..$#_]) };
defglobal hashcode => sub {
  my ($bindings, $x) = @_;
  my $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
            . 'abcdefghijklmnopqrstuvwxyz'
            . '0123456789'
            . '+-*&^%@!~`|=_<>,.:;';
  my $n = length $chars;

  my $h = $x->hashcode;
  my $s = '';
  $s .= substr($chars, $h % $n, 1), $h /= $n while $h = int $h;
  literal->new($s);
};

defglobal if => sub {
  my ($bindings, $cond, $then, $else) = @_;
  $cond = $cond->eval($bindings);
  return undef unless $cond->concrete;
  ($cond->true ? $then : $else)->eval($bindings);
};

defglobal into => sub {
  my ($bindings, $to, $from) = @_;
  return undef unless ref($to)   eq array
                  and ref($from) eq array;
  ref($to)->new(@$to, @$from);
};

defglobal iota => sub {
  my ($bindings, $i) = @_;
  return undef unless ref($i) eq literal;
  array->new(map literal->new($_), 0..$i->name-1);
};

defglobal keys => sub {
  ref($_[1]) eq hash  ? array->new(map parse($_), sort keys %{$_[1]})
: ref($_[1]) eq array ? array->new(map literal->new($_), 0..$#{$_[1]})
                      : undef;
};

defglobal len     => sub { literal->new(length $_[1]->name) };
defglobal list    => sub { list->new(@_[1..$#_]) };
defglobal literal => sub { literal->new($_[1]->name) };

defglobal 'list->array' => sub {
  my ($bindings, $l) = @_;
  array->new(@$l);
};

defglobal module => sub {
  return undef unless ref($_[1]) eq literal;
  literal->new($xh::modules{$_[1]->name});
};

defglobal modules => sub {
  array->new(map literal->new($_), @xh::module_ordering);
};

defglobal parse => sub {
  return undef unless ref($_[1]) eq literal;
  array->new(parse $_[1]->name);
};

defglobal quote => sub { $_[1] };

defglobal realtype => sub {
  return undef unless $_[1]->concrete;
  literal->new(ref($_[1]) =~ s/^.*:://r);
};

defglobal reduce => sub {
  my ($bindings, $f, $init, $xs) = @_;
  return undef unless ref($xs) eq array;
  for my $x (@$xs) {
    my $args = array->new($init, $x);
    $init = $f->invoke($bindings, $args) // quote_call($f, $args);
  }
  $init;
};

defglobal scope => sub {
  my ($bindings, $b, $v) = @_;
  return undef unless ref($b) eq hash;
  $v->eval(bindings->new($bindings, $b));
};

defglobal slice => sub {
  my ($bindings, $xs, $lower, $upper) = @_;
  $lower //= literal->new(0);
  $upper //= literal->new(ref($xs) eq array   ? scalar @$xs
                        : ref($xs) eq literal ? length($xs) - 1
                                              : return undef);
  return undef unless ref($lower) eq literal
                  and ref($upper) eq literal;
  ref($xs) eq array   ? array->new($upper->name - 1 >= $lower->name
                                   ? @$xs[$lower->name .. $upper->name - 1]
                                   : ())
: ref($xs) eq literal ? literal->new(substr $xs->name, $lower,
                                            $upper - $lower)
                      : undef;
};

defglobal str => sub {
  ref($_) eq literal or return undef for @_[1..$#_];
  literal->new(join '', map $_->name, @_[1..$#_]);
};

defglobal type => sub { literal->new(ref($_[1]) =~ s/^.*:://r) };

defglobal undef => sub {
  my ($bindings, $x) = @_;
  return undef unless ref($x) eq literal;
  delete $globals{$x->name};
  $x;
};

defglobal unquote => sub {
  my ($bindings, $x, $b) = @_;
  $x->eval($bindings)->eval($b // $bindings);
};

defglobal vals => sub { array->new(map ${$_[1]}{$_}, sort keys %{$_[1]}) };
defglobal var  => sub {
  return undef unless ref($_[1]) eq literal;
  var->new($_[1]->name);
};

# Primitive arithmetic
BEGIN {
  my @float_binops = qw( + - * / % ** < > <= >= == != );
  my @float_unops  = qw( - );
  my @int_binops   = (@float_binops, qw( << >> >>> & | ^ ));
  my @int_unops    = (@float_unops,  qw( ~ ! ));

  eval qq{
    defglobal 'f$_', sub {
      my (\$bindings, \$x, \$y) = \@_;
      return undef unless ref(\$x) eq literal
                      and ref(\$y) eq literal;
      literal->new(\$x->name $_ \$y->name);
    };
  } for @float_binops;

  eval qq{
    defglobal 'fu$_', sub {
      my (\$bindings, \$x) = \@_;
      return undef unless ref(\$x) eq literal;
      literal->new($_ \$x);
    };
  } for @float_unops;

  eval qq{
    defglobal 'i$_', sub {
      my (\$bindings, \$x, \$y) = \@_;
      return undef unless ref(\$x) eq literal
                      and ref(\$y) eq literal;
      literal->new(int(int(\$x->name) $_ int(\$y->name)));
    };
  } for @int_binops;

  eval qq{
    defglobal 'iu$_', sub {
      my (\$bindings, \$x) = \@_;
      return undef unless ref(\$x) eq literal;
      literal->new(int($_ int(\$x->name)));
    };
  } for @int_unops;
}

our %escapes = (n => "\n", r => "\r", t => "\t");
sub parse {
  my @stack = [];
  local $_;
  while ($_[0] =~ / \G (?: (?<comment> \#.*)
                         | (?<ws>      [\s,]+)
                         | '(?<qstr>   (?:[^\\']|\\.)*)'
                         | (?<str>     [^\$()\[\]{}\s,]+)
                         | (?<var>     \$[^\$\s()\[\]{},]+)
                         | (?<opener>  [(\[{])
                         | (?<closer>  [)\]}])) /gx) {
    next if $+{comment} || $+{ws};
    my $s = $+{str};
    if (defined $s)      {push @{$stack[-1]}, literal->new($s)}
    elsif ($s = $+{var}) {push @{$stack[-1]}, var->new(substr $s, 1)}
    elsif ($+{opener})   {push @stack, []}
    elsif ($s = $+{closer}) {
      my $last = pop @stack;
      die "too many closers" unless @stack;
      push @{$stack[-1]}, $brackets{$s}->new(@$last);
    } elsif (defined($s = $+{qstr})) {
      push @{$stack[-1]},
           literal->new($s =~ s|\\(.)|$escapes{$1} // $1|egr);
    } else {
      die "unrecognized token: $_";
    }
  }
  die "unbalanced brackets: " . scalar(@stack) . " != 1"
    unless @stack == 1;
  @{$stack[0]};
}

sub evaluate {
  my ($expr, $bindings, $timeout) = @_;
  local $_;
  $deadline = $timeout ? time + $timeout : 0;
  $expr->eval($bindings // $global_bindings);
}

$::xh::compilers{xh} = sub {
  for my $x (parse $_[1]) {
    print STDERR '> ', $x->str, "\n";
    my $e = evaluate($x, $global_bindings, 30);
    print STDERR '= ', $e->str, "\n";
  }
};
_ \end{perlcode}

\chapter{html introspection}\label{chp:base-html-introspection}
  xh images can be opened as self-inspecting HTML files. This strategy of
  embedding xh module definitions in comments isn't very elegant, but it makes
  the Javascript parser easier to write. (A better system would be to have the
  Javascript parse everything in a single \verb|<script>| tag, then build all
  of the HTML that way; but due to browser security restrictions, this would
  break local viewing.)

\lstset{caption={src/introspect/dependencies.html},name={src/introspect/dependencies.html}}\begin{javascriptcode}
BEGIN {xh::defmodule('js-dependencies.html', <<'_')}
<script>
-- include deps/jquery.min.js
-- include deps/caterwaul.min.js
-- include deps/caterwaul.std.min.js
-- include deps/caterwaul.ui.min.js
</script>
_ \end{javascriptcode}

\lstset{caption={src/introspect/css.html},name={src/introspect/css.html}}\begin{javascriptcode}
BEGIN {xh::defmodule('css.html', <<'_')}
<style>
/*BEGIN {xh::defmodule('introspection.css', <<'_')}*/
@import url(http://fonts.googleapis.com/css?family=Abel|Fira+Mono);
body {background:   #080808;
      color:        #eae8e4;
      margin:       auto;
      max-width:    600px;
      overflow-y:   scroll;
      padding-left: 14px;
      border-left:  solid 1px #383736}

h1 {font-family: 'Abel', monospace;
    font-weight: normal;
    font-size:   16px;
    color:       #878177;
    margin:      0}

h1:hover, h1.active {color: #eae8e4}
h1 .suffix {color: #878177}
h1 .suffix:before {content: '.'; color: #878177}

pre {font-family: 'Fira Mono', monospace;
     font-size:  10px}

.module {border-top: solid 1px #383736;
         overflow:   hidden}
.module pre {margin: 0}

#dom   {margin: 20px 0}
#dom, #dom a {font-family:     'Abel', sans-serif;
              font-size:       16px;
              text-decoration: none;
              color:           #878177}
#dom a:hover {color: #eae8e4}
.title {color: #f89421}
/*_*/
</style>
_ \end{javascriptcode}

\lstset{caption={src/introspect/dom.html},name={src/introspect/dom.html}}\begin{javascriptcode}
BEGIN {xh::defmodule('dom.html', <<'_')}
<div id='dom'>
<a href='https://github.com/spencertipping/xh' target='_blank'>
  <span class='title'>xh</span></a>
<div>$ curl http://xh.spencertipping.com | perl</div>
</div>
_ \end{javascriptcode}

\lstset{caption={src/introspect/js.html},name={src/introspect/js.html}}\begin{javascriptcode}
BEGIN {xh::defmodule('introspection.html', <<'_')}
<script>
/*BEGIN {xh::defmodule('introspection.js', <<'_')}*/
// TESTCODE (should contain a functioning repl)
$(caterwaul(':all')(function () {
  $.fn.toggle_vertically(v) = $(this).each(toggle)
  -where [toggle(t = $(this).stop()) =
            cs /~animate/ {top:    v ? 0 : -0.3 * h}
     -then- t  /~animate/ {height: v ? h : 0}
/{opacity: +v} /~animate/ {queue: false, duration: 300}
     -where [cs = t.children().stop() /~css/ {position: 'relative'},
             h  = cs.first().height()]],

  $('body').empty() /~before/ jquery[head /append(css)]
                    /~append/ dom
                    /~append/ ui_for(parsed_modules)
                    /~css/    {display: 'block'},
  where [
  css               = $('style'),
  dom               = $('#dom'),
  self              = +$('script, style') *[$(x).html()] /seq /~join/ '\n',
  parse_modules(ls) = xs -se [ls *!process_line -seq] -where [
    xs              = {__ordering: []},
    name            = null,
    text            = '',
    process_line(s) = /^(?:\/\*)?BEGIN.*defmodule\('([^']+)'/.exec(s)
            -re [it ? name /eq[it[1]] -then- text /eq['']
                    : /^(?:\/\*)?_+(?:\*\/)?$/.test(s)
                      ? name -ocq- 'bootstrap.pl'
                        -then- xs[name] /eq [text /~substr/ 1]
                        -then- xs.__ordering /~push/ name
                    : text += '\n#{s}']],

  parsed_modules    = self.split(/\n/) /!parse_modules,
  ui_for(modules)   = ui -se [sections *![ui /~append/ x] -seq] -where [
    ui              = jquery in div.modules,
    toggle()        = $(this).toggleClass('active').next().stop()
                      /~toggle_vertically/ $(this).hasClass('active'),
    module_name(x)  = jquery [span.prefix /text(pieces[0])
                            + span.suffix /text(pieces[1])]
                      -where [pieces = x.split(/\./, 2)],
    sections        = seq in
                      modules.__ordering
                      *[jquery in h1 /append(x /!module_name)
                                     /css({cursor: 'pointer'})
                                     /click(toggle)
                                + div.module(pre /text(modules[x]))
                                  /toggle_vertically(false)]]]}));
/*_*/
</script>
_
 \end{javascriptcode}

\part{self-hosting implementation}\label{part:self-hosting-implementation}
\chapter{xh-core interpreter}\label{chp:xh-core-self-hosting}
  We defined an xh-core script interpreter in Perl in chapter
  \ref{chp:xh-core-script}, but we need one written in xh-core so we can
  compile it to other backends. This forms the foundation for xh-script, which
  is written in xh-core.

  Some backends will provide convenient stuff like hashtables and garbage
  collection, but for those that don't (like C), we'll need to implement them
  from scratch. All we can assume in that case is support for arrays of known
  length. We figure this stuff out inside the xh-core script by looking for
  definitions of native functions and defining our own alternatives otherwise.

  Another discrepancy between backends is the amount of runtime type
  information that's supported. By default all values are tagged unions that
  store their types, but GCs and such will need access to machine words.

\lstset{caption={src/corescript/boot.xh},name={src/corescript/boot.xh}}\begin{xhcode}
(def destructuring-bind1
  (fn* outer        # outer = [template value bindings]
    (if (== literal (realtype (get $outer 0)))
      (assoc (get $outer 2) (get $outer 0) (get $outer 1))
      (if (if (== array (realtype (get $outer 0)))
            y
            (== hash (realtype (get $outer 0))))
        (reduce (fn* k
                  (delay [$k] destructuring-bind1
                              (get (get $outer 0) (get $k 1))
                              (get (get $outer 1) (get $k 1))
                              (get $k 0)))
                (get $outer 2)
                (keys (get $outer 0)))
        (get $outer 2)))))

(def fn1
  (fn* args
    (fn* (get $args 0)
      (scope (destructuring-bind1 (get $args 1)
                                  (var (get $args 0))
                                  {})
        (get $args 2)))))

(def fn
  (fn1 fn~ [formals body]
    ((fn1 gs~ [gs]
       (fn* $gs
         (scope (delay [$gs]
                 delay [$gs]
                 destructuring-bind1 $formals (var $gs) {})
           $body)))
     (str : (delay [$formals $body]
             delay [$formals $body]
             hashcode [$formals $body])))))

(def defn
  (fn [name formals body]
    (def $name (fn $formals $body))))

(defn and2 [x y] (if $x $y ''))
(defn or2  [x y] (if $x $x $y))
(defn not  [x]   (if $x '' y))
(defn xor2 [x y] (and2 (or2 $x $y) (not (and2 $x $y))))

(defn map1     [f xs] (flatmap1 (fn [x] [($f $x)]) $xs))
(defn filter1  [f xs] (flatmap1 (fn [x] (if (f $x) [$x] [])) $xs))
(defn flatmap1 [f xs] (reduce (fn [ys x] (into $ys ($f $x)))
                              (empty $xs)
                              $xs))

(defn reverse [xs] (reduce (fn [ys x] (into [$x] $ys))
                           []
                           $xs))

(defn partial fs (let1 [f] $fs (fn xs (apply $f (into (slice $fs 1) $xs)))))
(defn comp    fs (fn xs (get (reduce (fn [x f] [(apply $f $x)])
                                     $xs
                                     (reverse $fs))
                             0)))

(defn inc [x] (i+ $x 1))
(defn dec [x] (i- $x 1))
(defn let1 [k v body] ((delay [$k] fn [$k] $body) $v))

(defn .. args
  (let1 [x] $args
    (delay [$x]
     delay [$x]
     apply list delay [$x] (slice $args 1))))

(defn ->> forms
  (reduce (fn [x l] (.. $l let1 _ $x $l))
          (get $forms 0)
          (slice $forms 1)))

(defn let [kvs body]
  (->> (count $kvs)
       (iota (i>> $_ 1))
       (map1 (partial i* 2) $_)
       (map1 (fn [i] [(get $kvs $i) (get $kvs (inc $i))]) $_)
       (reduce (fn [code [k v]] (.. $k let1 $k $v $code))
               $body
               $_)))

(defn cond clauses
  (->> (count $clauses)
       (iota (i>> $_ 1))
       (map1 (partial i* 2) $_)
       (reduce (fn [code i]
                 (let [[c v] (map1 (partial get $clauses) [$i (inc $i)])]
                   (if $c $v $code)))
               ''
               (reverse $_)))) \end{xhcode}

\chapter{data structures}\label{chp:data-structures}
\lstset{caption={src/cs/datameta.xh},name={src/cs/datameta.xh}}\begin{xhcode}
(defn defstruct args
  (let [[name structure] $args]
    (def $name
      (apply tagged-struct $name $structure (slice $args 2))))) \end{xhcode}

\lstset{caption={src/cs/data.xh},name={src/cs/data.xh}}\begin{xhcode}
(defstruct linear-array-container
  {length 0}
  (get [this i]
    [(== literal (realtype $i))]
    (mget (i+ $this (i* $word-size (i+ $i 1)))))) \end{xhcode}

\chapter{algorithms}\label{chp:algorithms}
\lstset{caption={src/cs/algorithms.xh},name={src/cs/algorithms.xh}}\begin{xhcode}
# TODO \end{xhcode}

\chapter{garbage collection}\label{chp:garbage-collection}
\lstset{caption={src/cs/gc.xh},name={src/cs/gc.xh}}\begin{xhcode}
# TODO \end{xhcode}

\end{document}
