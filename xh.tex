\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}
\lstnewenvironment{pythoncode}    {\lstset{language=python}}{}

\lstnewenvironment{resourcecode}{}{}

\newcommand{\bs}{\textbackslash}
\setcounter{tocdepth}{0}
\lstnewenvironment{xhcode}{}{}

\title{xh}
\author{Spencer Tipping}

\begin{document}
\maketitle{}
\tableofcontents{}


\part{Language reference}\label{part:language-reference}
\chapter{Similarities to TCL}\label{chp:similarities-to-tcl}
  Every xh value is a string. This includes lists, functions, closures, lazy
  expressions, scope chains, call stacks, and heaps. Asserting string
  equivalence makes it possible to serialize any value losslessly, including a
  running xh process.\footnote{Note that things like active socket connections
  and external processes will be proxied, however; xh can't migrate
  system-native things.}

  Although the string equivalence is available, most operations have
  higher-level structure. For example, the \verb|$| operator, which performs
  string interpolation, interpolates values in such a way that two things are
  true:

\begin{enumerate}
\item{No interpolated value will be further interpolated (idempotence).}
\item{The interpolated value will be read as a single list element.}
\end{enumerate}

  For example:

\begin{verbatim}
(def bar bif)
(def foo "hi there \$bar!")
(def baz $foo)                      # no quoting necessary here by (2)
(identity $baz)
"hi there \$bar!"
(echo $baz)
hi there $bar!                      # $bar unevaluated by (1)
(identity $foo)
"hi there \$bar!"                   # $foo == $baz, of course
(echo $foo)
hi there $bar!
()
\end{verbatim}

  This interpolation structure can be overridden by using one of three
  alternative forms of \verb|$|:

\begin{verbatim}
(def bar bif)
(def foo "hi there \$bar!")
(echo $!foo)                        # allow re-interpolation
hi there bif!
(count [$foo])                      # single element
1
(count [$@foo])                     # multiple elements
3
(nth [$@!foo] 2)                    # multiple and re-interpolation
bif!
()
\end{verbatim}

  All string values in xh programs are lifted into reader-safe quotations. This
  causes any ``active'' characters such as \verb|$| to be prefixed with
  backslashes, a transformation you can mostly undo by using \verb|$@!|. The
  only thing you can't undo is bracket balancing, which if undone would wreak
  havoc on your programs. You can see the effect of balancing by doing
  something like this:

\begin{verbatim}
(def foo "[[ [[")
(def bar [$@!foo])
(echo $bar)
["[[ [["]
()
\end{verbatim}

\section{Type hints}\label{sec:type-hints}
    The string form of a value conveys its type. xh syntax supports the
    following structures:

\begin{verbatim}
[x y z ...]                       # array/vector
{x y z ...}                       # map
(x y z ...)                       # interpolated (active!) list
$x                                # interpolated (active!) variable
bareword                          # string with interpolation
-42.0                             # string with interpolation
"..."                             # string with interpolation
'...'                             # string with no interpolation
\x                                # single-character string, no interp
\end{verbatim}

    When you ask xh about the type of a value, xh looks at the first byte and
    figures it out.\footnote{Note that xh is in no way required to represent
    these values as strings internally. It just lies so convincingly that you
    would never know the difference.} Because of this, not all strings are
    convertible to values despite all values being convertible to strings. You
    can easily convert between types by interpolating:

\begin{verbatim}
(def list-form [1 2 3 4])
(def string-form "$@list-form")
(identity $list-form)
[1 2 3 4]
(identity $string-form)
"1 2 3 4"
(def map-form {$@list-form})
(identity $map-form)
{1 2 3 4}
()
\end{verbatim}

    Therefore the meaning of \verb|$@x| could be interpreted as, ``the untyped
    version of {\tt x},'' and \verb|$!@x| could be, ``eval the untyped version
    of {\tt x}.''

\section{Laziness and localization}\label{sec:laziness-and-localization}
    xh is a distributed runtime with serializable lazy values, which is a
    potential problem if you want to avoid proxying all over the place.
    Fortunately, a more elegant solution exists in most cases. Rather than
    using POSIX calls directly, xh programs access system resources like files
    through a slight indirection:

\begin{verbatim}
(def some-bytes (subs /etc/passwd 0 4096))
(echo $some-bytes)                # $some-bytes is lazy
\end{verbatim}

    This is clearly trivial if the {\tt def} and {\tt echo} execute on the same
    machine. But the {\tt echo} can also be moved trivially by adding a
    hostname component to the file:

\begin{verbatim}
(def some-bytes (subs /etc/passwd 0 4096))
(identity $some-bytes)
(subs @host1/etc/passwd 0 4096)
\end{verbatim}

    This {\tt @host1} namespace allows any remote xh runtime to negotiate with
    the original host, making lazy values fully mobile (albeit possibly
    slower).

\chapter{Similarities to Lisp}\label{chp:similarities-to-lisp}
  xh is strongly based on the Lisp family of languages, most visibly in its
  homoiconicity. Any string wrapped in \verb|[]|, \verb|{}|, or \verb|()| is
  interpreted as a list of words, just as it is in Clojure. Also as in Lisp in
  general, \verb|()| interpolates its result into the surrounding context:

\begin{verbatim}
(def foo 'hi there')
(echo $foo)
hi there
(echo (echo $foo))                  # similar to bash's $()
hi there
()
\end{verbatim}

  Any \verb|()| list can be prefixed with \verb|@| and/or \verb|!| with effects
  analogous to \verb|$|; e.g.~\verb|echo !@(echo hi there)|.

\chapter{Dissimilarities from everything else I know of}\label{chp:dissimilarities}
  xh evaluates expressions outside-in:

\begin{enumerate}
\item{Variable shadowing is not generally possible.}
       \label{item:no-variable-shadowing}
\item{Expansion is idempotent for any set of bindings.}
       \label{item:idempotent-expansion}
\item{Unbound variables expand to active versions of themselves (a}
       corollary of \ref{item:idempotent-expansion}).
       \label{item:unbound-expansion}
\item{Laziness is implemented by referring to unbound quantities.}
       \label{item:laziness-unbound}
\item{Bindings can be arbitrary list expressions, not just names (a}
       partial corollary of \ref{item:laziness-unbound}).
       \label{item:arbitrary-bindings}
\item{No errors are ever thrown; all expressions that cannot be evaluated}
       become \verb|(error)| clauses that most functions consider to be
       opaque.
       \label{item:no-errors}
\item{xh has no support for syntax macros.}
       \label{item:no-macros}
\end{enumerate}

  Unbound names are treated as though they might at some point exist. For
  example:

\begin{verbatim}
(echo $x)
$x
(def x $y)
(echo $x)
$y
(def y 10)
(echo $x)
10
()
\end{verbatim}

  You can also bind expressions of things to express partial knowledge:

\begin{verbatim}
(echo (count $str))
(count $str)
(def (count $str) 10)
(echo $str)
$str
(echo (count $str))
10
()
\end{verbatim}

  This is the mechanism by which xh implements lazy evaluation, and it's also
  the reason you can serialize partially-computed lazy values.

\chapter{Functions}\label{chp:functions}
  xh supports two equivalent ways to write function-like relations:

\begin{verbatim}
(def (foo $x) {echo hi there, $x!})
(foo spencer)
hi there, spencer!
()
\end{verbatim}

  This is named definition by destructuring, which works great for most cases.
  When you're writing an anonymous function, however, you'll need to describe
  the mappings individually:

\begin{verbatim}
(reduce {[$total +$x] (+ $total $x)
         [$total *$x] (* $total $x)} \
        0 \
        [+1 +2 *5 +1])
16
()
\end{verbatim}

\part{Bootstrap implementation}\label{part:bootstrap-implementation}
\chapter{Self-replication}\label{chp:self-replication}
\lstset{caption={boot/xh-header},name={boot/xh-header}}\begin{perlcode}
#!/usr/bin/env perl
BEGIN {
print STDERR q{
NOTE: Development image

If you see this note after installing the shell, it's probably because
you're running a version that has not yet rebuilt itself (maybe you got the
wrong file from the Git repo?). You can do this, but it will be really
slow and may use a lot of memory. There are two ways to fix this:

1. Download the standard image from http://spencertipping.com/xh
2. Have this image recompile itself by running xh.recompile-in-place (this
   will take some time because it stress-tests your Perl runtime)

Note also that bootstrapping requires Perl 5.14 or later, whereas running a
compiled image just requires Perl 5.10.

};
}

BEGIN {eval(our $xh_bootstrap = q{
# xh: the X shell | https://github.com/spencertipping/xh
# Copyright (C) 2014, Spencer Tipping
# Licensed under the terms of the MIT source code license

# For the benefit of HTML viewers (long story):
# <body style='display:none'>
# <script src='http://spencertipping.com/xh/page.js'></script>
use 5.014;
package xh;
our %modules;
our @module_ordering;

our %compilers = (pl => sub {
  my $package = $_[0] =~ s/\./::/gr;
  eval "{package ::$package;\n$_[1]\n}";
  die "error compiling module $_[0]: $@" if $@;
});

sub defmodule {
  my ($name, $code, @args) = @_;
  chomp($modules{$name} = $code);
  push @module_ordering, $name;
  my ($base, $extension) = split /\.(\w+$)/, $name;
  die "undefined module extension '$extension' for $name"
    unless exists $compilers{$extension};
  $compilers{$extension}->($base, $code, @args);
}

chomp($modules{bootstrap} = $::xh_bootstrap);
undef $::xh_bootstrap; \end{perlcode}

  At this point we need a way to reproduce the image. Since the bootstrap code
  is already stored, we can just wrap it and each defined module into an
  appropriate \verb|BEGIN| block.

\lstset{caption={boot/xh-header (continued)},name={boot/xh-header}}\begin{perlcode}
sub image {
  my @pieces = "#!/usr/bin/env perl";
  push @pieces, "BEGIN {eval(our \$xh_bootstrap = <<'_')}",
                $modules{bootstrap},
                '_';
  push @pieces, "BEGIN {xh::defmodule('$_', <<'_')}",
                $modules{$_},
                '_' for @module_ordering;
  push @pieces, "xh::main::main;\n__DATA__";
  join "\n", @pieces;
}
})} \end{perlcode}

\chapter{Perl-hosted evaluator}\label{chp:perl-hosted-evaluator}
  xh is self-hosting, but to get there we need to implement an interpreter in
  Perl. This interpreter is mostly semantically correct but slow and shouldn't
  be used for anything besides bootstrapping the real compiler.

\lstset{caption={modules/interpreter.pl},name={modules/interpreter.pl}}\begin{perlcode}
BEGIN {xh::defmodule('xh::interpreter.pl', <<'_')}
use Memoize qw/memoize/;
use List::Util qw/max/;

sub active_regions {
  # Returns a series of numbers that describes, in pre-order, regions of
  # the given string that should be interpolated. The numeric list has the
  # following format:
  #
  # (offset << 32 | len), (offset << 32 | len) ...

  my @pieces = split /(\\.|\$@?!?\w+|\$@?!?\{[^}]+\}|@?!?\(|[')])/s, $_[0];
  my $offset = 0;
  my @result;
  my @quote_offsets;

  for (@pieces) {
    if (@quote_offsets && substr($_[0], $quote_offsets[-1], 1) eq "'") {
      # We're inside a hard-quote, so ignore everything except for the next
      # hard-quote.
      pop @quote_offsets if /^'/;
    } else {
      if (/^'/ || /^@?!?\(/) {
        push @quote_offsets, $offset;
      } elsif (/^\$/) {
        push @result, $offset << 32 | length;
      } elsif (/^\)/) {
        my $start = pop @quote_offsets;
        push @result, $start << 32 | $offset + 1 - $start;
      }
    }
    $offset += length;
  }

  sort {$a <=> $b} @result;
}

memoize 'active_regions';

our %closers = ('(' => ')', '[' => ']', '{' => '}');
sub element_regions {
  # Returns integer-encoded regions describing the positions of list
  # elements. The list passed into this function should be unwrapped; that
  # is, it should have no braces.
  my ($xs)   = @_;
  my $offset = 0;
  my @pieces = split / ( "(?:\\.|[^"])*"
                       | '(?:\\.|[^'])*'
                       | \\.
                       | [({\[\]})]
                       | \s+ ) /xs, $_[0];
  my @paren_offsets;
  my @parens;
  my @result;
  my $item_start = -1;

  for (@pieces) {
    unless (@paren_offsets) {
      if (/\s+/ || /^[)\]}]/) {
        # End any item if we have one.
        push @result, $item_start << 32 | $offset - $item_start
        if $item_start >= 0;
        $item_start = -1;
      } else {
        # Start an item unless we've already done so.
        $item_start = $offset if $item_start < 0;
      }
    }

    # Update bracket tracking.
    if ($_ eq $closers{$parens[-1]}) {
      if (@parens) {
        pop @paren_offsets;
        pop @parens;
      } else {
        die 'illegal closing brace: ... '
          . substr($xs, max(0, $offset - 10), 20)
          . ' ...'
          . "\n(whole string is $xs)";
      }
    } elsif (/^[(\[{]/) {
      push @paren_offsets, $offset;
      push @parens, $_;
    }

    $offset += length;
  }

  push @result, $item_start << 32 | $offset if $item_start >= 0;
  @result;
}

memoize 'element_regions';

sub xh_list_box {
  $_[0] !~ /^[({\[]/ && element_regions(0, $_[0]) > 1
    ? "[$_[0]]"
    : $_[0];
}

sub xh_list_unbox {
  return $1 if $_[0] =~ /^\[(.*)\]$/
            || $_[0] =~ /^\((.*)\)$/
            || $_[0] =~ /^\{(.*)\}$/;
  $_[0];
}

sub parse_list {
  my $unboxed = xh_list_unbox $_[0];
  map xh_list_box(substr $unboxed, $_ >> 32, $_ & 0xffffffff),
      element_regions 0, $unboxed;
}

sub into_list  {'(' . join(' ', map xh_list_box($_), @_) . ')'}
sub into_vec   {'[' . join(' ', map xh_list_box($_), @_) . ']'}
sub into_block {'{' . join(' ', map xh_list_box($_), @_) . '}'}

sub xh_vecp   {$_[0] =~ /^\[.*\]$/}
sub xh_listp  {$_[0] =~ /^\(.*\)$/}
sub xh_blockp {$_[0] =~ /^\{.*\}$/}
sub xh_varp   {$_[0] =~ /^\$/}

sub xh_count {
  scalar element_regions 0, xh_list_unbox $_[0];
}

sub xh_nth {(parse_list $_[0])[$_[1]]}

sub xh_nth_eq {
  # FIXME
  my ($copy, $i, $v) = @_;
  my @regions        = element_regions 0, $copy;
  my $r              = $regions[$i];
  substr($copy, $r >> 32, $r & 0xffffffff) = $v;
  $copy;
}

sub destructuring_bind;
sub destructuring_bind {
  # Both $pattern and $v should be quoted; that is, the string character [
  # should be encoded as \[.
  my ($pattern, $v) = @_;
  my @pattern_elements = element_regions 0, $pattern;
  my @v_elements       = element_regions 0, $v;
  my %bindings;

  # NOTE: no $@ matching
  return undef unless @v_elements == @pattern_elements;

  # NOTE: no foo$bar matching (partial constants)
  for (my $i = 0; $i < @pattern_elements; ++$i) {
    my $pi = xh_nth $pattern, $i;
    my $vi = xh_nth $v,       $i;

    return undef if $pi !~ /^\$/ && $pi ne $vi;

    my @pattern_regions = element_regions 0, $pi;
    my @v_regions       = element_regions 0, $vi;
    return undef unless @pattern_regions == 1 && $pi =~ /^\$/
                     || @pattern_regions == @v_regions;

    if (xh_vecp $pi) {
      my $sub_bind = destructuring_bind $pi, $vi;
      return undef unless ref $sub_bind;
      my %sub_bindings = %$sub_bind;
      for (keys %sub_bindings) {
        return undef if exists $bindings{$_}
                     && $bindings{$_} ne $sub_bindings{$_};
        $bindings{$_} = $sub_bindings{$_};
      }
    } elsif (xh_listp $pi) {
      die "TODO: implement list binding for $pi";
    } elsif ($pi =~ /^\$\{?(\w+)\}?$/) {
      return undef if exists $bindings{$1} && $bindings{$1} ne $vi;
      $bindings{$1} = $vi;
    } elsif ($pi =~ /^\$/) {
      die "illegal binding form: $pi";
    } else {
      return undef unless $pi eq $vi;
    }
  }

  {%bindings};
}

sub invoke;
sub interpolate;
sub interpolate {
  # Takes a string and a compiled binding hash and interpolates all
  # applicable substrings outside-in. This process may involve full
  # evaluation if () subexpressions are present, and is in general
  # quadratic or worse in the length of the string.
  my $bindings              = $_[0];
  my @interpolation_regions = active_regions $_[1];
  my @result_pieces;

  for (@interpolation_regions) {
    my $slice = substr $_[0], $_ >> 32, $_ & 0xffffffff;

    # NOTE: no support for complex ${} expressions
    if ($slice =~ /^\$(@?!?)\{?(\w+)\}?$/) {
      # Expand a named variable that may or may not be defined yet.
      push @result_pieces,
           exists ${$bindings}{$2} ?
               $1 eq ''  ? xh_listquote(xh_deactivate $bindings->{$2})
             : $1 eq '@' ? xh_deactivate($bindings->{$2})
             : $1 eq '!' ? xh_listquote($bindings->{$2})
             :             $bindings->{$2}
           : "\$$slice";
    } elsif ($slice =~ /^\((.*)\)$/s) {
      push @result_pieces, invoke $bindings, parse_list interpolate $1;
    } else {
      push @result_pieces, $slice;
    }
  }

  join '', @result_pieces;
}

sub xh_function_cases {
  # FIXME
  my @result;
  my @so_far;
  for (parse_vlist $_[0]) {
    my ($command, @args) = parse_list $_;
    if (xh_vecp $command) {
      push @result, into_block @so_far if @so_far;
      @so_far = ($command, into_list @args);
    }
  }
  push @result, into_block @so_far if @so_far;
  @result;
}

sub evaluate;
sub invoke {
  # NOTE: no support for (foo bar $x)-style conditional destructuring;
  # these are all rewritten into lambda forms
  my ($bindings, $f, @args) = @_;
  my $args = into_vec @args;

  # Resolve f into a lambda form if it's still in word form.
  $f = $bindings->{$f} if exists $bindings->{$f};

  # Escape into perl
  return $f->($bindings, @args) if ref $f eq 'CODE';

  my %nested_bindings = %$bindings;
  for (xh_function_cases $f) {
    my ($formals, @body) = parse_block $_;
    if (my $maybe_bindings = destructuring_bind $formals, $args) {
      $nested_bindings{$_} = $$maybe_bindings{$_}
      for keys %$maybe_bindings;
      return evaluate {%nested_bindings}, into_block @body;
    }
  }

  return into_list $f, @args;
}

sub evaluate {
  my ($bindings, $block) = @_;
  my @statements         = parse_block $block;
  my $result;

  # NOTE: this function updates $bindings in place.
  for (@statements) {
    # Each statement is an invocation, which for now we assume all to be
    # functions.
    #
    # NOTE: this is semantically incomplete as we don't consider
    # macro-bindings.
    $result = invoke $bindings, parse_list interpolate $bindings, $_;
  }
  $result;
}
_
 \end{perlcode}

\end{document}
