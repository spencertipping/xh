\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}
\lstnewenvironment{pythoncode}    {\lstset{language=python}}{}

\lstnewenvironment{resourcecode}{}{}

\newcommand{\bs}{\textbackslash}
\setcounter{tocdepth}{0}
\lstnewenvironment{xhcode}{}{}

\title{xh}
\author{Spencer Tipping}

\begin{document}
\maketitle{}
\tableofcontents{}


\part{introduction}\label{part:introduction}
\chapter{design constraints}\label{chp:design-constraints}
  xh is designed to be a powerful and ergonomic interface to multiple systems,
  many of which are remote. As such, it's subject to programming language,
  shell, and distributed-systems constraints:

\begin{enumerate}
\item{}\label{i:real-programming}
  xh will be used for real programming.
    (Initial assumption)
\item{}\label{i:shell}
  xh will be used as a shell.
    (Initial assumption)
\item{}\label{i:distributed-computation}
  xh will be used to manage any machine on which you have a login, which
  could be hundreds or thousands.
    (Initial assumption)
\item{}\label{i:no-root-access}
  You will not always have root access to machines you want to use, and
  they may have different architectures.
    (Initial assumption)
\item{}\label{i:ergonomic-limit}
  xh should approach the limit of ergonomic efficiency as it learns more
  about you.
    (Initial assumption)
\item{}\label{i:security}
  xh should never compromise your security, provided you understand what
  it's doing.
    (Initial assumption)

\item{}\label{i:quick-webserver}
  It should be possible to write a ``hello world'' HTTP server on one line.
    (Initial assumption,
     \ref{i:real-programming},
     \ref{i:shell})
\item{}\label{i:live-preview}
  It should be possible to preview the evaluation of any well-formed
  expression without causing side-effects.
    (Initial assumption,
     \ref{i:shell},
     \ref{i:ergonomic-limit},
     \ref{i:trivial-debugging})
\item{}\label{i:not-slow}
  xh should never cause a dealbreaking performance problem.
    (Initial assumption,
     \ref{i:real-programming},
     \ref{i:ergonomic-limit})
\item{}\label{i:unreliable-connections}
  Connections between machines may die at any time, and remain down for
  arbitrarily long. xh must never become unresponsive when this happens,
  and any data coming from those machines should block until it is
  available again (i.e.~xh's behavior should be invariant with connection
  failures).
    (Initial assumption,
     \ref{i:real-programming},
     \ref{i:shell},
     \ref{i:distributed-computation})
\item{}\label{i:trivial-debugging}
  Debugging should require little or no effort; all error cases should be
  trivially obvious.
    (Initial assumption,
     \ref{i:real-programming},
     \ref{i:distributed-computation},
     \ref{i:ergonomic-limit})
\item{}\label{i:trivial-database}
  An xh instance should trivially function as a database; there should be
  no distinction between data in memory and data on disk.
    (Initial assumption,
     \ref{i:real-programming},
     \ref{i:ergonomic-limit},
     \ref{i:trivial-debugging},
     \ref{i:no-oome},
     \ref{i:not-slow})

\item{}\label{i:universal-prediction}
  xh should use every keystroke to build/refine a model it uses to predict
  future keystrokes and commands.
    (\ref{i:ergonomic-limit})
\item{}\label{i:forgetful-history}
  The likelihood that xh forgets anything from your command history should
  be inversely proportional to the amount of effort required to
  retype/recreate it.
    (\ref{i:ergonomic-limit},
     \ref{i:universal-prediction})
\item{}\label{i:locally-anonymous}
  xh must provide a way to accept input and execute commands without
  updating its prediction model.
    (\ref{i:security})
\item{}\label{i:http-client}
  xh should be able to submit an encrypted version of its current state to
  HTTP services like Github gists or pastebin.
    (\ref{i:ergonomic-limit},
     \ref{i:security},
     \ref{i:unreliable-connections},
     \ref{i:transparent-self-install},
     \ref{i:www-initialization})

\item{}\label{i:feel-like-shell}
  xh-script needs to feel like a regular shell for most purposes.
    (\ref{i:shell})
\item{}\label{i:imperative}
  xh-script should be fundamentally imperative.
    (\ref{i:real-programming},
     \ref{i:shell},
     \ref{i:feel-like-shell})
\item{}\label{i:no-oome}
  xh must never run out of memory or swap pages to disk, regardless of what
  you tell it to do.
    (\ref{i:real-programming},
     \ref{i:shell},
     \ref{i:not-slow},
     \ref{i:ergonomic-limit})
\item{}\label{i:nonblocking}
  xh must respond to every keystroke within 20ms; therefore, SSH must be
  used only for nonblocking RPC requests (i.e.~the shell always runs
  locally).
    (\ref{i:shell},
     \ref{i:not-slow},
     \ref{i:ergonomic-limit})
\item{}\label{i:remote-resources}
  All resources, local and remote, must be uniformly accessible;
  i.e.~autocomplete, filename substitution, etc, must all just work (up to
  random access, which is impossible without FUSE or similar).
    (\ref{i:shell},
     \ref{i:distributed-computation},
     \ref{i:ergonomic-limit})

\item{}\label{i:prefix-notation}
  xh-script uses prefix notation.
    (\ref{i:shell})
\item{}\label{i:quasiquoting}
  xh-script quasiquotes values by default.
    (\ref{i:shell})
\item{}\label{i:unquoting}
  xh-script defines an unquote operator.
    (\ref{i:shell},
     \ref{i:quasiquoting})

\item{}\label{i:real-data-structures}
  The xh runtime provides real, garbage-collected data structures.
    (\ref{i:real-programming})
\item{}\label{i:data-structures-can-be-quoted}
  Every xh data structure has a quoted form.
    (\ref{i:real-data-structures},
     \ref{i:shell},
     \ref{i:trivial-debugging},
     \ref{i:live-preview})
\item{}\label{i:data-structures-can-be-serialized}
  Every xh data structure can be losslessly serialized.
    (\ref{i:shell},
     \ref{i:distributed-computation},
     \ref{i:trivial-database},
     \ref{i:data-structures-can-be-quoted},
     \ref{i:settings-contain-variable-definitions},
     \ref{i:image-merging})
\item{}\label{i:data-structures-are-immutable}
  Data structures have no identity and therefore are immutable.
    (\ref{i:distributed-computation},
     \ref{i:data-structures-can-be-serialized})

\item{}\label{i:opaque-resources}
  xh-script must have access to machine-specific opaque resources like PIDs
  and file handles.
    (\ref{i:real-programming},
     \ref{i:shell})
\item{}\label{i:mutable-symbol-table}
  Each xh instance should implement a mutable symbol table with weak
  reference support, subject to semi-conservative distributed garbage
  collection.
    (\ref{i:data-structures-are-immutable},
     \ref{i:opaque-resources},
     \ref{i:no-oome},
     \ref{i:xh-heap})
\item{}\label{i:state-ownership}
  Every piece of mutable state, including symbol tables, must have at most
  one authoritative copy (mutable state within xh is managed by a CP
  system).
    (\ref{i:unreliable-connections},
     \ref{i:opaque-resources},
     \ref{i:mutable-symbol-table},
     \ref{i:thread-mobility})
\item{}\label{i:checkpointing}
  An xh instance should be able to save checkpoints of itself in case of
  failure. If you do this, xh becomes an AP system.
    (\ref{i:unreliable-connections},
     \ref{i:state-ownership})

\item{}\label{i:lazy-evaluation}
  xh's evaluator must support some kind of laziness.
    (\ref{i:real-programming},
     \ref{i:no-oome},
     \ref{i:remote-resources},
     \ref{i:not-slow})
\item{}\label{i:laziness-serializable}
  Lazy values must have well-defined quoted forms and be losslessly
  serializable.
    (\ref{i:data-structures-can-be-quoted},
     \ref{i:data-structures-can-be-serialized},
     \ref{i:lazy-evaluation},
     \ref{i:thread-mobility},
     \ref{i:xh-heap})
\item{}\label{i:lazy-introspection}
  All lazy values must be subject to introspection to identify why they
  haven't been realized.
    (\ref{i:trivial-debugging},
     \ref{i:not-slow},
     \ref{i:unreliable-connections},
     \ref{i:nonblocking},
     \ref{i:lazy-evaluation},
     \ref{i:priority-scheduler})
\item{}\label{i:abstract-evaluation}
  xh must be able to partially evaluate expressions that contain unknown
  quantities.
    (\ref{i:live-preview},
     \ref{i:lazy-evaluation},
     \ref{i:lazy-introspection},
     \ref{i:laziness-serializable})
\item{}\label{i:code-as-data}
  xh-script code should be a reasonable data storage format.
    (\ref{i:shell},
     \ref{i:abstract-evaluation})
\item{}\label{i:parse-self}
  xh-script must contain a library to parse itself.
    (\ref{i:code-as-data})
\item{}\label{i:homoiconic}
  xh-script must be homoiconic.
    (\ref{i:code-as-data},
     \ref{i:parse-self},
     \ref{i:self-hosting-runtime},
     \ref{i:representational-abstraction})

\item{}\label{i:compile-to-c}
  xh should be able to compile any function to C, compile it if the host
  has a C compiler, and transparently migrate execution into this process.
    (\ref{i:real-programming},
     \ref{i:thread-mobility},
     \ref{i:not-slow})
\item{}\label{i:compile-to-perl}
  xh should be able to compile any function to Perl rather than
  interpreting its execution.
    (\ref{i:real-programming},
     \ref{i:no-root-access},
     \ref{i:not-slow})
\item{}\label{i:compile-to-js}
  xh should be able to compile any function to Javascript so that browser
  sessions can transparently become computing nodes.
    (\ref{i:real-programming},
     \ref{i:distributed-computation},
     \ref{i:not-slow})
\item{}\label{i:self-hosting-runtime}
  xh should follow a bootstrapped self-hosting runtime model.
    (\ref{i:compile-to-c},
     \ref{i:compile-to-perl},
     \ref{i:compile-to-js}
     \ref{i:representational-abstraction})
\item{}\label{i:tracing-jit}
  xh-script should be executed by a profiling/tracing dynamic compiler that
  automatically compiles certain pieces of code to alternative forms like
  Perl or C.
    (\ref{i:not-slow})
\item{}\label{i:representational-abstraction}
  The xh compiler should optimize data structure representations for the
  backend being targeted.
    (\ref{i:not-slow},
     \ref{i:thread-mobility},
     \ref{i:tracing-jit})

\item{}\label{i:xh-heap}
  xh needs to implement its own heap and memory manager, and swap values to
  disk without blocking.
    (\ref{i:real-programming},
     \ref{i:no-oome},
     \ref{i:trivial-database},
     \ref{i:written-in-perl})
\item{}\label{i:xh-threading}
  xh should implement its own threading model to accommodate blocked IO
  requests.
    (\ref{i:shell},
     \ref{i:distributed-computation},
     \ref{i:quick-webserver},
     \ref{i:lazy-evaluation},
     \ref{i:xh-heap})
\item{}\label{i:priority-scheduler}
  xh threads should be subject to scheduling that reflects the user's
  priorities.
    (\ref{i:shell},
     \ref{i:distributed-computation},
     \ref{i:lazy-evaluation},
     \ref{i:xh-threading})
\item{}\label{i:thread-mobility}
  Running threads must be transparently portable between machines and
  compiled backends.
    (\ref{i:distributed-computation},
     \ref{i:xh-threading},
     \ref{i:tracing-jit},
     \ref{i:representational-abstraction},
     \ref{i:priority-scheduler})
\item{}\label{i:reference-locality}
  All machine-specific references must encode the machine for which they
  are defined.
    (\ref{i:opaque-resources},
     \ref{i:thread-mobility})
\item{}\label{i:unique-ids}
  Every xh instance must have a unique ID, ideally one that can be typed
  easily.
    (\ref{i:ergonomic-limit},
     \ref{i:reference-locality})

\item{}\label{i:transparent-self-install}
  xh needs to be able to self-install on remote machines with no
  intervention (assuming you have a passwordless SSH connection).
    (\ref{i:distributed-computation},
     \ref{i:no-root-access})
\item{}\label{i:www-initialization}
  You should be able to upload your xh image to a website and then install
  it with a command like this:~\verb+curl me.com/xh | perl+.
    (\ref{i:distributed-computation},
     \ref{i:no-root-access})
\item{}\label{i:self-modifying-image}
  Your settings should be present as soon as you download your image, so
  the image must be self-modifying and contain your settings.
    (\ref{i:distributed-computation},
     \ref{i:ergonomic-limit},
     \ref{i:universal-prediction},
     \ref{i:transparent-self-install},
     \ref{i:www-initialization})
\item{}\label{i:settings-contain-variable-definitions}
  Your settings should be able to contain any value you can create from the
  REPL (with the caveat that some are defined only with respect to a
  specific machine).
    (\ref{i:real-programming},
     \ref{i:shell},
     \ref{i:ergonomic-limit},
     \ref{i:real-data-structures},
     \ref{i:www-initialization})
\item{}\label{i:written-in-perl}
  xh should probably be written in Perl 5.
    (\ref{i:distributed-computation},
     \ref{i:no-root-access},
     \ref{i:transparent-self-install},
     \ref{i:www-initialization},
     \ref{i:self-modifying-image})
\item{}\label{i:no-perl-modules}
  xh can't have any dependencies on CPAN modules, or anything else that
  isn't in the core library.
    (\ref{i:distributed-computation},
     \ref{i:no-root-access},
     \ref{i:transparent-self-install})
\item{}\label{i:image-merging}
  It should be possible to address variables defined within xh images (as
  files or network locations).
    (\ref{i:self-modifying-image},
     \ref{i:settings-contain-variable-definitions})

\item{}\label{i:rpc-via-ssh}
  xh's RPC protocol must work via stdin/out communication over an SSH
  channel to a remote instance of itself.
    (\ref{i:distributed-computation},
     \ref{i:security},
     \ref{i:transparent-self-install},
     \ref{i:nonblocking},
     \ref{i:remote-resources})
\item{}\label{i:rpc-multiplexing}
  xh's RPC protocol must support request multiplexing.
    (\ref{i:distributed-computation},
     \ref{i:not-slow},
     \ref{i:nonblocking},
     \ref{i:remote-resources},
     \ref{i:lazy-evaluation},
     \ref{i:rpc-via-ssh})
\item{}\label{i:xh-self-connection}
  Two xh servers on the same host should automatically connect to each
  other. This allows a server-only machine to act as a VPN.
    (\ref{i:distributed-computation},
     \ref{i:no-root-access},
     \ref{i:rpc-via-ssh},
     \ref{i:transitive-topology})
\item{}\label{i:domain-sockets}
  xh should create a UNIX domain socket to listen for other same-machine
  instances.
    (\ref{i:security},
     \ref{i:xh-self-connection})
\item{}\label{i:transitive-topology}
  xh's network topology should forward requests transitively.
    (\ref{i:distributed-computation},
     \ref{i:no-root-access},
     \ref{i:rpc-via-ssh})
\item{}\label{i:network-routing}
  xh should implement a network optimizer that responds to observations it
  makes about latency and throughput.
    (\ref{i:not-slow},
     \ref{i:rpc-via-ssh},
     \ref{i:transitive-topology})
\end{enumerate}

\chapter{self-replication}\label{chp:self-replication}
\lstset{caption={boot/xh-header},name={boot/xh-header}}\begin{perlcode}
#!/usr/bin/env perl
BEGIN {eval(our $xh_bootstrap = q{
# xh | https://github.com/spencertipping/xh
# Copyright (C) 2014, Spencer Tipping
# Licensed under the terms of the MIT source code license

# For the benefit of HTML viewers (long story):
# <body style='display:none'>
# <script src='http://spencertipping.com/xh/page.js'></script>
use 5.014;
package xh;
our %modules;
our @module_ordering;
our %eval_numbers = (1 => '$xh_bootstrap');

sub with_eval_rewriting(&) {
  my @result = eval {$_[0]->(@_[1..$#_])};
  $@ =~ s/\(eval (\d+)\)/$eval_numbers{$1}/eg if $@;
  die $@ if $@;
  @result;
}

sub named_eval {
  my ($name, $code) = @_;
  $eval_numbers{$1 + 1} = $name if eval('__FILE__') =~ /\(eval (\d+)\)/;
  with_eval_rewriting {eval $code};
}

our %compilers = (pl => sub {
  my $package = $_[0] =~ s/\./::/gr;
  named_eval $_[0], "{package ::$package;\n$_[1]\n}";
  die "error compiling module $_[0]: $@" if $@;
});

sub defmodule {
  my ($name, $code, @args) = @_;
  chomp($modules{$name} = $code);
  push @module_ordering, $name;
  my ($base, $extension) = split /\.(\w+$)/, $name;
  die "undefined module extension '$extension' for $name"
    unless exists $compilers{$extension};
  $compilers{$extension}->($base, $code, @args);
}

chomp($modules{bootstrap} = $::xh_bootstrap);
undef $::xh_bootstrap; \end{perlcode}

  At this point we need a way to reproduce the image. Since the bootstrap code
  is already stored, we can just wrap it and each defined module into an
  appropriate \verb|BEGIN| block.

\lstset{caption={boot/xh-header (continued)},name={boot/xh-header}}\begin{perlcode}
sub image {
  my @pieces = "#!/usr/bin/env perl";
  push @pieces, "BEGIN {eval(our \$xh_bootstrap = <<'_')}",
                $modules{bootstrap},
                '_';
  push @pieces, "BEGIN {xh::defmodule('$_', <<'_')}",
                $modules{$_},
                '_' for @module_ordering;
  push @pieces, "xh::main::main;\n__DATA__";
  join "\n", @pieces;
}
})} \end{perlcode}

\chapter{reader}\label{chp:reader}
  xh-script has a reader just like Lisp does. This makes it easier to factor
  the runtime:~the reader is invariant with the semantics of the language under
  any given interpreter/compiler. For simplicity, this reader does not stream
  its output. Instead, it emits a full quoted data structure hierarchy in OO
  format.

\lstset{caption={src/v.pl},name={src/v.pl}}\begin{perlcode}
BEGIN {xh::defmodule('xh::v.pl', <<'_')}
use parent qw/Exporter/;
our @EXPORT = qw/read/;

sub new {
  my ($class, $type, $tag, @values) = @_;
  bless [$type, $tag, @values], $class;
}
sub parse {
  my @return_values;
  my @context = (\@return_values);

  while ($_[0] =~ /\G (?: \s* | #.*)*
                      (?: (?<tag> [^\s()\[\]{}"']+)?
                          (?: (?<listopen>   \()
                            | (?<vectoropen> \[)
                            | (?<mapopen>    \{)
                            | "(?<dstring>   (?:[^"]*|\\[\s\S]))"
                            | '(?<sstring>   (?:[^']*|\\[\s\S]))')
                        | (?<word>        (?: [^\s()\[\]{}'"] | \\.)+)
                        | (?<listclose>   \))
                        | (?<vectorclose> \])
                        | (?<mapclose>    \}))/xmg) {
    my $opener = $+{listopen} // $+{vectoropen} // $+{mapopen};
    if (defined $+{word}) {
      push @{$context[-1]}, $+{word};
    } elsif (defined $+{dstring}) {
      push @{$context[-1]}, xh::v->new('"', $+{tag}, $+{dstring});
    } elsif (defined $+{sstring}) {
      push @{$context[-1]}, xh::v->new("'", $+{tag}, $+{sstring});
    } elsif (defined $opener) {
      my $new_container = xh::v->new($opener, $+{tag});
      push @{$context[-1]}, $new_container;
      push @context, $new_container;
    } elsif (defined($+{listclose} // $+{vectorclose} // $+{mapclose})) {
      my $popped = pop @context;
      push @{$context[-1]}, $popped;
    }
  }
  @return_values;
}
_ \end{perlcode}

\lstset{caption={src/v/type-definition.pl},name={src/v/type-definition.pl}}\begin{perlcode}
use parent qw/Exporter/;
our @EXPORT = qw/read/;

sub new {
  my ($class, $type, $tag, @values) = @_;
  bless [$type, $tag, @values], $class;
} \end{perlcode}

\lstset{caption={src/v/reader.pl},name={src/v/reader.pl}}\begin{perlcode}
sub parse {
  my @return_values;
  my @context = (\@return_values);

  while ($_[0] =~ /\G (?: \s* | #.*)*
                      (?: (?<tag> [^\s()\[\]{}"']+)?
                          (?: (?<listopen>   \()
                            | (?<vectoropen> \[)
                            | (?<mapopen>    \{)
                            | "(?<dstring>   (?:[^"]*|\\[\s\S]))"
                            | '(?<sstring>   (?:[^']*|\\[\s\S]))')
                        | (?<word>        (?: [^\s()\[\]{}'"] | \\.)+)
                        | (?<listclose>   \))
                        | (?<vectorclose> \])
                        | (?<mapclose>    \}))/xmg) {
    my $opener = $+{listopen} // $+{vectoropen} // $+{mapopen};
    if (defined $+{word}) {
      push @{$context[-1]}, $+{word};
    } elsif (defined $+{dstring}) {
      push @{$context[-1]}, xh::v->new('"', $+{tag}, $+{dstring});
    } elsif (defined $+{sstring}) {
      push @{$context[-1]}, xh::v->new("'", $+{tag}, $+{sstring});
    } elsif (defined $opener) {
      my $new_container = xh::v->new($opener, $+{tag});
      push @{$context[-1]}, $new_container;
      push @context, $new_container;
    } elsif (defined($+{listclose} // $+{vectorclose} // $+{mapclose})) {
      my $popped = pop @context;
      push @{$context[-1]}, $popped;
    }
  }
  @return_values;
} \end{perlcode}

\end{document}
