\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}
\lstnewenvironment{pythoncode}    {\lstset{language=python}}{}

\lstnewenvironment{resourcecode}{}{}

\newcommand{\bs}{\textbackslash}
\setcounter{tocdepth}{0}
\lstnewenvironment{xhcode}{}{}

\title{xh}
\author{Spencer Tipping}

\begin{document}
\maketitle{}
\tableofcontents{}


\part{design}\label{part:design}
\chapter{constraints}\label{chp:design-constraints}
  xh is designed to be a powerful and ergonomic interface to multiple systems,
  many of which are remote. As such, it's subject to programming language,
  shell, and distributed-systems constraints:

\begin{enumerate}
\item{}\label{i:real-programming}
  xh will be used for real programming.
    (Initial assumption)
\item{}\label{i:shell}
  xh will be used as a shell.
    (Initial assumption)
\item{}\label{i:distributed-computation}
  xh will be used to manage any machine on which you have a login, which
  could be hundreds or thousands.
    (Initial assumption)
\item{}\label{i:no-root-access}
  You will not always have root access to machines you want to use, and
  they may have different architectures.
    (Initial assumption)
\item{}\label{i:ergonomic-limit}
  xh should approach the limit of ergonomic efficiency as it learns more
  about you.
    (Initial assumption)
\item{}\label{i:security}
  xh should never compromise your security, provided you understand what
  it's doing.
    (Initial assumption)

\item{}\label{i:quick-webserver}
  It should be possible to write a ``hello world'' HTTP server on one line.
    (Initial assumption,
     \ref{i:real-programming},
     \ref{i:shell})
\item{}\label{i:live-preview}
  It should be possible to preview the evaluation of any well-formed
  expression without causing side-effects.
    (Initial assumption,
     \ref{i:shell},
     \ref{i:ergonomic-limit},
     \ref{i:trivial-debugging})
\item{}\label{i:not-slow}
  xh should never cause a dealbreaking performance problem.
    (Initial assumption,
     \ref{i:real-programming},
     \ref{i:ergonomic-limit})
\item{}\label{i:unreliable-connections}
  Connections between machines may die at any time, and remain down for
  arbitrarily long. xh must never become unresponsive when this happens,
  and any data coming from those machines should block until it is
  available again (i.e.~xh's behavior should be invariant with connection
  failures).
    (Initial assumption,
     \ref{i:real-programming},
     \ref{i:shell},
     \ref{i:distributed-computation})
\item{}\label{i:trivial-debugging}
  Debugging should require little or no effort; all error cases should be
  trivially obvious.
    (Initial assumption,
     \ref{i:real-programming},
     \ref{i:distributed-computation},
     \ref{i:ergonomic-limit})
\item{}\label{i:trivial-database}
  An xh instance should trivially function as a database; there should be
  no distinction between data in memory and data on disk.
    (Initial assumption,
     \ref{i:real-programming},
     \ref{i:ergonomic-limit},
     \ref{i:trivial-debugging},
     \ref{i:no-oome},
     \ref{i:not-slow})

\item{}\label{i:universal-prediction}
  xh should use every keystroke to build/refine a model it uses to predict
  future keystrokes and commands.
    (\ref{i:ergonomic-limit})
\item{}\label{i:forgetful-history}
  The likelihood that xh forgets anything from your command history should
  be inversely proportional to the amount of effort required to
  retype/recreate it.
    (\ref{i:ergonomic-limit},
     \ref{i:universal-prediction})
\item{}\label{i:locally-anonymous}
  xh must provide a way to accept input and execute commands without
  updating its prediction model.
    (\ref{i:security})
\item{}\label{i:http-client}
  xh should be able to submit an encrypted version of its current state to
  HTTP services like Github gists or pastebin.
    (\ref{i:ergonomic-limit},
     \ref{i:security},
     \ref{i:unreliable-connections},
     \ref{i:transparent-self-install},
     \ref{i:www-initialization})

\item{}\label{i:feel-like-shell}
  xh-script needs to feel like a regular shell for most purposes.
    (\ref{i:shell})
\item{}\label{i:imperative}
  xh-script should be fundamentally imperative.
    (\ref{i:real-programming},
     \ref{i:shell},
     \ref{i:feel-like-shell})
\item{}\label{i:no-oome}
  xh must never run out of memory or swap pages to disk, regardless of what
  you tell it to do.
    (\ref{i:real-programming},
     \ref{i:shell},
     \ref{i:not-slow},
     \ref{i:ergonomic-limit})
\item{}\label{i:nonblocking}
  xh must respond to every keystroke within 20ms; therefore, SSH must be
  used only for nonblocking RPC requests (i.e.~the shell always runs
  locally).
    (\ref{i:shell},
     \ref{i:not-slow},
     \ref{i:ergonomic-limit})
\item{}\label{i:remote-resources}
  All resources, local and remote, must be uniformly accessible;
  i.e.~autocomplete, filename substitution, etc, must all just work (up to
  random access, which is impossible without FUSE or similar).
    (\ref{i:shell},
     \ref{i:distributed-computation},
     \ref{i:ergonomic-limit})

\item{}\label{i:prefix-notation}
  xh-script uses prefix notation.
    (\ref{i:shell})
\item{}\label{i:quasiquoting}
  xh-script quasiquotes values by default.
    (\ref{i:shell})
\item{}\label{i:unquoting}
  xh-script defines an unquote operator.
    (\ref{i:shell},
     \ref{i:quasiquoting})

\item{}\label{i:real-data-structures}
  The xh runtime provides real, garbage-collected data structures.
    (\ref{i:real-programming})
\item{}\label{i:data-structures-can-be-quoted}
  Every xh data structure has a quoted form.
    (\ref{i:real-data-structures},
     \ref{i:shell},
     \ref{i:trivial-debugging},
     \ref{i:live-preview})
\item{}\label{i:data-structures-can-be-serialized}
  Every xh data structure can be losslessly serialized.
    (\ref{i:shell},
     \ref{i:distributed-computation},
     \ref{i:trivial-database},
     \ref{i:data-structures-can-be-quoted},
     \ref{i:settings-contain-variable-definitions},
     \ref{i:image-merging})
\item{}\label{i:data-structures-are-immutable}
  Data structures have no identity and therefore are immutable.
    (\ref{i:distributed-computation},
     \ref{i:data-structures-can-be-serialized})

\item{}\label{i:opaque-resources}
  xh-script must have access to machine-specific opaque resources like PIDs
  and file handles.
    (\ref{i:real-programming},
     \ref{i:shell})
\item{}\label{i:mutable-symbol-table}
  Each xh instance should implement a mutable symbol table with weak
  reference support, subject to semi-conservative distributed garbage
  collection.
    (\ref{i:data-structures-are-immutable},
     \ref{i:opaque-resources},
     \ref{i:no-oome},
     \ref{i:xh-heap})
\item{}\label{i:state-ownership}
  Every piece of mutable state, including symbol tables, must have at most
  one authoritative copy (mutable state within xh is managed by a CP
  system).
    (\ref{i:unreliable-connections},
     \ref{i:opaque-resources},
     \ref{i:mutable-symbol-table},
     \ref{i:thread-mobility})
\item{}\label{i:checkpointing}
  An xh instance should be able to save checkpoints of itself in case of
  failure. If you do this, xh becomes an AP system.
    (\ref{i:unreliable-connections},
     \ref{i:state-ownership})

\item{}\label{i:lazy-evaluation}
  xh's evaluator must support some kind of laziness.
    (\ref{i:real-programming},
     \ref{i:no-oome},
     \ref{i:remote-resources},
     \ref{i:not-slow})
\item{}\label{i:laziness-serializable}
  Lazy values must have well-defined quoted forms and be losslessly
  serializable.
    (\ref{i:data-structures-can-be-quoted},
     \ref{i:data-structures-can-be-serialized},
     \ref{i:lazy-evaluation},
     \ref{i:thread-mobility},
     \ref{i:xh-heap})
\item{}\label{i:lazy-introspection}
  All lazy values must be subject to introspection to identify why they
  haven't been realized.
    (\ref{i:trivial-debugging},
     \ref{i:not-slow},
     \ref{i:unreliable-connections},
     \ref{i:nonblocking},
     \ref{i:lazy-evaluation},
     \ref{i:priority-scheduler})
\item{}\label{i:abstract-evaluation}
  xh must be able to partially evaluate expressions that contain unknown
  quantities.
    (\ref{i:live-preview},
     \ref{i:lazy-evaluation},
     \ref{i:lazy-introspection},
     \ref{i:laziness-serializable})
\item{}\label{i:code-as-data}
  xh-script code should be a reasonable data storage format.
    (\ref{i:shell},
     \ref{i:abstract-evaluation})
\item{}\label{i:parse-self}
  xh-script must contain a library to parse itself.
    (\ref{i:code-as-data})
\item{}\label{i:homoiconic}
  xh-script must be homoiconic.
    (\ref{i:code-as-data},
     \ref{i:parse-self},
     \ref{i:self-hosting-runtime},
     \ref{i:representational-abstraction})

\item{}\label{i:compile-to-c}
  xh should be able to compile any function to C, compile it if the host
  has a C compiler, and transparently migrate execution into this process.
    (\ref{i:real-programming},
     \ref{i:thread-mobility},
     \ref{i:not-slow})
\item{}\label{i:compile-to-perl}
  xh should be able to compile any function to Perl rather than
  interpreting its execution.
    (\ref{i:real-programming},
     \ref{i:no-root-access},
     \ref{i:not-slow})
\item{}\label{i:compile-to-js}
  xh should be able to compile any function to Javascript so that browser
  sessions can transparently become computing nodes.
    (\ref{i:real-programming},
     \ref{i:distributed-computation},
     \ref{i:not-slow})
\item{}\label{i:self-hosting-runtime}
  xh should follow a bootstrapped self-hosting runtime model.
    (\ref{i:compile-to-c},
     \ref{i:compile-to-perl},
     \ref{i:compile-to-js}
     \ref{i:representational-abstraction})
\item{}\label{i:tracing-jit}
  xh-script should be executed by a profiling/tracing dynamic compiler that
  automatically compiles certain pieces of code to alternative forms like
  Perl or C.
    (\ref{i:not-slow})
\item{}\label{i:representational-abstraction}
  The xh compiler should optimize data structure representations for the
  backend being targeted.
    (\ref{i:not-slow},
     \ref{i:thread-mobility},
     \ref{i:tracing-jit})

\item{}\label{i:xh-heap}
  xh needs to implement its own heap and memory manager, and swap values to
  disk without blocking.
    (\ref{i:real-programming},
     \ref{i:no-oome},
     \ref{i:trivial-database},
     \ref{i:written-in-perl})
\item{}\label{i:xh-threading}
  xh should implement its own threading model to accommodate blocked IO
  requests.
    (\ref{i:shell},
     \ref{i:distributed-computation},
     \ref{i:quick-webserver},
     \ref{i:lazy-evaluation},
     \ref{i:xh-heap})
\item{}\label{i:priority-scheduler}
  xh threads should be subject to scheduling that reflects the user's
  priorities.
    (\ref{i:shell},
     \ref{i:distributed-computation},
     \ref{i:lazy-evaluation},
     \ref{i:xh-threading})
\item{}\label{i:thread-mobility}
  Running threads must be transparently portable between machines and
  compiled backends.
    (\ref{i:distributed-computation},
     \ref{i:xh-threading},
     \ref{i:tracing-jit},
     \ref{i:representational-abstraction},
     \ref{i:priority-scheduler})
\item{}\label{i:reference-locality}
  All machine-specific references must encode the machine for which they
  are defined.
    (\ref{i:opaque-resources},
     \ref{i:thread-mobility})
\item{}\label{i:unique-ids}
  Every xh instance must have a unique ID, ideally one that can be typed
  easily.
    (\ref{i:ergonomic-limit},
     \ref{i:reference-locality})

\item{}\label{i:transparent-self-install}
  xh needs to be able to self-install on remote machines with no
  intervention (assuming you have a passwordless SSH connection).
    (\ref{i:distributed-computation},
     \ref{i:no-root-access})
\item{}\label{i:www-initialization}
  You should be able to upload your xh image to a website and then install
  it with a command like this:~\verb+curl me.com/xh | perl+.
    (\ref{i:distributed-computation},
     \ref{i:no-root-access})
\item{}\label{i:self-modifying-image}
  Your settings should be present as soon as you download your image, so
  the image must be self-modifying and contain your settings.
    (\ref{i:distributed-computation},
     \ref{i:ergonomic-limit},
     \ref{i:universal-prediction},
     \ref{i:transparent-self-install},
     \ref{i:www-initialization})
\item{}\label{i:settings-contain-variable-definitions}
  Your settings should be able to contain any value you can create from the
  REPL (with the caveat that some are defined only with respect to a
  specific machine).
    (\ref{i:real-programming},
     \ref{i:shell},
     \ref{i:ergonomic-limit},
     \ref{i:real-data-structures},
     \ref{i:www-initialization})
\item{}\label{i:written-in-perl}
  xh should probably be written in Perl 5.
    (\ref{i:distributed-computation},
     \ref{i:no-root-access},
     \ref{i:transparent-self-install},
     \ref{i:www-initialization},
     \ref{i:self-modifying-image})
\item{}\label{i:no-perl-modules}
  xh can't have any dependencies on CPAN modules, or anything else that
  isn't in the core library.
    (\ref{i:distributed-computation},
     \ref{i:no-root-access},
     \ref{i:transparent-self-install})
\item{}\label{i:image-merging}
  It should be possible to address variables defined within xh images (as
  files or network locations).
    (\ref{i:self-modifying-image},
     \ref{i:settings-contain-variable-definitions})

\item{}\label{i:rpc-via-ssh}
  xh's RPC protocol must work via stdin/out communication over an SSH
  channel to a remote instance of itself.
    (\ref{i:distributed-computation},
     \ref{i:security},
     \ref{i:transparent-self-install},
     \ref{i:nonblocking},
     \ref{i:remote-resources})
\item{}\label{i:rpc-multiplexing}
  xh's RPC protocol must support request multiplexing.
    (\ref{i:distributed-computation},
     \ref{i:not-slow},
     \ref{i:nonblocking},
     \ref{i:remote-resources},
     \ref{i:lazy-evaluation},
     \ref{i:rpc-via-ssh})
\item{}\label{i:xh-self-connection}
  Two xh servers on the same host should automatically connect to each
  other. This allows a server-only machine to act as a VPN.
    (\ref{i:distributed-computation},
     \ref{i:no-root-access},
     \ref{i:rpc-via-ssh},
     \ref{i:transitive-topology})
\item{}\label{i:domain-sockets}
  xh should create a UNIX domain socket to listen for other same-machine
  instances.
    (\ref{i:security},
     \ref{i:xh-self-connection})
\item{}\label{i:transitive-topology}
  xh's network topology should forward requests transitively.
    (\ref{i:distributed-computation},
     \ref{i:no-root-access},
     \ref{i:rpc-via-ssh})
\item{}\label{i:network-routing}
  xh should implement a network optimizer that responds to observations it
  makes about latency and throughput.
    (\ref{i:not-slow},
     \ref{i:rpc-via-ssh},
     \ref{i:transitive-topology})
\end{enumerate}

\chapter{xh-script}\label{chp:design-xh-script}
  These constraints are based on the ones in
  \Ref{chapter}{chp:design-constraints}.

\begin{enumerate}
\item{}\label{is:evaluation-identities}
  Evaluation of any expression may happen at any time; the only scheduling
  constraint is the realization of lazy expressions, whose status is
  visible by looking at their quoted forms. Therefore, the evaluator is, to
  some degree, associative, commutative, and idempotent.
    (Initial assumption,
     \ref{i:distributed-computation} above,
     \ref{i:trivial-debugging} above,
     \ref{i:live-preview} above,
     \ref{i:nonblocking} above,
     \ref{i:lazy-evaluation} above,
     \ref{i:lazy-introspection} above,
     \ref{i:abstract-evaluation} above)

\item{}\label{is:relational-evaluation}
  Relational evaluation is possible by using {\tt amb}, which returns any
  of the given presumably-equivalent values. xh-script is relational and
  invertible, though inversion is not always lossless and may produce
  perpetually-unresolved unknowns representing degrees of freedom.
    (Initial assumption,
     \ref{i:trivial-debugging} above,
     \ref{i:lazy-evaluation} above,
     \ref{i:lazy-introspection} above,
     \ref{i:abstract-evaluation} above,
     \ref{i:self-hosting-runtime} above,
     \ref{i:representational-abstraction} above,
     \ref{i:priority-scheduler} above,
     \ref{is:evaluation-identities})
\item{}\label{is:best-first-search}
  Due to functions like {\tt amb}, evaluation proceeds as a best-first
  search through the space of values. You can influence this search by
  defining the {\tt abstraction} relation for a particular class of
  expressions.
    (\ref{i:not-slow} above,
     \ref{is:relational-evaluation})
\item{}\label{is:no-cut-operator}
  Unlike Prolog, xh defines no cut primitive. You should use {\tt
  abstraction} to locally grade the search space instead.
    (\ref{i:trivial-debugging} above,
     \ref{is:evaluation-identities},
     \ref{is:best-first-search})

\item{}\label{is:unquote-structure-preserving}
  The unquoting operators \verb|$|, \verb|$@|, \verb|()|, and \verb|@()|
  each preserve some aspect of structure:
\begin{itemize}
\item{}
  \verb|$| and \verb|()| preserve list structure and atom count, and
  strictly decrease quotation level.
\item{}
  \verb|$@| and \verb|@()| preserve list levels while varying atom
  count, and strictly decrease quotation level.
\item{}
  \verb|$!| and \verb|!()| locally preserve list structure, atom count,
  and quotation level. These are the only forms that won't block when
  expanding unrealized lazy values.
\end{itemize}
  Operators that decrease quotation level will block if the result requires
  quoting to represent fully.
    (Initial assumption,
     \ref{i:real-programming} above,
     \ref{i:unquoting} above,
     \ref{i:not-slow} above)
\item{}\label{is:stack-local-scoping}
  All scoping is done by passing a second argument to {\tt unquote}; this
  enables variable resolution during the unquoting operation.
    (Initial assumption,
     \ref{i:unquoting} above,
     \ref{i:mutable-symbol-table} above,
     \ref{is:evaluation-identities})
\item{}\label{is:no-variable-shadowing}
  Variable shadowing is impossible.
    (\ref{is:evaluation-identities},
     \ref{is:stack-local-scoping})
\item{}\label{is:unquoting-vs-parsing}
  Unquoting and structural parsing are orthogonal operations provided by
  {\tt unquote} and {\tt read}, respectively.
    (\ref{i:data-structures-can-be-quoted} above,
     \ref{i:lazy-introspection} above,
     \ref{is:evaluation-identities},
     \ref{is:unquote-structure-preserving})

\item{}\label{is:runtime-as-receiver}
  Whether via RPC or locally, statements issued to an xh runtime can be
  interpreted as messages being sent to a receiver; the reply is sent along
  whatever continuation is specified. The runtime doesn't differentiate
  between local and remote requests, including those made by functions.
    (\ref{i:imperative} above,
     \ref{i:xh-threading} above,
     \ref{i:thread-mobility} above,
     \ref{i:state-ownership} above)
\item{}\label{is:function-variable-namespaces}
  Functions and variables exist in separate namespaces.
    (\ref{i:feel-like-shell} above,
     \ref{i:unquoting} above,
     \ref{is:stack-local-scoping},
     \ref{is:runtime-as-receiver})
\item{}\label{is:function-literals-as-messages}
  Function literals are self-invoking when used as messages.
    (\ref{is:function-variable-namespaces})
\item{}\label{is:no-real-continuations}
  Continuations are simulated in terms of lazy evaluation, but are never
  first-class.
    (\ref{i:tracing-jit} above,
     \ref{i:lazy-introspection} above,
     \ref{i:abstract-evaluation} above,
     \ref{is:runtime-as-receiver})
\item{}\label{is:transient-definitions}
  Some definitions are ``transient,'' in which case they are used to
  resolve blocked lazy values but then may be discarded at any point.
    (\ref{i:distributed-computation} above,
     \ref{i:no-oome} above,
     \ref{i:lazy-evaluation} above,
     \ref{is:runtime-as-receiver})
\item{}\label{is:global-definition-universality}
  Global definitions can apply to values at any time, and to values on
  different machines (i.e.~their existence is broadcast).
    (\ref{i:lazy-evaluation} above,
     \ref{is:transient-definitions})

\item{}\label{is:macros-cannot-exist}
  Syntactic macros cannot exist because invocation commutes with expansion,
  but functions may operate on terms whose values are undefined.
    (\ref{is:evaluation-identities},
     \ref{is:unquote-structure-preserving})
\item{}\label{is:errors-cannot-exist}
  Errors cannot exist, but are represented by lazy values that contain
  undefined quantities that will never be realized. These undefined
  quantities are the unevaluated backtraces to the error-causing
  subexpressions.
    (\ref{i:trivial-debugging} above,
     \ref{i:lazy-evaluation} above,
     \ref{i:abstract-evaluation} above,
     \ref{is:evaluation-identities})
\end{enumerate}

\part{base implementation}\label{part:base-implementation}
\chapter{self-replication}\label{chp:self-replication}
\lstset{caption={boot/xh-header},name={boot/xh-header}}\begin{perlcode}
#!/usr/bin/env perl
BEGIN {eval(our $xh_bootstrap = q{
# xh | https://github.com/spencertipping/xh
# Copyright (C) 2014, Spencer Tipping
# Licensed under the terms of the MIT source code license

# For the benefit of HTML viewers (long story):
# <body style='display:none'>
# <script src='http://spencertipping.com/xh/page.js'></script>
use 5.014;
package xh;
our %modules;
our @module_ordering;
our %eval_numbers = (1 => '$xh_bootstrap');

sub with_eval_rewriting(&) {
  my @result = eval {$_[0]->(@_[1..$#_])};
  die $@ =~ s/\(eval (\d+)\)/$eval_numbers{$1}/egr if $@;
  @result;
}

sub named_eval {
  my ($name, $code) = @_;
  $eval_numbers{$1 + 1} = $name if eval('__FILE__') =~ /\(eval (\d+)\)/;
  with_eval_rewriting {eval $code; die $@ if $@};
}

our %compilers = (pl => sub {
  my $package = $_[0] =~ s/\./::/gr;
  eval {named_eval $_[0], "{package ::$package;\n$_[1]\n}"};
  die "error compiling module $_[0]: $@" if $@;
});

sub defmodule {
  my ($name, $code, @args) = @_;
  chomp($modules{$name} = $code);
  push @module_ordering, $name;
  my ($base, $extension) = split /\.(\w+$)/, $name;
  die "undefined module extension '$extension' for $name"
    unless exists $compilers{$extension};
  $compilers{$extension}->($base, $code, @args);
}

chomp($modules{bootstrap} = $::xh_bootstrap);
undef $::xh_bootstrap; \end{perlcode}

  At this point we need a way to reproduce the image. Since the bootstrap code
  is already stored, we can just wrap it and each defined module into an
  appropriate \verb|BEGIN| block.

\lstset{caption={boot/xh-header (continued)},name={boot/xh-header}}\begin{perlcode}
sub image {
  join "\n", "#!/usr/bin/env perl",
             "BEGIN {eval(our \$xh_bootstrap = <<'_')}",
             $modules{bootstrap},
             '_',
             map(("BEGIN {xh::defmodule('$_', <<'_')}",
                  $modules{$_},
                  '_'), @module_ordering),
             "xh::main::main;\n__DATA__";
}
})} \end{perlcode}

\chapter{reader}\label{chp:reader}
  xh-script has a reader just like Lisp does. This makes it easier to factor
  the runtime:~the reader is invariant with the semantics of the language under
  any given interpreter/compiler. For simplicity, this reader does not stream
  its output. Instead, it emits a full quoted data structure hierarchy in OO
  format.

\lstset{caption={src/v.pl},name={src/v.pl}}\begin{perlcode}
BEGIN {xh::defmodule('xh::v.pl', <<'_')}
-- include src/v/type-definition.pl
-- include src/v/reader.pl
_ \end{perlcode}

\lstset{caption={src/v/type-definition.pl},name={src/v/type-definition.pl}}\begin{perlcode}
use parent qw/Exporter/;
our @EXPORT_OK = qw/parse/;

sub new {
  my ($class, $type, $tag, @values) = @_;
  bless [$type, $tag, @values], $class;
} \end{perlcode}

\lstset{caption={src/v/reader.pl},name={src/v/reader.pl}}\begin{perlcode}
sub parse {
  my @return_values;
  my @context = (\@return_values);

  while ($_[0] =~ /\G (?: \s* | \#.*)*
                      (?: (?<tag> (?: [^\s()\[\]{}"'\\] | \\.)+)?
                          (?: (?<listopen>   \()
                            | (?<vectoropen> \[)
                            | (?<mapopen>    \{)
                            | "(?<dstring>   (?:[^"\\]*|\\[\s\S]))"
                            | '(?<sstring>   (?:[^'\\]*|\\[\s\S]))')
                        | (?<word>        (?: [^\s()\[\]{}'"\\] | \\.)+)
                        | (?<listclose>   \))
                        | (?<vectorclose> \])
                        | (?<mapclose>    \}))/xmg) {
    my $opener = $+{listopen} // $+{vectoropen} // $+{mapopen};
    if (defined $+{word}) {
      push @{$context[-1]}, $+{word};
    } elsif (defined $+{dstring}) {
      push @{$context[-1]}, xh::v->new('"', $+{tag}, $+{dstring});
    } elsif (defined $+{sstring}) {
      push @{$context[-1]}, xh::v->new("'", $+{tag}, $+{sstring});
    } elsif (defined $opener) {
      my $new_container = xh::v->new($opener, $+{tag});
      push @{$context[-1]}, $new_container;
      push @context, $new_container;
    } elsif (defined($+{listclose} // $+{vectorclose} // $+{mapclose})) {
      my $popped = pop @context;
      push @{$context[-1]}, $popped;
    }
  }
  @return_values;
} \end{perlcode}

\end{document}
