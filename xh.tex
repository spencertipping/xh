\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

% Shamelessly swiped from
% http://compgroups.net/comp.text.tex/using-ref-and-label-so-that-ref-points-to-the-l/245066
\makeatletter
\newcommand*{\Label}[2]{%
  \@bsphack
  \begingroup
    \label{#1-original}%
    \def\@currentlabel{#2}%
    \label{#1}%
  \endgroup
  \@esphack
}
\makeatother


\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}
\lstnewenvironment{pythoncode}    {\lstset{language=python}}{}

\lstnewenvironment{resourcecode}{}{}

\newcommand{\bs}{\textbackslash}
\setcounter{tocdepth}{0}
\lstnewenvironment{xhcode}{}{}

\newcommand{\initial}{{\em initial assumption}}
\newcommand{\refboth}[1]{{\em \ref{#1}} \ref{#1-original}}

\title{xh}
\author{Spencer Tipping}

\begin{document}
\maketitle{}
\tableofcontents{}


\part{design}\label{part:design}
\chapter{constraints}\label{chp:design-constraints}
  xh is designed to be a powerful and ergonomic interface to multiple systems,
  many of which are remote. As such, it's subject to programming language,
  shell, and distributed-systems constraints:

\begin{enumerate}
\item{}\Label{i:real-programming}{realprog}{\em\ref{i:real-programming}}
  xh will be used for real programming.
(\initial)
\item{}\Label{i:shell}{shell}{\em\ref{i:shell}}
  xh will be used as a shell.
(\initial)
\item{}\Label{i:distributed-computation}{distributed}{\em\ref{i:distributed-computation}}
  xh will be used to manage any machine on which you have a login, which
  could be hundreds or thousands.
(\initial)
\item{}\Label{i:no-root-access}{noroot}{\em\ref{i:no-root-access}}
  You will not always have root access to machines you want to use, and
  they may have different architectures.
(\initial)
\item{}\Label{i:ergonomic-limit}{ergonomic}{\em\ref{i:ergonomic-limit}}
  xh should approach the limit of ergonomic efficiency as it learns more
  about you.
(\initial)
\item{}\Label{i:security}{security}{\em\ref{i:security}}
  xh should never compromise your security, provided you understand what
  it's doing.
(\initial)

\item{}\Label{i:quick-webserver}{webserver}{\em\ref{i:quick-webserver}}
  It should be possible to write a ``hello world'' HTTP server on one line.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\end{itemize}
\item{}\Label{i:live-preview}{liveprev}{\em\ref{i:live-preview}}
  It should be possible to preview the evaluation of any well-formed
  expression without causing side-effects.
\begin{itemize}
\item \initial
\item \refboth{i:shell}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:trivial-debugging}
\end{itemize}
\item{}\Label{i:not-slow}{notslow}{\em\ref{i:not-slow}}
  xh should never cause an unresolvable performance problem that could be
  worked around by using a different language.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\item{}\Label{i:unreliable-connections}{unreliable}{\em\ref{i:unreliable-connections}}
  Connections between machines may die at any time, and remain down for
  arbitrarily long. xh must never become unresponsive when this happens,
  and any data coming from those machines should block until it is
  available again (i.e.~xh's behavior should be invariant with connection
  failures).
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\item \refboth{i:distributed-computation}
\end{itemize}
\item{}\Label{i:trivial-debugging}{nodebug}{\em\ref{i:trivial-debugging}}
  Debugging should require little or no effort; all error cases should be
  trivially obvious.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:distributed-computation}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\item{}\Label{i:trivial-database}{database}{\em\ref{i:trivial-database}}
  An xh instance should trivially function as a database; there should be
  no distinction between data in memory and data on disk.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:trivial-debugging}
\item \refboth{i:no-oome}
\item \refboth{i:not-slow}
\end{itemize}

\item{}\Label{i:universal-prediction}{prediction}{\em\ref{i:universal-prediction}}
  xh should use every keystroke to build/refine a model it uses to predict
  future keystrokes and commands.
(\refboth{i:ergonomic-limit})
\item{}\Label{i:forgetful-history}{history}{\em\ref{i:forgetful-history}}
  The likelihood that xh forgets anything from your command history should
  be inversely proportional to the amount of effort required to
  retype/recreate it.
\begin{itemize}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:universal-prediction}
\end{itemize}
\item{}\Label{i:locally-anonymous}{anonymous}{\em\ref{i:locally-anonymous}}
  xh must provide a way to accept input and execute commands without
  updating its prediction model.
(\refboth{i:security})
\item{}\Label{i:http-client}{pastebin}{\em\ref{i:http-client}}
  xh should be able to submit an encrypted version of its current state to
  HTTP services like Github gists or pastebin.
\begin{itemize}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:security}
\item \refboth{i:unreliable-connections}
\item \refboth{i:transparent-self-install}
\item \refboth{i:www-initialization}
\end{itemize}

\item{}\Label{i:feel-like-shell}{likeshell}{\em\ref{i:feel-like-shell}}
  xh-script needs to feel like a regular shell for most purposes.
(\refboth{i:shell})
\item{}\Label{i:imperative}{imperative}{\em\ref{i:imperative}}
  xh-script should be fundamentally imperative.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\item \refboth{i:feel-like-shell}
\end{itemize}
\item{}\Label{i:no-oome}{no-oome}{\em\ref{i:no-oome}}
  xh must never run out of memory or swap pages to disk, regardless of what
  you tell it to do.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\item \refboth{i:not-slow}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\item{}\Label{i:nonblocking}{nonblock}{\em\ref{i:nonblocking}}
  xh must respond to every keystroke within 20ms; therefore, SSH must be
  used only for nonblocking RPC requests (i.e.~the shell always runs
  locally).
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:not-slow}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\item{}\Label{i:remote-resources}{remotestuff}{\em\ref{i:remote-resources}}
  All resources, local and remote, must be uniformly accessible;
  i.e.~autocomplete, filename substitution, etc, must all just work (up to
  random access, which is impossible without FUSE or similar).
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:distributed-computation}
\item \refboth{i:ergonomic-limit}
\end{itemize}

\item{}\Label{i:prefix-notation}{prefix}{\em\ref{i:prefix-notation}}
  xh-script uses prefix notation.
(\refboth{i:shell})
\item{}\Label{i:quasiquoting}{quasiquote}{\em\ref{i:quasiquoting}}
  xh-script quasiquotes values by default.
(\refboth{i:shell})
\item{}\Label{i:unquoting}{unquote}{\em\ref{i:unquoting}}
  xh-script defines an unquote operator.
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:quasiquoting}
\end{itemize}

\item{}\Label{i:real-data-structures}{datastruct}{\em\ref{i:real-data-structures}}
  The xh runtime provides real, garbage-collected data structures.
(\refboth{i:real-programming})
\item{}\Label{i:data-structures-can-be-quoted}{quotestruct}{\em\ref{i:data-structures-can-be-quoted}}
  Every xh data structure has a quoted form.
\begin{itemize}
\item \refboth{i:real-data-structures}
\item \refboth{i:shell}
\item \refboth{i:trivial-debugging}
\item \refboth{i:live-preview}
\end{itemize}
\item{}\Label{i:data-structures-can-be-serialized}{printstruct}{\em\ref{i:data-structures-can-be-serialized}}
  Every xh data structure can be losslessly serialized.
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:distributed-computation}
\item \refboth{i:trivial-database}
\item \refboth{i:data-structures-can-be-quoted}
\item \refboth{i:settings-contain-variable-definitions}
\item \refboth{i:image-merging}
\end{itemize}
\item{}\Label{i:data-structures-are-immutable}{immutable}{\em\ref{i:data-structures-are-immutable}}
  Data structures have no identity and therefore are immutable.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:data-structures-can-be-serialized}
\end{itemize}

\item{}\Label{i:opaque-resources}{opaques}{\em\ref{i:opaque-resources}}
  xh-script must have access to machine-specific opaque resources like PIDs
  and file handles.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\end{itemize}
\item{}\Label{i:mutable-symbol-table}{mutablesyms}{\em\ref{i:mutable-symbol-table}}
  Each xh instance should implement a mutable symbol table with weak
  reference support, subject to semi-conservative distributed garbage
  collection.
\begin{itemize}
\item \refboth{i:data-structures-are-immutable}
\item \refboth{i:opaque-resources}
\item \refboth{i:no-oome}
\item \refboth{i:xh-heap}
\end{itemize}
\item{}\Label{i:state-ownership}{stateown}{\em\ref{i:state-ownership}}
  Every piece of mutable state, including symbol tables, must have at most
  one authoritative copy (mutable state within xh is managed by a CP
  system).
\begin{itemize}
\item \refboth{i:unreliable-connections}
\item \refboth{i:opaque-resources}
\item \refboth{i:mutable-symbol-table}
\item \refboth{i:thread-mobility}
\end{itemize}
\item{}\Label{i:checkpointing}{checkpoint}{\em\ref{i:checkpointing}}
  An xh instance should be able to save checkpoints of itself in case of
  failure. If you do this, xh becomes an AP system.
\begin{itemize}
\item \refboth{i:unreliable-connections}
\item \refboth{i:state-ownership}
\end{itemize}

\item{}\Label{i:lazy-evaluation}{lazy}{\em\ref{i:lazy-evaluation}}
  xh's evaluator must support some kind of laziness.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:no-oome}
\item \refboth{i:remote-resources}
\item \refboth{i:not-slow}
\end{itemize}
\item{}\Label{i:laziness-serializable}{printlazy}{\em\ref{i:laziness-serializable}}
  Lazy values must have well-defined quoted forms and be losslessly
  serializable.
\begin{itemize}
\item \refboth{i:data-structures-can-be-quoted}
\item \refboth{i:data-structures-can-be-serialized}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:thread-mobility}
\item \refboth{i:xh-heap}
\end{itemize}
\item{}\Label{i:lazy-introspection}{introspectlazy}{\em\ref{i:lazy-introspection}}
  All lazy values must be subject to introspection to identify why they
  haven't been realized.
\begin{itemize}
\item \refboth{i:trivial-debugging}
\item \refboth{i:not-slow}
\item \refboth{i:unreliable-connections}
\item \refboth{i:nonblocking}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:priority-scheduler}
\end{itemize}
\item{}\Label{i:abstract-evaluation}{abstract}{\em\ref{i:abstract-evaluation}}
  xh must be able to partially evaluate expressions that contain unknown
  quantities.
\begin{itemize}
\item \refboth{i:live-preview}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:lazy-introspection}
\item \refboth{i:laziness-serializable}
\end{itemize}
\item{}\Label{i:code-as-data}{code=data}{\em\ref{i:code-as-data}}
  xh-script code should be a reasonable data storage format.
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:abstract-evaluation}
\end{itemize}
\item{}\Label{i:parse-self}{selfparse}{\em\ref{i:parse-self}}
  xh-script must contain a library to parse itself.
(\refboth{i:code-as-data})
\item{}\Label{i:homoiconic}{homoiconic}{\em\ref{i:homoiconic}}
  xh-script must be homoiconic.
\begin{itemize}
\item \refboth{i:code-as-data}
\item \refboth{i:parse-self}
\item \refboth{i:self-hosting-runtime}
\item \refboth{i:representational-abstraction}
\end{itemize}

\item{}\Label{i:compile-to-c}{xh2c}{\em\ref{i:compile-to-c}}
  xh should be able to compile any function to C, compile it if the host
  has a C compiler, and transparently migrate execution into this process.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:thread-mobility}
\item \refboth{i:not-slow}
\end{itemize}
\item{}\Label{i:compile-to-perl}{xh2perl}{\em\ref{i:compile-to-perl}}
  xh should be able to compile any function to Perl rather than
  interpreting its execution.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:no-root-access}
\item \refboth{i:not-slow}
\end{itemize}
\item{}\Label{i:compile-to-js}{xh2js}{\em\ref{i:compile-to-js}}
  xh should be able to compile any function to Javascript so that browser
  sessions can transparently become computing nodes.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:distributed-computation}
\item \refboth{i:not-slow}
\end{itemize}
\item{}\Label{i:self-hosting-runtime}{selfhost}{\em\ref{i:self-hosting-runtime}}
  xh should follow a bootstrapped self-hosting runtime model.
\begin{itemize}
\item \refboth{i:compile-to-c}
\item \refboth{i:compile-to-perl}
\item \refboth{i:compile-to-js}
\item \refboth{i:representational-abstraction}
\end{itemize}
\item{}\Label{i:tracing-jit}{dynamiccompiler}{\em\ref{i:tracing-jit}}
  xh-script should be executed by a profiling/tracing dynamic compiler that
  automatically compiles certain pieces of code to alternative forms like
  Perl or C.
(\refboth{i:not-slow})
\item{}\Label{i:representational-abstraction}{abstractstruct}{\em\ref{i:representational-abstraction}}
  The xh compiler should optimize data structure representations for the
  backend being targeted.
\begin{itemize}
\item \refboth{i:not-slow}
\item \refboth{i:thread-mobility}
\item \refboth{i:tracing-jit}
\end{itemize}

\item{}\Label{i:xh-heap}{heap}{\em\ref{i:xh-heap}}
  xh needs to implement its own heap and memory manager, and swap values to
  disk without blocking.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:no-oome}
\item \refboth{i:trivial-database}
\item \refboth{i:written-in-perl}
\end{itemize}
\item{}\Label{i:xh-threading}{threading}{\em\ref{i:xh-threading}}
  xh should implement its own threading model to accommodate blocked IO
  requests.
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:distributed-computation}
\item \refboth{i:quick-webserver}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:xh-heap}
\end{itemize}
\item{}\Label{i:priority-scheduler}{threadscheduler}{\em\ref{i:priority-scheduler}}
  xh threads should be subject to scheduling that reflects the user's
  priorities.
\begin{itemize}
\item \refboth{i:shell}
\item \refboth{i:distributed-computation}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:xh-threading}
\end{itemize}
\item{}\Label{i:thread-mobility}{threadmobility}{\em\ref{i:thread-mobility}}
  Running threads must be transparently portable between machines and
  compiled backends.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:xh-threading}
\item \refboth{i:tracing-jit}
\item \refboth{i:representational-abstraction}
\item \refboth{i:priority-scheduler}
\end{itemize}
\item{}\Label{i:reference-locality}{refaffinity}{\em\ref{i:reference-locality}}
  All machine-specific references must encode the machine for which they
  are defined.
\begin{itemize}
\item \refboth{i:opaque-resources}
\item \refboth{i:thread-mobility}
\end{itemize}
\item{}\Label{i:unique-ids}{uniqueid}{\em\ref{i:unique-ids}}
  Every xh instance must have a unique ID, ideally one that can be typed
  easily.
\begin{itemize}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:reference-locality}
\end{itemize}

\item{}\Label{i:transparent-self-install}{selfinstall}{\em\ref{i:transparent-self-install}}
  xh needs to be able to self-install on remote machines with no
  intervention (assuming you have a passwordless SSH connection).
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:no-root-access}
\end{itemize}
\item{}\Label{i:www-initialization}{wwwinit}{\em\ref{i:www-initialization}}
  You should be able to upload your xh image to a website and then install
  it with a command like this:~\verb+curl me.com/xh | perl+.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:no-root-access}
\end{itemize}
\item{}\Label{i:self-modifying-image}{selfmodifying}{\em\ref{i:self-modifying-image}}
  Your settings should be present as soon as you download your image, so
  the image must be self-modifying and contain your settings.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:universal-prediction}
\item \refboth{i:transparent-self-install}
\item \refboth{i:www-initialization}
\end{itemize}
\item{}\Label{i:settings-contain-variable-definitions}{varsinrc}{\em\ref{i:settings-contain-variable-definitions}}
  Your settings should be able to contain any value you can create from the
  REPL (with the caveat that some are defined only with respect to a
  specific machine).
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:shell}
\item \refboth{i:ergonomic-limit}
\item \refboth{i:real-data-structures}
\item \refboth{i:www-initialization}
\end{itemize}
\item{}\Label{i:written-in-perl}{inperl}{\em\ref{i:written-in-perl}}
  xh should probably be written in Perl 5.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:no-root-access}
\item \refboth{i:transparent-self-install}
\item \refboth{i:www-initialization}
\item \refboth{i:self-modifying-image}
\end{itemize}
\item{}\Label{i:no-perl-modules}{perlcoreonly}{\em\ref{i:no-perl-modules}}
  xh can't have any dependencies on CPAN modules, or anything else that
  isn't in the core library.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:no-root-access}
\item \refboth{i:transparent-self-install}
\end{itemize}
\item{}\Label{i:image-merging}{imagemerging}{\em\ref{i:image-merging}}
  It should be possible to address variables defined within xh images (as
  files or network locations).
\begin{itemize}
\item \refboth{i:self-modifying-image}
\item \refboth{i:settings-contain-variable-definitions}
\end{itemize}

\item{}\Label{i:rpc-via-ssh}{sshrpc}{\em\ref{i:rpc-via-ssh}}
  xh's RPC protocol must work via stdin/out communication over an SSH
  channel to a remote instance of itself.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:security}
\item \refboth{i:transparent-self-install}
\item \refboth{i:nonblocking}
\item \refboth{i:remote-resources}
\end{itemize}
\item{}\Label{i:rpc-multiplexing}{rpcmulti}{\em\ref{i:rpc-multiplexing}}
  xh's RPC protocol must support request multiplexing.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:not-slow}
\item \refboth{i:nonblocking}
\item \refboth{i:remote-resources}
\item \refboth{i:lazy-evaluation}
\item \refboth{i:rpc-via-ssh}
\end{itemize}
\item{}\Label{i:xh-self-connection}{hostswitch}{\em\ref{i:xh-self-connection}}
  Two xh servers on the same host should automatically connect to each
  other. This allows a server-only machine to act as a VPN.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:no-root-access}
\item \refboth{i:rpc-via-ssh}
\item \refboth{i:transitive-topology}
\end{itemize}
\item{}\Label{i:domain-sockets}{domainsockets}{\em\ref{i:domain-sockets}}
  xh should create a UNIX domain socket to listen for other same-machine
  instances.
\begin{itemize}
\item \refboth{i:security}
\item \refboth{i:xh-self-connection}
\end{itemize}
\item{}\Label{i:transitive-topology}{transitive}{\em\ref{i:transitive-topology}}
  xh's network topology should forward requests transitively.
\begin{itemize}
\item \refboth{i:distributed-computation}
\item \refboth{i:no-root-access}
\item \refboth{i:rpc-via-ssh}
\end{itemize}
\item{}\Label{i:network-routing}{routing}{\em\ref{i:network-routing}}
  xh should implement a network optimizer that responds to observations it
  makes about latency and throughput.
\begin{itemize}
\item \refboth{i:not-slow}
\item \refboth{i:rpc-via-ssh}
\item \refboth{i:transitive-topology}
\end{itemize}
\end{enumerate}

\chapter{xh-script}\label{chp:design-xh-script}
  These constraints are based on the ones in
  \Ref{chapter}{chp:design-constraints}.

\begin{enumerate}
\item{}\Label{is:evaluation-identities}{xhs.eval-identities}{\em\ref{is:evaluation-identities}}
  Evaluation of any expression may happen at any time; the only scheduling
  constraint is the realization of lazy expressions, whose status is
  visible by looking at their quoted forms. Therefore, the evaluator is, to
  some degree, associative, commutative, and idempotent.
\begin{itemize}
\item \initial
\item \refboth{i:distributed-computation} above
\item \refboth{i:trivial-debugging} above
\item \refboth{i:live-preview} above
\item \refboth{i:nonblocking} above
\item \refboth{i:lazy-evaluation} above
\item \refboth{i:lazy-introspection} above
\item \refboth{i:abstract-evaluation} above
\end{itemize}

\item{}\Label{is:relational-evaluation}{xhs.relational}{\em\ref{is:relational-evaluation}}
  Relational evaluation is possible by using {\tt amb}, which returns any
  of the given presumably-equivalent values. xh-script is relational and
  invertible, though inversion is not always lossless and may produce
  perpetually-unresolved unknowns representing degrees of freedom.
\begin{itemize}
\item \initial
\item \refboth{i:trivial-debugging} above
\item \refboth{i:lazy-evaluation} above
\item \refboth{i:lazy-introspection} above
\item \refboth{i:abstract-evaluation} above
\item \refboth{i:self-hosting-runtime} above
\item \refboth{i:representational-abstraction} above
\item \refboth{i:priority-scheduler} above
\item \refboth{is:evaluation-identities}
\end{itemize}
\item{}\Label{is:best-first-search}{xhs.bestfirst}{\em\ref{is:best-first-search}}
  Due to functions like {\tt amb}, evaluation proceeds as a best-first
  search through the space of values. You can influence this search by
  defining the {\tt abstraction} relation for a particular class of
  expressions.
\begin{itemize}
\item \refboth{i:not-slow} above
\item \refboth{is:relational-evaluation}
\end{itemize}
\item{}\Label{is:no-cut-operator}{xhs.nocut}{\em\ref{is:no-cut-operator}}
  Unlike Prolog, xh defines no cut primitive. You should use {\tt
  abstraction} to locally grade the search space instead.
\begin{itemize}
\item \refboth{i:trivial-debugging} above
\item \refboth{is:evaluation-identities}
\item \refboth{is:best-first-search}
\end{itemize}

\item{}\Label{is:unquote-structure-preserving}{xhs.unquote-structure}{\em\ref{is:unquote-structure-preserving}}
  Unquoting is structure-preserving with respect to parsing; that is, it
  will never force a reparse if its argument has already been parsed.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming} above
\item \refboth{i:unquoting} above
\item \refboth{i:not-slow} above
\item \refboth{i:abstract-evaluation} above
\end{itemize}
\item{}\Label{is:stack-local-scoping}{xhs.stackscope}{\em\ref{is:stack-local-scoping}}
  All scoping is done by passing a second argument to {\tt unquote}; this
  enables variable resolution during the unquoting operation.
\begin{itemize}
\item \initial
\item \refboth{i:unquoting} above
\item \refboth{i:mutable-symbol-table} above
\item \refboth{is:evaluation-identities}
\end{itemize}
\item{}\Label{is:no-variable-shadowing}{xhs.noshadow}{\em\ref{is:no-variable-shadowing}}
  Variable shadowing is impossible.
\begin{itemize}
\item \refboth{is:evaluation-identities}
\item \refboth{is:stack-local-scoping}
\end{itemize}
\item{}\Label{is:unquoting-vs-parsing}{xhs.unquote-parse}{\em\ref{is:unquoting-vs-parsing}}
  Unquoting and structural parsing are orthogonal operations provided by
  {\tt unquote} and {\tt read}, respectively.
\begin{itemize}
\item \refboth{i:data-structures-can-be-quoted} above
\item \refboth{i:lazy-introspection} above
\item \refboth{is:evaluation-identities}
\item \refboth{is:unquote-structure-preserving}
\end{itemize}

\item{}\Label{is:runtime-as-receiver}{xhs.runtimereceiver}{\em\ref{is:runtime-as-receiver}}
  Whether via RPC or locally, statements issued to an xh runtime can be
  interpreted as messages being sent to a receiver; the reply is sent along
  whatever continuation is specified. The runtime doesn't differentiate
  between local and remote requests, including those made by functions.
\begin{itemize}
\item \refboth{i:imperative} above
\item \refboth{i:xh-threading} above
\item \refboth{i:thread-mobility} above
\item \refboth{i:state-ownership} above
\end{itemize}
\item{}\Label{is:function-variable-namespaces}{xhs.namespaces}{\em\ref{is:function-variable-namespaces}}
  Functions and variables exist in separate namespaces.
\begin{itemize}
\item \refboth{i:feel-like-shell} above
\item \refboth{i:unquoting} above
\item \refboth{is:stack-local-scoping}
\item \refboth{is:runtime-as-receiver}
\end{itemize}
\item{}\Label{is:function-literals-as-messages}{xhs.fnliterals}{\em\ref{is:function-literals-as-messages}}
  Function literals are self-invoking when used as messages.
(\refboth{is:function-variable-namespaces})
\item{}\Label{is:no-real-continuations}{nocallcc}{\em\ref{is:no-real-continuations}}
  Continuations are simulated in terms of lazy evaluation, but are never
  first-class.
\begin{itemize}
\item \refboth{i:tracing-jit} above
\item \refboth{i:lazy-introspection} above
\item \refboth{i:abstract-evaluation} above
\item \refboth{is:runtime-as-receiver}
\end{itemize}
\item{}\Label{is:transient-definitions}{xhs.transientdefs}{\em\ref{is:transient-definitions}}
  Some definitions are ``transient,'' in which case they are used to
  resolve blocked lazy values but then may be discarded at any point.
\begin{itemize}
\item \refboth{i:distributed-computation} above
\item \refboth{i:no-oome} above
\item \refboth{i:lazy-evaluation} above
\item \refboth{is:runtime-as-receiver}
\end{itemize}
\item{}\Label{is:global-definition-universality}{xhs.globaldefs}{\em\ref{is:global-definition-universality}}
  Global definitions can apply to values at any time, and to values on
  different machines (i.e.~their existence is broadcast).
\begin{itemize}
\item \refboth{i:lazy-evaluation} above
\item \refboth{is:transient-definitions}
\end{itemize}

\item{}\Label{is:macros-cannot-exist}{xhs.nomacros}{\em\ref{is:macros-cannot-exist}}
  Syntactic macros cannot exist because invocation commutes with expansion,
  but functions may operate on terms whose values are undefined.
\begin{itemize}
\item \refboth{is:evaluation-identities}
\item \refboth{is:unquote-structure-preserving}
\end{itemize}
\item{}\Label{is:errors-cannot-exist}{xhs.noerrors}{\em\ref{is:errors-cannot-exist}}
  Errors cannot exist, but are represented by lazy values that contain
  undefined quantities that will never be realized. These undefined
  quantities are the unevaluated backtraces to the error-causing
  subexpressions.
\begin{itemize}
\item \refboth{i:trivial-debugging} above
\item \refboth{i:lazy-evaluation} above
\item \refboth{i:abstract-evaluation} above
\item \refboth{is:evaluation-identities}
\end{itemize}

\item{}\Label{is:arbitrary-destructuring}{xhs.destructuring}{\em\ref{is:arbitrary-destructuring}}
  Any value can be used as a destructuring bind pattern.
\begin{itemize}
\item \initial
\item \refboth{is:relational-evaluation}
\end{itemize}
\item{}\Label{is:amb-desctructuring}{xhs.ambdestructure}{\em\ref{is:amb-desctructuring}}
  \verb|(amb)| can be used to destructure values, and it behaves as a
  disjunction.
\begin{itemize}
\item \initial
\item \refboth{is:relational-evaluation}
\item \refboth{is:arbitrary-destructuring}
\end{itemize}
\item{}\Label{is:abstract-dof}{xhs.dof}{\em\ref{is:abstract-dof}}
  Degrees of freedom within an inversion are represented by abstract values
  that will prevent the result from being realized. They are visible as
  unknowns within the quoted form.
\begin{itemize}
\item \initial
\item \refboth{is:relational-evaluation}
\end{itemize}

\item{}\Label{is:side-effects-as-axioms}{xhs.se-axioms}{\em\ref{is:side-effects-as-axioms}}
  Side effects and axioms are the same thing in xh. Once it commits to a
  side-effect, it must always assume that it happened (since it did). In
  particular, this means that imperative forms like {\tt (def)} are
  actually ways to assume new ground truths.
\begin{itemize}
\item \initial
\item \refboth{i:imperative}
\item \refboth{is:relational-evaluation}
\item \refboth{is:global-definition-universality}
\end{itemize}
\item{}\Label{is:hypotheses-are-virtualization}{xhs.virtualization}{\em\ref{is:hypotheses-are-virtualization}}
  Every side effect can be replaced by a temporary assumption that models
  the effect. If you do this, you're replacing an axiom with a hypothesis.
\begin{itemize}
\item \initial
\item \refboth{is:side-effects-as-axioms}
\end{itemize}
\end{enumerate}

\chapter{xh-script syntax}\label{chp:xhs-syntax}
  Design constraints for the syntax in particular.

\begin{enumerate}
\item{}\Label{isyn:reversible-parsing}{syn.reversibleparsing}{\em\ref{isyn:reversible-parsing}}
  The parser for xh is losslessly reversible:~comment data, whitespace, and
  any other aspect of valid xh code is encoded in the parsed
  representation.
(\initial)
\item{}\Label{isyn:tags}{syn.tags}{\em\ref{isyn:tags}}
  Lists, vectors, and maps can each be tagged by immediately prefixing the
  opening brace with a word.
(\initial)
\item{}\Label{isyn:splicing}{syn.splice}{\em\ref{isyn:splicing}}
  A quoted form prefixed with \verb|@| causes list splicing to occur, just
  like Common Lisp's \verb|,@| and Clojure's \verb|~@|. Technically
  \verb|@| is a distributive, right-associative prefix expansion operator
  (sort of like \verb|$| in some ways), so you can layer it to expand
  multiple layers of lists. Any non-lists are treated as lists of a single
  item; \verb|@| will never block evaluation.
\begin{itemize}
\item \initial
\item \refboth{i:real-programming}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\item{}\Label{isyn:escaping}{syn.escaping}{\em\ref{isyn:escaping}}
  Any character can be prefixed with {\tt \textbackslash} to cause it to be
  interpreted as a string. The only exception is that some escape sequences
  are interpreted, including \verb|\n|, \verb|\t|, and similar.
\begin{itemize}
\item \initial
\item \refboth{i:feel-like-shell}
\end{itemize}

\item{}\Label{isyn:hash-comments}{syn.hashcomments}{\em\ref{isyn:hash-comments}}
  Comments begin with \verb|#| preceded either by whitespace or the
  beginning of a line. Unlike in many languages, comment data is available
  in the parsed representation of xh source code.
\begin{itemize}
\item \refboth{i:feel-like-shell}
\item \refboth{isyn:reversible-parsing}
\end{itemize}
\item{}\Label{isyn:string-quoting}{syn.stringquoting}{\em\ref{isyn:string-quoting}}
  Single-quoted and double-quoted strings have exactly the semantics they
  do in Perl or bash; that is, single-quoted strings are oblivious to most
  unquoting features, whereas double-quoted strings are interpolated.
(\refboth{i:feel-like-shell})
\item{}\Label{isyn:expression-interpolation}{syn.stringexpressions}{\em\ref{isyn:expression-interpolation}}
  Within a double-quoted string, you need to prefix any interpolating
  \verb|()| group with a \verb|$| to make it active.
\begin{itemize}
\item \refboth{i:trivial-debugging}
\item \refboth{i:feel-like-shell}
\end{itemize}
\item{}\Label{isyn:toplevel-expressions}{syn.toplevelexpressions}{\em\ref{isyn:toplevel-expressions}}
  Outside words and quoted strings, \verb|()| does not require a \verb|$|
  prefix to interpolate. Put differently, the \verb|$| is required if and
  only if you are interpolating by same-word string concatenation.
\begin{itemize}
\item \refboth{i:real-programming}
\item \refboth{i:ergonomic-limit}
\end{itemize}

\item{}\Label{isyn:flat-toplevel-lists}{syn.flattoplevel}{\em\ref{isyn:flat-toplevel-lists}}
  xh's toplevel grammar is based on Tcl, not Lisp; this means that you
  don't need to wrap each statement in parentheses. Line breaks are
  significant unless preceded with {\tt \textbackslash} or inside a list.
  Unlike bash and tcl, all sub-lists are parsed as in Lisp; that is, this
  toplevel syntax applies only at the outermost level.
\begin{itemize}
\item \initial
\item \refboth{i:feel-like-shell}
\item \refboth{i:ergonomic-limit}
\end{itemize}
\end{enumerate}

\chapter{runtime}\label{chp:runtime}
  xh-script operates within a hosting environment that manages things like
  memory allocation and thread/evaluation scheduling. Beyond this, we also need
  a quoted-value format that's more efficient than doing a bunch of string
  manipulation (\refboth{ir:expression-representation},
  \refboth{ir:flat-containers}, \refboth{ir:deduplication}).

\begin{enumerate}
\item{}\Label{ir:priority-queue}{xhr.priorityqueue}{\em\ref{ir:priority-queue}}
  Evaluation always happens as a process of pulling expressions from a
  priority queue.
\begin{itemize}
\item \initial
\item \refboth{is:relational-evaluation}
\item \refboth{is:best-first-search}
\end{itemize}
\item{}\Label{ir:priority-tracing}{xhr.prioritytracing}{\em\ref{ir:priority-tracing}}
  Every expression in the queue knows its ``origin'' for scheduling
  purposes.
\begin{itemize}
\item \refboth{is:best-first-search}
\item \refboth{ir:priority-queue}
\end{itemize}

\item{}\Label{ir:static-inlining}{xhr.staticinline}{\em\ref{ir:static-inlining}}
  Function compositions should be added as derived definitions to minimize
  the number of symbol-table lookups per unit rewriting distance.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{is:relational-evaluation}
\end{itemize}
\item{}\Label{ir:latency}{xhr.latency}{\em\ref{ir:latency}}
  The runtime should provide low enough latency that it can be used as the
  graph-solving backend for RPC routing.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{i:network-routing}
\end{itemize}
\item{}\Label{ir:value-caching}{xhr.valuecache}{\em\ref{ir:value-caching}}
  To guarantee low latency, the runtime should emit transient values for
  solutions it finds. These become cached bindings that can be kicked out
  under memory pressure, but reduce the load on the optimizer.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{ir:latency}
\end{itemize}

\item{}\Label{ir:expression-representation}{xhr.representation}{\em\ref{ir:expression-representation}}
  Every quasiquoted form with variant pieces should be represented as a
  separate instantiable class.
\begin{itemize}
\item \initial
\item \refboth{i:quasiquoting}
\item \refboth{i:not-slow}
\item \refboth{is:evaluation-identities}
\end{itemize}
\item{}\Label{ir:flat-containers}{xhr.flatcontainers}{\em\ref{ir:flat-containers}}
  Quasiquoted structures are profiled for the distributions of their
  children (upon expansion); for strongly nonuniform distributions,
  specialized flattened container types are generated.
\begin{itemize}
\item \initial
\item \refboth{i:quasiquoting}
\item \refboth{i:not-slow}
\item \refboth{is:evaluation-identities}
\item \refboth{ir:static-inlining}
\item \refboth{ir:expression-representation}
\end{itemize}
\item{}\Label{ir:flat-container-limit}{xhr.flatlimit}{\em\ref{ir:flat-container-limit}}
  Containers should be flattened until the type-encoding overhead is
  minimized for the given (possibly-contextful) distribution of values. In
  practice, this probably means using PPM and Huffman coding with an
  initial noise floor to prevent short-run overfitting.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{ir:flat-containers}
\end{itemize}
\item{}\Label{ir:deduplication}{xhr.deduplication}{\em\ref{ir:deduplication}}
  Every independent value within a quasiquoted form should be referred to
  by a structural signature, in our case SHA-256. This trivially causes
  strings, and by extension execution paths, to be deduplicated. Because we
  assume no hash collisions, xh string values have no defined instance
  affinity (apropos of \refboth{i:reference-locality}).
\begin{itemize}
\item \refboth{i:xh-heap}
\item \refboth{ir:static-inlining}
\item \refboth{ir:expression-representation}
\item \refboth{ir:hinting}
\end{itemize}
\item{}\Label{ir:pointer-entropy}{xhr.pointerentropy}{\em\ref{ir:pointer-entropy}}
  256 bits is sufficient to encode any pointer.
\begin{itemize}
\item \initial
\item \refboth{i:unique-ids}
\item \refboth{i:reference-locality}
\item \refboth{ir:deduplication}
\end{itemize}

\item{}\Label{ir:hinting}{xhr.hinting}{\em\ref{ir:hinting}}
  Expressions should be hinted with tags that track and influence their
  paths through the search space. The optimizer uses machine learning
  against these tags to predict successful search strategies.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{is:best-first-search}
\item \refboth{is:no-cut-operator}
\end{itemize}
\item{}\Label{ir:hashing}{xhr.hashing}{\em\ref{ir:hashing}}
  The runtime should use some type of masked hashing strategy (or other
  decision tree) to minimize the expected resolution time for each
  expression.
\begin{itemize}
\item \initial
\item \refboth{ir:hinting}
\end{itemize}
\item{}\Label{ir:transient-prediction}{xhr.transientprediction}{\em\ref{ir:transient-prediction}}
  Many functions will end up returning lazy values, and most of the time
  those lazy values will eventually be realized. The runtime should have
  some expectation of which lazy sub-values will be realized, and with what
  probability; this influences its search strategy in the future.
\begin{itemize}
\item \initial
\item \refboth{i:not-slow}
\item \refboth{is:transient-definitions}
\item \refboth{is:best-first-search}
\item \refboth{ir:hinting}
\end{itemize}

\item{}\Label{ir:override}{xhr.override}{\em\ref{ir:override}}
  The user must be able to completely override any strategy preferences the
  runtime has. The runtime can be arbitrarily wrong and the user can be
  arbitrarily right.
\begin{itemize}
\item \initial
\item \refboth{is:best-first-search}
\item \refboth{ir:hinting}
\item \refboth{ir:transient-prediction}
\end{itemize}
\item{}\Label{ir:external-strategy}{xhr.externalstrategy}{\em\ref{ir:external-strategy}}
  The xh runtime does not itself define the evaluation strategy, nor does
  it internally observe things; this is done as part of the evaluation
  functions in the standard library. The only thing the xh runtime provides
  is a scheduled/prioritized event loop.
\begin{itemize}
\item \initial
\item \refboth{i:abstract-evaluation}
\item \refboth{i:code-as-data}
\item \refboth{ir:override}
\end{itemize}
\item{}\Label{ir:evaluator-api}{xhr.evaluatorapi}{\em\ref{ir:evaluator-api}}
  Evaluator functions are straightforward to write, and the standard
  library includes several designed for different use cases (e.g.~local,
  distributed, profiling). Any significantly nontrivial aspect of it is
  factored off into an API.
\begin{itemize}
\item \initial
\item \refboth{ir:override}
\item \refboth{ir:external-strategy}
\end{itemize}
\item{}\Label{ir:evaluator-base}{xhr.evaluatorbase}{\em\ref{ir:evaluator-base}}
  The runtime is itself subject to evaluation (since it's self-hosting),
  and the base evaluator is implemented in Perl, C, or Javascript. This
  base evaluator runs locally; the distributed evaluator runs on top of it.
\begin{itemize}
\item \initial
\item \refboth{i:compile-to-perl}
\item \refboth{i:compile-to-c}
\item \refboth{i:compile-to-js}
\item \refboth{i:written-in-perl}
\item \refboth{i:self-hosting-runtime}
\item \refboth{ir:override}
\item \refboth{ir:evaluator-api}
\end{itemize}

\item{}\Label{ir:cryptographic-limit}{xhr.cryptographic}{\em\ref{ir:cryptographic-limit}}
  Any function can be modeled as a cipher and subject to forms of
  cryptanalysis to discover structure. The worst case is a truly random
  mapping that requires each permutation to be evaluated independently.
  (This is relevant for code synthesis, which is an inversion of the
  evaluator.)
\begin{itemize}
\item \initial
\item \refboth{is:relational-evaluation}
\end{itemize}
\item{}\Label{ir:uniformity-reduction}{xhr.uniformityreduction}{\em\ref{ir:uniformity-reduction}}
  Entropy can be reduced by biasing otherwise uniform distributions of
  \verb|(amb)| alternatives, possibly by looking at context. This can be
  done using real-world data, if any exists.
(\refboth{ir:cryptographic-limit})
\item{}\Label{ir:separability}{xhr.separability}{\em\ref{ir:separability}}
  Entropy can be reduced by identifying input separability or other such
  structure. This is done through cryptanalysis.
(\refboth{ir:cryptographic-limit})
\end{enumerate}

\part{base implementation}\label{part:base-implementation}
\chapter{self-replication}\label{chp:self-replication}
\lstset{caption={boot/xh-header},name={boot/xh-header}}\begin{perlcode}
#!/usr/bin/env perl
#<body style='display:none'><script id='self' type='xh'>
BEGIN {eval(our $xh_bootstrap = q{
# xh | https://github.com/spencertipping/xh
# Copyright (C) 2014, Spencer Tipping
# Licensed under the terms of the MIT source code license
use 5.014;
package xh;
our %modules;
our @module_ordering;
our %eval_numbers = (1 => '$xh_bootstrap');

sub with_eval_rewriting(&) {
  my @result = eval {$_[0]->(@_[1..$#_])};
  die $@ =~ s/\(eval (\d+)\)/$eval_numbers{$1}/egr if $@;
  @result;
}

sub named_eval {
  my ($name, $code) = @_;
  $eval_numbers{$1 + 1} = $name if eval('__FILE__') =~ /\(eval (\d+)\)/;
  with_eval_rewriting {eval $code; die $@ if $@};
}

our %compilers = (
  pl => sub {
    my $package = $_[0] =~ s/\./::/gr;
    eval {named_eval $_[0], "{package ::$package;\n$_[1]\n}"};
    die "error compiling module $_[0]: $@" if $@;
  },
  html => sub {});

sub defmodule {
  my ($name, $code, @args) = @_;
  chomp($modules{$name} = $code);
  push @module_ordering, $name;
  my ($base, $extension) = split /\.(\w+$)/, $name;
  die "undefined module extension '$extension' for $name"
    unless exists $compilers{$extension};
  $compilers{$extension}->($base, $code, @args);
}

chomp($modules{bootstrap} = $::xh_bootstrap);
undef $::xh_bootstrap; \end{perlcode}

  At this point we need a way to reproduce the image. Since the bootstrap code
  is already stored, we can just wrap it and each defined module into an
  appropriate \verb|BEGIN| block.

\lstset{caption={boot/xh-header (continued)},name={boot/xh-header}}\begin{perlcode}
sub image {
  join "\n", "#!/usr/bin/env perl",
             "#<body style='display:none'><script type='xh'>",
             "BEGIN {eval(our \$xh_bootstrap = <<'_')}",
             $modules{bootstrap},
             '_',
             map("BEGIN {xh::defmodule('$_', <<'_')}\n$modules{$_}\n_",
                 grep !/\.html$/, @module_ordering),
             "#</" . "script>",
             map("BEGIN {xh::defmodule('$_', <<'_')}\n$modules{$_}\n_",
                 grep /\.html$/, @module_ordering),
             "xh::main::main;\n__DATA__";
}
})} \end{perlcode}

  Here's a quick test implementation of \verb|xh::main::main|; its purpose is
  to make sure replication works. This won't be present in real images:

\lstset{caption={src/test/main.pl},name={src/test/main.pl}}\begin{perlcode}
BEGIN {xh::defmodule('xh::main.pl', <<'_')}
sub main {
  print ::xh::image;
}
_ \end{perlcode}

\chapter{html introspection}\label{chp:base-html-introspection}
  xh images can be opened as self-inspecting HTML files.

\lstset{caption={src/introspect/dependencies.html},name={src/introspect/dependencies.html}}\begin{javascriptcode}
BEGIN {xh::defmodule('js-dependencies.html', <<'_')}
<script src='http://code.jquery.com/jquery.min.js'></script>
<script src='http://caterwauljs.org/build/caterwaul.min.js'></script>
<script src='http://caterwauljs.org/build/caterwaul.std.min.js'></script>
<script src='http://caterwauljs.org/build/caterwaul.ui.min.js'></script>
_
 \end{javascriptcode}

\lstset{caption={src/introspect/css.html},name={src/introspect/css.html}}\begin{javascriptcode}
BEGIN {xh::defmodule('css.html', <<'_')}
<style>
@import url(http://fonts.googleapis.com/css?family=Abel|Fira+Mono);
body {background:   #080808;
      color:        #eae8e4;
      margin:       auto;
      max-width:    700px;
      overflow-y:   scroll;
      padding-left: 14px;
      border-left:  solid 1px #383736}

h1 {font-family: 'Abel', monospace;
    font-weight: normal;
    font-size:   20px}

h1:hover {color: #878177}
h1 .suffix {color: #878177}
h1 .suffix:before {content: '.'; color: #878177}

pre {font-family: 'Fira Mono', monospace;
      font-size:  10px}

#dom   {margin: 20px 0}
.title {color:       #f85421;
        font-family: 'Abel', sans-serif}
</style>
_
 \end{javascriptcode}

\lstset{caption={src/introspect/dom.html},name={src/introspect/dom.html}}\begin{javascriptcode}
BEGIN {xh::defmodule('dom.html', <<'_')}
<div id='dom'>
<span class='title'>xh</span>
</div>
_
 \end{javascriptcode}

\lstset{caption={src/introspect/js.html},name={src/introspect/js.html}}\begin{javascriptcode}
BEGIN {xh::defmodule('introspection.html', <<'_')}
<script>
//BEGIN {xh::defmodule('introspection.js', <<'_')}
$(caterwaul(':all')(function () {
  $('body').empty() /~prepend/ jquery[head /append(css)]
                    /~append/  dom
                    /~append/  ui_for(parsed_modules)
                    /~css/     {display: 'block'},
  where [
  css               = $('style'),
  dom               = $('#dom'),
  self              = +$('script') *[$(x).html()] /seq /~join/ '\n',
  parse_modules(ls) = xs -se [ls *!process_line -seq]
-where [xs              = {__ordering: []},
    name            = null,
    text            = '',
    process_line(s) = /^(?:\/\*)?BEGIN.*defmodule\('([^']+)',.*\)/.exec(s)
            -re [it ? name /eq[it[1]] -then- text /eq['']
                    : /^(?:\/\*)?_$/.test(s)
                      ? name -ocq- 'bootstrap.pl'
                        -then- xs[name] /eq [text /~substr/ 1]
                        -then- xs.__ordering /~push/ name
                    : text += '\n#{s}']],

  parsed_modules    = self.split(/\n/) /!parse_modules,
  ui_for(modules)   = ui -se [sections *![ui /~append/ x] -seq]
-where [ui             = jquery in div,
    toggle()       = $(this).next().toggle(),
    module_name(x) = jquery [span.prefix /text(pieces[0])
                           + span.suffix /text(pieces[1])]
                     -where [pieces = x.split(/\./, 2)],
    sections       = modules.__ordering
                     *[jquery in h1 /append(x /!module_name)
                                    /css({cursor: 'pointer'})
                                    /click(toggle)
                               + pre /text(modules[x])
                                     /hide()] -seq]]}));
//_
</script>
_
 \end{javascriptcode}

\chapter{parser}\label{chp:base-parser}
\lstset{caption={src/baseparser.pl},name={src/baseparser.pl}}\begin{perlcode}
BEGIN {xh::defmodule('xh::baseparser.pl', <<'_')}
# TODO
_ \end{perlcode}

\chapter{evaluator}\label{chp:base-evaluator}
\lstset{caption={src/baseevaluator.pl},name={src/baseevaluator.pl}}\begin{perlcode}
BEGIN {xh::defmodule('xh::baseevaluator.pl', <<'_')}
# TODO
_ \end{perlcode}

\part{self-hosting implementation}\label{part:self-hosting-implementation}
\chapter{computational abstraction}\label{chp:computational-abstraction}
\begin{enumerate}
\item{}\Label{ica:structured-programming}{ca.structured}{\em\ref{ica:structured-programming}}
  All compilation is run through a structured programming layer that has
  abstractions for numeric operations and basic control flow. Shortcuts for
  higher-level operations are provided to leverage platform-specific
  optimized libraries.
\begin{itemize}
\item \initial
\item \refboth{i:compile-to-c}
\item \refboth{i:compile-to-perl}
\item \refboth{i:compile-to-js}
\end{itemize}

\item{}\Label{ica:variable-width-integers}{ca.varwidthint}{\em\ref{ica:variable-width-integers}}
  Integer operations have signed and unsigned variants, and exist at any
  bit width. xh doesn't restrict to 32/64 bits (or other common values)
  because not all backends, e.g.~Perl, support all bit widths.
\begin{itemize}
\item \initial
\item \refboth{i:written-in-perl}
\end{itemize}
\end{enumerate}

\end{document}
