BEGIN {xh::defmodule('xh::coreboot.xh', <<'_')}
(def destructuring-bind1
  (fn* outer        # outer = [template value bindings]
    (if (== literal (realtype (get $outer 0)))
      (assoc (get $outer 2) (get $outer 0) (get $outer 1))
      (if (if (== array (realtype (get $outer 0)))
            y
            (== hash (realtype (get $outer 0))))
        (reduce (fn* k
                  (delay [$k] destructuring-bind1
                              (get (get $outer 0) (get $k 1))
                              (get (get $outer 1) (get $k 1))
                              (get $k 0)))
                (get $outer 2)
                (keys (get $outer 0)))
        (get $outer 2)))))

(def fn1
  (fn* args
    (fn* (get $args 0)
      (scope (destructuring-bind1 (get $args 1)
                                  (var (get $args 0))
                                  {})
        (get $args 2)))))

(def fn
  (fn1 fn~ [formals body]
    ((fn1 gs~ [gs]
       (fn* $gs
         (scope (delay [$gs]
                 delay [$gs]
                 destructuring-bind1 $formals (var $gs) {})
           $body)))
     (str : (delay [$formals $body]
             delay [$formals $body]
             hashcode [$formals $body])))))

(def defn
  (fn [name formals body]
    (def $name (fn $formals $body))))

(defn and2 [x y] (if $x $y ''))
(defn or2  [x y] (if $x $x $y))
(defn not  [x]   (if $x '' y))
(defn xor2 [x y] (and2 (or2 $x $y) (not (and2 $x $y))))

(defn map1     [f xs] (flatmap1 (fn [x] [($f $x)]) $xs))
(defn filter1  [f xs] (flatmap1 (fn [x] (if (f $x) [$x] [])) $xs))
(defn flatmap1 [f xs] (reduce (fn [ys x] (into $ys ($f $x)))
                              (empty $xs)
                              $xs))

(defn reverse [xs] (reduce (fn [ys x] (into [$x] $ys))
                           []
                           $xs))

(defn partial fs (let1 [f] $fs (fn xs (apply $f (into (slice $fs 1) $xs)))))
(defn comp    fs (fn xs (get (reduce (fn [x f] [(apply $f $x)])
                                     $xs
                                     (reverse $fs))
                             0)))

(defn inc [x] (i+ $x 1))
(defn dec [x] (i- $x 1))
(defn let1 [k v body] ((delay [$k] fn [$k] $body) $v))

(defn .. args
  (let1 [x] $args
    (delay [$x]
     delay [$x]
     apply list delay [$x] (slice $args 1))))

(defn let [kvs body]
  (reduce (fn [code [k v]] (.. $k let1 $k $v $code))
          $body
          (map1 (fn [i] [(get $kvs $i) (get $kvs (inc $i))])
                (reverse (map1 (partial i* 2)
                               (iota (i>> (count $kvs) 1)))))))

(defn cond clauses
  (reduce (fn [code i]
            (let [[c v] (map1 (partial get $clauses) [$i (inc $i)])]
              (if $c $v $code)))
          ''
          (reverse (map1 (partial i* 2)
                         (iota (i>> (count $clauses) 1))))))

# Better definition of destructuring-bind; this one supports things like
# aliasing and array slicing. Unfortunately, the corescript interpreter is
# too slow to handle this definition gracefully.
(defn* destructuring-bind
  [template value bs]
  (let [t      (realtype $template)
        this   (get @ 0)
        after  (get & 0)
        before (get < 0)]
    (cond (== literal $t) (assoc $bs $template $value)
          (== array $t)
          (reduce (fn [bs' i]
                    (let [t' (get $template $i)
                          c  (if (== literal (realtype $t'))
                               (get $t' 0)
                               '')]
                      (.. $i destructuring-bind
                             (if (or2 (or2 (== $c $after) (== $c $this))
                                      (== $c $before))
                               (slice $t' 1)
                               $t')
                             (cond (== $c $after)  (slice $value $i)
                                   (== $c $before) (slice $value 0 $i)
                                   (== $c $this)   $value
                                   else            (get $value $i))
                             $bs')))
                  $bs
                  (keys $template))

          (== hash $t)
          (reduce (fn [bs' k]
                    (let [t' (get $template $k)
                          c  (if (== literal (realtype $t'))
                               (get $t' 0)
                               '')]
                      (.. $k destructuring-bind
                             (if (== $c $this) (slice $t' 1) $t')
                             (if (== $c $this) $value (get $value $k))
                             $bs')))
                  $bs
                  (keys $template)))))
_
