#!/usr/bin/perl
# 99aeabc9ec7fe80b1b39f5e53dc7e49e      <- self-modifying Perl magic
# state:  Dj0xbVvDUYMZeMBaeHN0P9aiD41rgck37GBQHK23V/4
# istate: Wa+9XWzEZH/Lz8n3UBmBMMBPcfSzoXogxtZ0W6mRwug
# id:     d8b3d476069348db3de1c9f0407d9c1e

# This is a self-modifying Perl file. I'm sorry you're viewing the source (it's
# really gnarly). If you're curious what it's made of, I recommend reading
# http://github.com/spencertipping/writing-self-modifying-perl.
#
# If you got one of these from someone and don't know what to do with it, send
# it to spencer@spencertipping.com and I'll see if I can figure out what it
# does.

# For the benefit of HTML viewers (this is a hack):
# <div id='cover' style='position: absolute; left: 0; top: 0; width: 10000px; height: 10000px; background: white'></div>

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

my $global_data = join '', <DATA>;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value, %options) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value unless $options{no_binding};
    &$delegate($name, $value) unless $options{no_delegate}}}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name")};
meta::meta('configure', <<'__');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__
meta::meta('externalize', <<'__');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  my $escaped = $name;
  $escaped =~ s/[^A-Za-z0-9:]/_/go;
  $externalized_functions{$name} = $externalized_functions{$escaped} = $attribute;
  *{"::$name"} = *{"::$escaped"} = $implementation || $attribute;
}
__
meta::meta('externalize_template', <<'__');
sub meta::externalize_template {
  my ($name, $implementation) = @_;
  meta::externalize "template::$name", "template::$name", $implementation;
}
__
meta::meta('functor::code-templates', <<'__');
package code;

# Templates for generating named source files.
sub template {
  my ($name, $implementation) = @_;
  $implementation ||= sub {
    my ($line, $block) = @_;
    my $append         = $line =~ s/^\h*>>\h*//o;

    $line =~ s/\s+.*$//o;
    file::write($line, ($append && "\n") . $block, mkpath => 1, append => $append);
    "\\lstset{caption={$line" . ($append && ' (continued)') . "},name={$line}}\\begin{${name}code}\n$block \\end{${name}code}";
  };

  meta::externalize_template $name, $implementation;
}
__
meta::meta('functor::editable', <<'__');
# An editable type. This creates a type whose default action is to open an editor
# on whichever value is mentioned. This can be changed using different flags.

sub meta::functor::editable {
  my ($typename, %options) = @_;

  meta::configure $typename, %options;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;

    $options{on_bind} && &{$options{on_bind}}($name, $value);

    meta::externalize $options{prefix} . $name, "${typename}::$name", sub {
      my $attribute             = "${typename}::$name";
      my ($command, @new_value) = @_;

      return &{$options{default}}(retrieve($attribute)) if ref $options{default} eq 'CODE' and not defined $command;
      return edit($attribute) if $command eq 'edit' or $options{default} eq 'edit' and not defined $command;
      return associate($attribute, @new_value ? join(' ', @new_value) : join('', <STDIN>)) if $command eq '=' or $command eq 'import' or $options{default} eq 'import' and not defined $command;
      return retrieve($attribute)}}}
__
meta::meta('functor::tex-templates', <<'__');
package tex;

# A wrapper for TeX templates. The idea is always the same, so I'm abstracting out the
# common externalization logic here.
sub template_for(&) {
  my ($implementation) = @_;
  sub {
    my %names = @_;
    for my $name (keys %names) {
      ::meta::externalize_template $name, sub {
        &$implementation($names{$name}, @_);
      };
    }
  };
}

sub id {
  map {$_ => $_} @_;
}

# Creates a one-line or multiline template based on normal TeX syntax. It's a straight
# transfer into TeX with no preprocessing.
*template = template_for {
  my ($name, $line, $block) = @_;
  $block ? "\\begin{$name}\n$block\n\\end{$name}" : "\\$name\{$line\}";
};

# Creates a labeled one-line template. This is just like normal TeX, but assumes the
# specification of a label name after a pipe character.
*labeled_template = template_for {
  my ($name, $line, undef) = @_;
  my ($real_stuff, $label) = split /\h*\|\h*/, $line, 2;
  "\\$name\{$real_stuff\}" . template::label($label);
};
__
meta::meta('template::beamer', <<'__');
tex::template tex::id(qw/frame pause block alertblock exampleblock/);

my $fframe_template = tex::template_for {
  my ($name, $line, $block) = @_;
  "\\begin{frame}[fragile]\n$block\n\\end{frame}\n";
};
&$fframe_template(tex::id('fframe'));
__
meta::meta('template::code', 'code::template $_ for qw/java cpp asm javascript html resource perl ruby python/;');
meta::meta('template::document', 'tex::template tex::id(qw/document tableofcontents maketitle title author date abstract documentclass verbatim/);');
meta::meta('template::enumeration', <<'__');
tex::template tex::id(qw/enumerate itemize description/);
tex::labeled_template tex::id(qw/item/);
__
meta::meta('template::math', <<'__');
tex::template align => 'align*', nalign => 'align';
tex::template tex::id(qw/theorem proof lemma corollary conjecture definition proposition/);
__
meta::meta('template::quotations', 'tex::template tex::id(qw/quotation quote/);');
meta::meta('template::sections', <<'__');
tex::labeled_template(s1 => 'section', s2 => 'subsection', s3 => 'subsubsection', s4 => 'paragraph', s5 => 'subparagraph');
tex::labeled_template(sc => 'chapter', sp => 'part');
__
meta::meta('type::alias', <<'__');
meta::configure 'alias', inherit => 0, trim => 1;
meta::define_form 'alias', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "alias::$name", sub {
    # Can't pre-tokenize because shell::tokenize doesn't exist until the library::
    # namespace has been evaluated (which will be after alias::).
    shell::run(shell::tokenize($value), shell::tokenize(@_));
  };
};
__
meta::meta('type::bootstrap', <<'__');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1, trim => 1;
meta::define_form 'bootstrap', sub {};
__
meta::meta('type::cache', <<'__');
meta::configure 'cache', inherit => 0, trim => 1;
meta::define_form 'cache', \&meta::bootstrap::implementation;
__
meta::meta('type::data', 'meta::functor::editable \'data\', extension => \'\', inherit => 0, default => \'cat\';');
meta::meta('type::function', <<'__');
meta::configure 'function', extension => '.pl', inherit => 1, trim => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", meta::eval_in("sub {\n$value\n}", "function::$name");
};
__
meta::meta('type::hook', <<'__');
meta::configure 'hook', extension => '.pl', inherit => 0, trim => 1;
meta::define_form 'hook', sub {
  my ($name, $value) = @_;
  *{"hook::$name"} = meta::eval_in("sub {\n$value\n}", "hook::$name");
};
__
meta::meta('type::inc', <<'__');
meta::configure 'inc', inherit => 1, extension => '.pl', trim => 1;
meta::define_form 'inc', sub {
  use File::Path 'mkpath';
  use File::Basename qw/basename dirname/;

  my ($name, $value) = @_;
  my $tmpdir   = basename($0) . '-' . $$;
  my $filename = "/tmp/$tmpdir/$name";

  push @INC, "/tmp/$tmpdir" unless grep /^\/tmp\/$tmpdir$/, @INC;

  mkpath(dirname($filename));
  unless (-e $filename) {
    open my $fh, '>', $filename;
    print $fh $value;
    close $fh;
  }
};
__
meta::meta('type::indicator', <<'__');
# Shell indicator function. The output of each of these is automatically
# appended to the shell prompt.

meta::configure 'indicator', inherit => 1, extension => '.pl', trim => 1;
meta::define_form 'indicator', sub {
  my ($name, $value) = @_;
  *{"indicator::$name"} = meta::eval_in("sub {\n$value\n}", "indicator::$name");
};
__
meta::meta('type::internal_function', <<'__');
meta::configure 'internal_function', extension => '.pl', inherit => 1, trim => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = meta::eval_in("sub {\n$value\n}", "internal_function::$name");
};
__
meta::meta('type::library', <<'__');
meta::configure 'library', extension => '.pl', inherit => 1, trim => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "library::$name");
};
__
meta::meta('type::message_color', <<'__');
meta::configure 'message_color', extension => '', inherit => 1, trim => 1;
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  terminal::color($name, $value);
};
__
meta::meta('type::meta', <<'__');
# This doesn't define a new type. It customizes the existing 'meta' type
# defined in bootstrap::initialization. Note that horrible things will
# happen if you redefine it using the editable functor.

meta::configure 'meta', extension => '.pl', inherit => 1, trim => 1;
__
meta::meta('type::note', 'meta::functor::editable \'note\', extension => \'.sdoc\', inherit => 0, default => \'edit\';');
meta::meta('type::parent', <<'__');
meta::define_form 'parent', \&meta::bootstrap::implementation;
meta::configure 'parent', extension => '', inherit => 1, trim => 1;
__
meta::meta('type::psection', <<'__');
# Perl TeX section (separated out to help vim syntax highlighter)
meta::functor::editable 'psection', extension => '.perltex', inherit => 0,
                                    default => 'edit';
__
meta::meta('type::resource', 'meta::functor::editable \'resource\', extension => \'.cltex\', inherit => 1, default => \'edit\';');
meta::meta('type::retriever', <<'__');
meta::configure 'retriever', extension => '.pl', inherit => 1, trim => 1;
meta::define_form 'retriever', sub {
  my ($name, $value) = @_;
  $transient{retrievers}{$name} = meta::eval_in("sub {\n$value\n}", "retriever::$name");
};
__
meta::meta('type::sdoc', <<'__');
# A meta-type for other types. So retrieve('js::main') will work if you have
# the attribute 'sdoc::js::main'. The filename will be main.js.sdoc.

meta::functor::editable 'sdoc', inherit => 1, extension => sub {
  extension_for(attribute($_[0])) . '.sdoc';
};
__
meta::meta('type::section', 'meta::functor::editable \'section\', extension => \'.cltex\', inherit => 0, default => \'edit\';');
meta::meta('type::slibrary', <<'__');
meta::configure 'slibrary', extension => '.pl.sdoc', inherit => 1;
meta::define_form 'slibrary', sub {
  my ($name, $value) = @_;
  meta::eval_in(sdoc("slibrary::$name"), "slibrary::$name");
};
__
meta::meta('type::state', <<'__');
# Allows temporary or long-term storage of states. Nothing particularly insightful
# is done about compression, so storing alternative states will cause a large
# increase in size. Also, states don't contain other states -- otherwise the size
# increase would be exponential.

# States are created with the save-state function.

meta::configure 'state', inherit => 0, extension => '.pl', trim => 1;
meta::define_form 'state', \&meta::bootstrap::implementation;
__
meta::meta('type::template', <<'__');
meta::configure 'template', extension => '.pl', inherit => 1;
meta::define_form 'template', sub {
  my ($name, $value) = @_;
  meta::externalize "template::$name", "template::$name", meta::eval_in("sub {\n$value\n}", "template::$name");
};
__
meta::meta('type::vim_highlighter', <<'__');
meta::configure 'vim_highlighter', extension => '.vim', inherit => 1;
meta::define_form 'vim_highlighter', \&meta::bootstrap::implementation;
__
meta::alias('d', 'sh perl -d boot/xh');
meta::alias('eI', 'edit sdoc::xh');
meta::alias('eM', 'edit function::make');
meta::alias('ei', 'edit psection::implementation');
meta::alias('em', 'edit section::main');
meta::alias('ev', 'edit vim_highlighter::xh');
meta::alias('r', 'sh boot/xh');
meta::bootstrap('html', <<'__');
<html>
  <head>
  <meta http-equiv='content-type' content='text/html; charset=UTF-8' />
  <link rel='stylesheet' href='http://spencertipping.com/perl-objects/web/style.css'/>

  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js'></script>
  <script src='http://spencertipping.com/caterwaul/caterwaul.all.min.js'></script>
  <script src='http://spencertipping.com/montenegro/montenegro.client.js'></script>
  <script src='http://spencertipping.com/perl-objects/web/attribute-parser.js'></script>
  <script src='http://spencertipping.com/perl-objects/web/interface.js'></script>
  </head>
  <body></body>
</html>
__
meta::bootstrap('initialization', <<'__');
#!/usr/bin/perl
# 99aeabc9ec7fe80b1b39f5e53dc7e49e      <- self-modifying Perl magic
# state:  __state
# istate: __istate
# id:     __id

# This is a self-modifying Perl file. I'm sorry you're viewing the source (it's
# really gnarly). If you're curious what it's made of, I recommend reading
# http://github.com/spencertipping/writing-self-modifying-perl.
#
# If you got one of these from someone and don't know what to do with it, send
# it to spencer@spencertipping.com and I'll see if I can figure out what it
# does.

# For the benefit of HTML viewers (this is a hack):
# <div id='cover' style='position: absolute; left: 0; top: 0; width: 10000px; height: 10000px; background: white'></div>

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

my $global_data = join '', <DATA>;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value, %options) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value unless $options{no_binding};
    &$delegate($name, $value) unless $options{no_delegate}}}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name")};
__
meta::bootstrap('perldoc', <<'__');
=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/writing-self-modifying-perl>. For quick usage guidelines,
run this script with the 'usage' argument.

=cut
__
meta::cache('parent-identification', <<'__');
/home/spencertipping/r/initiative/perl-objects/tex-document d6b8b54aecc42ae92c7a8c570c5559fc
notes a9e5975593ed5d90d943ad98405c71e5
object 99aeabc9ec7fe80b1b39f5e53dc7e49e
preprocessor 70dae4b46eb4e06798ec6f38d17d4c7b
sdoc a1e8480e579614c01dabeecf0f963bcc
vim-highlighters 902333a0bd6ed90ff919fe8477cb4e69
__
meta::cache('parent-state', <<'__');
70dae4b46eb4e06798ec6f38d17d4c7b aVkS5uQvv85hgzS3VDzMTfOKCXBPxJ8n+FHe2wroaCc
902333a0bd6ed90ff919fe8477cb4e69 a2UfhjT/gGzuzJhjQpPzYghjO5CQH4FkK/o/GudHAo8
99aeabc9ec7fe80b1b39f5e53dc7e49e 8o6O4hqEnGDxNC5FgK+q340aKWykAb+LRLAe0Fi9xMc
a1e8480e579614c01dabeecf0f963bcc TBP4VqMuHSrBGYCiWy55lQf/m9n+oFaFNxsHIxBGCnQ
a9e5975593ed5d90d943ad98405c71e5 21rFW0cbMFtbY56uoN16l/ZlsJxAHKK431eTvQChPI4
d6b8b54aecc42ae92c7a8c570c5559fc r/XuS0NmAOK5ctQCiJapfDA6ij7HcGK1LDWOA1k6ttI
__
meta::data('author', 'Spencer Tipping');
meta::data('default-action', 'shell');
meta::data('license', <<'__');
MIT License
Copyright (c) 2010 Spencer Tipping

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
__
meta::data('permanent-identity', 'd8b3d476069348db3de1c9f0407d9c1e');
meta::function('ad', <<'__');
my ($options, @paths) = separate_options(@_);
@{$transient{path}} = () if $$options{-c};
return @{$transient{path}} = () unless @paths;
push @{$transient{path}}, @paths;
__
meta::function('alias', <<'__');
my ($name, @stuff) = @_;
@_ ? @stuff ? around_hook('alias', @_, sub {associate("alias::$name", join(' ', @stuff), execute => 1)})
            : retrieve("alias::$name") // "Undefined alias $name"
   : table_display([select_keys('--namespace' => 'alias')], [map retrieve($_), select_keys('--namespace' => 'alias')]);
__
meta::function('cat', 'join "\\n", retrieve(@_);');
meta::function('cc', <<'__');
# Stashes a quick one-line continuation. (Used to remind me what I was doing.)
@_ ? associate('data::current-continuation', hook('set-cc', join(' ', @_))) : retrieve('data::current-continuation');
__
meta::function('ccc', 'rm(\'data::current-continuation\');');
meta::function('cd', <<'__');
my ($options, @stuff) = separate_options(@_);
my @new_stuff = map "${_}::", @stuff;
ad(%$options, @new_stuff);
__
meta::function('child', <<'__');
around_hook('child', @_, sub {
  my ($child_name) = @_;
  clone($child_name);
  enable();
  qx($child_name update-from $0);
  terminal::info("$child_name\'s identity is " . join '', qx($child_name identity));
  disable()});
__
meta::function('clone', <<'__');
my ($options, @files) = separate_options(@_);
for my $file (@files) {
  around_hook('clone', $file, sub {
    hypothetically(sub {
      # Assign a new object identity.
      rm('data::permanent-identity');
      identity();

      file::write($file, serialize(), noclobber => 1);
      chmod(0700, $file)})})}
__
meta::function('compile-tex', <<'__');
my ($options, @documents) = separate_options(@_);
my $temporary_directory = temporary_name();

my $tex = tex(@documents);
my $toc = $tex =~ /\\tableofcontents/;

mkdir $temporary_directory;
file::write(my $filename = "$temporary_directory/document.tex", tex(@documents));

my $destination = $$options{'--pdf'} || name() . '.pdf';
my $output = $filename;
$output =~ s/\.tex$/.pdf/;

my $opts = "-output-directory=$temporary_directory";

$toc ? sh("latex $opts $filename && latex $opts $filename && pdflatex $opts $filename && mv $output $destination && rm -r $temporary_directory")
     : sh("pdflatex $opts $filename && mv $output $destination && rm -r $temporary_directory");
__
meta::function('cp', <<'__');
my $from = shift @_;
my $value = retrieve($from);
associate($_, $value) for @_;
__
meta::function('create', <<'__');
my ($name, $value) = @_;
around_hook('create', $name, $value, sub {
  return edit($name) if exists $data{$name};
  associate($name, defined $value ? $value : '');
  edit($name) unless defined $value});
__
meta::function('current-state', 'serialize(\'-pS\');');
meta::function('cwd', <<'__');
use Cwd qw/getcwd/;
getcwd();
__
meta::function('disable', 'hook(\'disable\', chmod_self(sub {$_[0] & 0666}));');
meta::function('edit', <<'__');
my ($options, @names) = separate_options(@_);
@names = select_keys('--criteria' => "^$$options{'--prefix'}.*" . join('.*', @names), %$options) if $$options{'--prefix'};

my ($name, @others) = @names;
die "cannot edit multiple attributes simultaneously (others are @others)" if @others;
die "$name is virtual or does not exist" unless exists $data{$name};
die "$name is inherited; use 'edit $name -f' to edit anyway" unless is($name, '-u') || is($name, '-d') || exists $$options{'-f'};

my $extension = extension_for($name);
my $changed   = 0;
around_hook('edit', @_, sub {
  my $result = invoke_editor_on($data{$name} // '', %$options, attribute => $name, extension => $extension);
  $changed += $data{$name} ne $result;
  associate($name, $result, execute => 1)});

save() unless !$changed or $data{'data::edit::no-save'} or state() eq $transient{initial};
$changed;
__
meta::function('edit-self', <<'__');
$global_data = invoke_editor_on($global_data);
save();
__
meta::function('enable', 'hook(\'enable\', chmod_self(sub {$_[0] | ($_[0] & 0444) >> 2}));');
meta::function('expanded-bootstrap', <<'__');
# Write headers into the bootstrap section. There is some subtle stuff going on
# here with the istate header. The idea is to provide other objects a very quick
# way to see whether our state has changed, but we don't want false positives.
# We would get a false positive if, for instance, we included the contents of
# parent:: attributes in the istate hash. The reason is that the parent::
# attribute contains a hash of every attribute provided by that parent, so any
# change in the parent would impact the istate of the child.
#
# The best way to deal with this is to treat parent:: attributes as being
# opaque; we record their existence or nonexistence, but we don't record their
# contents. We also look only at inheritable and unique attributes and fail to
# consider global state.

my $bootstrap_text = $_[0] // retrieve('bootstrap::initialization');
my $state          = state();
my $istate         = state('-iGP');
my $object_id      = identity();

$bootstrap_text =~ s/__state/$state/g;
$bootstrap_text =~ s/__istate/$istate/g;
$bootstrap_text =~ s/__id/$object_id/g;

$bootstrap_text;
__
meta::function('export', <<'__');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt
my $name = pop @_;
@_ or die 'Expected filename';
file::write($name, join "\n", retrieve(@_));
__
meta::function('extern', '&{$_[0]}(retrieve(@_[1 .. $#_]));');
meta::function('grep', <<'__');
# Looks through attributes for a pattern. Usage is grep pattern [options], where
# [options] is the format as provided to select_keys.

my ($pattern, @args)     = @_;
my ($options, @criteria) = separate_options(@args);
my @attributes           = select_keys(%$options, '--criteria' => join('|', @criteria));

$pattern = qr/$pattern/;

my @m_attributes;
my @m_line_numbers;
my @m_lines;

for my $k (@attributes) {
  next unless length $k;
  my @lines = split /\n/, retrieve($k);
  for (0 .. $#lines) {
    next unless $lines[$_] =~ $pattern;
    push @m_attributes,   $k;
    push @m_line_numbers, $_ + 1;
    push @m_lines,        '' . ($lines[$_] // '')}}

unless ($$options{'-C'}) {
  s/($pattern)/\033[1;31m\1\033[0;0m/g for @m_lines;
  s/^/\033[1;34m/o for @m_attributes;
  s/^/\033[1;32m/o && s/$/\033[0;0m/o for @m_line_numbers}

table_display([@m_attributes], [@m_line_numbers], [@m_lines]);
__
meta::function('hash', 'fast_hash(@_);');
meta::function('hook', <<'__');
my ($hook, @args) = @_;
$transient{active_hooks}{$hook} = 1;
dangerous('', sub {&$_(@args)}) for grep /^hook::${hook}::/, sort keys %data;
@args;
__
meta::function('hooks', 'join "\\n", sort keys %{$transient{active_hooks}};');
meta::function('identity', <<'__');
retrieve('data::permanent-identity') or
associate('data::permanent-identity', fast_hash(join '|', map rand(), 1 .. 32));
__
meta::function('import', <<'__');
my $name = pop @_;
my $namespace = 'meta::' . namespace($name);
my $attribute = attribute($name);
&$namespace($attribute, @_ ? join '', map file::read($_), @_
                           : join '', <STDIN>);
__
meta::function('initial-state', '$transient{initial};');
meta::function('is', <<'__');
my ($attribute, @criteria) = @_;
my ($options, @stuff) = separate_options(@criteria);
exists $data{$attribute} and attribute_is($attribute, %$options);
__
meta::function('load-state', <<'__');
around_hook('load-state', @_, sub {
  my ($state_name) = @_;
  my $state = retrieve("state::$state_name");

  terminal::state('saving current state into _...');
  save_state('_');

  delete $data{$_} for grep ! /^state::/, keys %data;
  %externalized_functions = ();

  terminal::state("restoring state $state_name...");
  meta::eval_in($state, "state::$state_name");
  terminal::error(hook('load-state-failed', $@)) if $@;
  reload();
  verify()});
__
meta::function('lock', 'hook(\'lock\', chmod_self(sub {$_[0] & 0555}));');
meta::function('ls', <<'__');
my ($options, @criteria) = separate_options(@_);
my ($external, $shadows, $sizes, $flags, $long, $hashes, $parent_hashes) = @$options{qw(-e -s -z -f -l -h -p)};
$sizes = $flags = $hashes = $parent_hashes = 1 if $long;

return table_display([grep ! exists $data{$externalized_functions{$_}}, sort keys %externalized_functions]) if $shadows;

my $criteria    = join('|', @criteria);
my @definitions = select_keys('--criteria' => $criteria, '--path' => $transient{path}, %$options);

my %inverses  = map {$externalized_functions{$_} => $_} keys %externalized_functions;
my @externals = map $inverses{$_}, grep length, @definitions;
my @internals = grep length $inverses{$_}, @definitions;
my @sizes     = map sprintf('%6d %6d', length(serialize_single($_)), length(retrieve($_))), @{$external ? \@internals : \@definitions} if $sizes;

my @flags     = map {my $k = $_; join '', map(is($k, "-$_") ? $_ : '-', qw(d i m u))} @definitions if $flags;
my @hashes    = map fast_hash(retrieve($_)), @definitions if $hashes;

my %inherited     = parent_attributes(grep /^parent::/o, keys %data) if $parent_hashes;
my @parent_hashes = map $inherited{$_} || '-', @definitions if $parent_hashes;

join "\n", map strip($_), split /\n/, table_display($external ? [grep length, @externals] : [@definitions],
                                                    $sizes ? ([@sizes]) : (), $flags ? ([@flags]) : (), $hashes ? ([@hashes]) : (), $parent_hashes ? ([@parent_hashes]) : ());
__
meta::function('make', <<'__');
my ($options, @stuff) = separate_options(@_);

# vim highlighting
file::write('xh.vim', retrieve('vim_highlighter::xh'));

tex();                  # preliminary run to generate files
my $tex = tex();

# XH bootstrapping
mkdir 'boot' unless -d 'boot';
file::write('boot/xh', retrieve('pp::sdoc::xh'));

chmod 0700, 'boot/xh';   system 'boot/xh   --recompile > boot/xh-1';
chmod 0700, 'boot/xh-1'; system 'boot/xh-1 --recompile > xh';
chmod 0755, 'xh';

unless ($$options{-T}) {
  file::write('xh.tex', $tex);
  compile_tex('--pdf=xh.pdf');
}

print "xh size is " . length(retrieve('xh')) . " bytes\n";
system 'echo `grep TESTCODE xh | wc -l` "line(s) of test code in ./xh"';
__
meta::function('mv', <<'__');
my ($from, $to) = @_;
die "'$from' does not exist" unless exists $data{$from};
associate($to, retrieve($from), execute => 1);
rm($from);
__
meta::function('name', <<'__');
my $name = $0;
$name =~ s/^.*\///;
$name;
__
meta::function('note', <<'__');
# Creates a note with a given name, useful for jotting things down.
my $name = join('-', @_);
create("note::$name");
__
meta::function('notes', 'ls(\'-a\', \'^note::\');');
meta::function('parents', 'join "\\n", grep s/^parent:://o, sort keys %data;');
meta::function('perl', <<'__');
my @result = eval(join ' ', @_);
$@ ? terminal::error($@) : wantarray ? @result : $result[0];
__
meta::function('preprocess', <<'__');
# Implements a simple preprocessing language.
# Syntax follows two forms. One is the 'line form', which gives you a way to specify arguments inline
# but not spanning multiple lines. The other is 'block form', which gives you access to both one-line
# arguments and a block of lines. The line parameters are passed in verbatim, and the block is
# indentation-adjusted and then passed in as a second parameter. (Indentation is adjusted to align
# with the name of the command.)
#
# Here are the forms:
#
# - line arguments to function
#
# - block line arguments << eof
#   block contents
#   block contents
#   ...
# - eof

my ($string, %options) = @_;
my $expansions         = 0;
my $old_string         = '';
my $limit              = $options{expansion_limit} || 100;
my @pieces             = ();

sub adjust_spaces {
  my ($spaces, $string) = @_;
  $string =~ s/^$spaces  //mg;
  chomp $string;
  $string;
}

while ($old_string ne $string and $expansions++ < $limit) {
  $old_string = $string;

  while ((my @pieces = split  /(^(\h*)-\h \S+ \h* \V* <<\h*(\w+)$ \n .*?  ^\2-\h\3$)/xms, $string) > 1 and $expansions++ < $limit) {
    $pieces[1 + ($_ << 2)] =~ /^ (\h*)-\h(\S+)\h*(\V*)<<\h*(\w+)$ \n(.*?) ^\1-\h\4 $/xms && $externalized_functions{"template::$2"} and
      $pieces[1 + ($_ << 2)] = &{"template::$2"}($3, adjust_spaces($1, $5))
      for 0 .. $#pieces / 4;

    @pieces[2 + ($_ << 2), 3 + ($_ << 2)] = '' for 0 .. $#pieces / 4;
    $string = join '', @pieces;
  }

  if ((my @pieces = split     /^(\h*-\h \S+ \h* .*)$/xom, $string) > 1) {
    $pieces[1 + ($_ << 1)] =~ /^ \h*-\h(\S+)\h*(.*)$/xom && $externalized_functions{"template::$1"} and
      $pieces[1 + ($_ << 1)] = &{"template::$1"}($2)
      for 0 .. $#pieces >> 1;

    $string = join '', @pieces;
  }
}

$string;
__
meta::function('rd', <<'__');
if (@_) {my $pattern = join '|', @_;
         @{$transient{path}} = grep $_ !~ /^$pattern$/, @{$transient{path}}}
else    {pop @{$transient{path}}}
__
meta::function('reload', 'around_hook(\'reload\', sub {execute($_) for grep ! /^bootstrap::/, keys %data});');
meta::function('rm', <<'__');
around_hook('rm', @_, sub {
  exists $data{$_} or terminal::warning("$_ does not exist") for @_;
  delete @data{@_}});
__
meta::function('rmparent', <<'__');
# Removes one or more parents.
my ($options, @parents) = separate_options(@_);
my $clobber_divergent = $$options{'-D'} || $$options{'--clobber-divergent'};

my %parents = map {$_ => 1} @parents;
my @other_parents = grep !$parents{$_}, grep s/^parent:://, select_keys('--namespace' => 'parent');
my %kept_by_another_parent;

$kept_by_another_parent{$_} = 1 for grep s/^(\S+)\s.*$/\1/, split /\n/o, cat(@other_parents);

for my $parent (@parents) {
  my $keep_parent_around = 0;

  for my $line (split /\n/, retrieve("parent::$parent")) {
    my ($name, $hash) = split /\s+/, $line;
    next unless exists $data{$name};

    my $local_hash = fast_hash(retrieve($name));
    if ($clobber_divergent or $hash eq $local_hash or ! defined $hash) {rm($name) unless $kept_by_another_parent{$name}}
    else {terminal::info("local attribute $name exists and is divergent; use rmparent -D $parent to delete it");
          $keep_parent_around = 1}}

  $keep_parent_around ? terminal::info("not deleting parent::$parent so that you can run", "rmparent -D $parent if you want to nuke divergent attributes too")
                      : rm("parent::$parent")}
__
meta::function('save', <<'__');
around_hook('save', sub {dangerous('', sub {
  file::write($0,
    retrieve('data::save-indirect') ? serialize('-V', '--indirect')
                                    : serialize('-V'));
  $transient{initial} = state()}) if verify()});
__
meta::function('save-state', <<'__');
# Creates a named copy of the current state and stores it.
my ($state_name) = @_;
around_hook('save-state', $state_name, sub {
  associate("state::$state_name", current_state(), execute => 1)});
__
meta::function('sdoc', <<'__');
# Applies SDoc processing to a file or attribute. Takes the file or attribute
# name as the first argument and returns the processed text.

my %comments_for_extension = 
  qw|c     /*,*/  cpp   //    cc   //    h    /*,*/ java //  py  #    rb   #    pl  #   pm   #         ml   (*,*)  js  //
     hs    --     sh    #     lisp ;;;   lsp  ;;;   s    #   scm ;;;  sc   ;;;  as  //  html <!--,-->  mli  (*,*)  cs  //
     vim   "      elisp ;     bas  '     ada  --    asm  ;   awk #    bc   #    boo #   tex  %         fss  (*,*)  erl %
     scala //     hx    //    io   //    j    NB.   lua  --  n   //   m    %    php //  sql  --        pov  //     pro %
     r     #      self  ","   tcl  #     texi @c    tk   #   csh #    vala //   vbs '   v    /*,*/     vhdl --     ss  ;;;
     haml  -#     sass  /*,*/ scss /*,*/ css  /*,*/ fig  /   waul #   hh   //   ps  %   canard nb[,]   x    /*,*/  xr  /*,*/
     xu    /*,*/  xn    /*,*/ xbn  /*,*/ xs   /*,*/ m4   dnl|;

# No extension suggests a shebang line, which generally requires # to denote a comment.
$comments_for_extension{''} = '#';

my $generated_string = 'Generated by SDoc';

sub is_code    {map /^\s*[^A-Z\|\s]/o, @_}
sub is_blank   {map /^\n/o, @_}
sub comment    {my ($text, $s, $e) = @_; join "\n", map("$s $_" . (length $e ? " $e" : ''), split /\n/, $text)}

sub paragraphs {map split(/(\n(?:\h*\n)+)/, $_), @_}

my ($filename, $specified_extension) = @_;
my $logical_filename = $filename =~ /^sdoc::(.*)$/ ? $1 : $filename;

# Two possibilities here. One is that the filename is an attribute, in which case
# we want to look up the extension in the transients table. The other is that
# it's a real filename.
my $extension = $specified_extension || extension_for($logical_filename) || ($filename =~ /\.sdoc$/io ? $filename =~ /\.(\w+)\.sdoc$/igo : $filename =~ /\.(\w+)$/igo)[0];
$extension =~ s/^\.//o;

my ($start, $end) = split /,/o, $comments_for_extension{lc $extension} // $comments_for_extension{''} // '#';

join '', map(is_code($_) || is_blank($_) ? ($_ =~ /^\s*c\n(.*)$/so ? $1 : $_) : comment($_, $start, $end), paragraphs retrieve($filename)),
         "\n" . comment($generated_string, $start, $end) . "\n";
__
meta::function('sdoc-html', <<'__');
# Converts SDoc to logically-structured HTML. Sections end up being nested,
# and code sections and examples are marked as such. For instance, here is some
# sample output:

# <div class='section level1'>
#   <h1 class='title'>Foo</h1>
#   <p>This is a paragraph...</p>
#   <p>This is another paragraph...</p>
#   <pre class='code'>int main () {return 0;}</pre>
#   <pre class='quoted'>int main () {return 0} // Won't compile</pre>
#   <div class='section level2'>
#     <h2 class='title'>Bar</h2>
#     ...
#   </div>
# </div>

# It is generally good about escaping things that would interfere with HTML,
# but within text paragraphs it lets you write literal HTML. The heuristic is
# that known tags that are reasonably well-formed are allowed, but unknown ones
# are escaped.

my ($attribute)   = @_;
my @paragraphs    = split /\n(?:\s*\n)+/, retrieve($attribute);

my $known_tags    = join '|', qw[html head body meta script style link title div a span input button textarea option select form label iframe blockquote code caption
                                 table tbody tr td th thead tfoot img h1 h2 h3 h4 h5 h6 li ol ul noscript p pre samp sub sup var canvas audio video strong em];
my $section_level = 0;
my @markup;

my $indent        = sub {'  ' x ($_[0] || $section_level)};
my $unindent      = sub {my $spaces = '  ' x ($section_level - 1); s/^$spaces//gm};

my $escape_all    = sub {s/&/&amp;/g; s/</&lt;/g; s/>/&gt;/g};
my $escape_some   = sub {s/&/&amp;/g; s/<(?!\/|($known_tags)[^>]*>.*<\/\1>)/&lt;/gs};

my $code          = sub {&$escape_all(); &$unindent(); s/^c\n//;                   push @markup, &$indent() . "<pre class='code'>$_</pre>"};
my $quoted        = sub {&$escape_all(); &$unindent(); s/^\|(\s?)/ \1/; s/^  //mg; push @markup, &$indent() . "<pre class='quoted'>$_</pre>"};

my $paragraph     = sub {&$escape_some(); push @markup, &$indent() . "<p>$_</p>"};

my $section       = sub {my $h = $_[0] > 6 ? 6 : $_[0]; push @markup, &$indent($_[0] - 1) . "<div class='section level$_[0]'>", &$indent($_[0]) . "<h$h>$2</h$h>"};
my $close_section = sub {push @markup, &$indent($_[0]) . "</div>"};

my $title = sub {
  my $indentation = (length($1) >> 1) + 1;
  &$close_section($section_level) while $section_level-- >= $indentation;
  &$section($indentation);
  $section_level = $indentation;
};

for (@paragraphs) {
  &$code(),   next unless /^\h*[A-Z|]/;
  &$quoted(), next if     /^\h*\|/;

  &$title(), s/^.*\n// if /^(\s*)(\S.*)\.\n([^\n]+)/ and length("$1$2") < 60 and length("$1$2") - 10 < length($3);
  &$paragraph();
}

&$close_section($section_level) while $section_level--;

join "\n", @markup;
__
meta::function('sdoc-markdown', <<'__');
# Renders a chunk of SDoc as Markdown. This involves converting quoted and
# unquoted code and section headings, but not numbered lists.

my ($attribute, %options) = @_;
my ($adjust, $quote_code) = @options{qw/adjust quote_code/};
$adjust //= 0;

my $extension     = extension_for($attribute =~ /^sdoc::(.*)$/g) || ($attribute =~ /.*?\.([^\.]+)(?:\.sdoc)?$/gi)[0];
my @paragraphs    = split /\n(?:\s*\n)+/, retrieve($attribute);

my $section_level = 0;
my @markup;

my $indent        = sub {'  ' x ($_[0] || $section_level)};
my $unindent      = sub {my $spaces = '  ' x ($section_level - $adjust - 1); s/^$spaces//gm; $_};

my $code          = sub {goto &$quoted if $quote_code;
                         &$unindent(); s/^c\n//;                   push @markup, "```$extension\n$_\n```"};
my $quoted        = sub {&$unindent(); s/^\|(\s?)/ \1/; s/^  //mg; push @markup, join("\n", map &$indent(2) . $_, split /\n/)};

my $heading       = sub {'#' x $_[0]};
my $section       = sub {&$unindent(); push @markup, &$heading($_[0]) . ' ' . $2};

my $title = sub {
  my $indentation = (length($1) >> 1) + 1 + $adjust;
  &$section($indentation);
  $section_level = $indentation;
};

for (@paragraphs) {
  &$code(),   next unless /^\h*[A-Z|]/;
  &$quoted(), next if     /^\h*\|/;

  &$title(), s/^.*\n// if /^(\s*)(\S.*)\.\n([^\n]+)/ and length("$1$2") < 60 and length("$1$2") - 10 < length($3);
  push @markup, join "\n", map &$unindent(), split /\n/;
}

join "\n\n", @markup;
__
meta::function('sdoc-packed', <<'__');
# An SDoc preprocessor that removes all comment paragraphs. Paragraph breaks
# are preserved, and no "generated by SDoc" string is added.
join "\n", grep /^\s*[^A-Z| ]/, split /\n(?:\s*\n)+/, retrieve(@_);
__
meta::function('sdoc-pod', <<'__');
# Renders a chunk of SDoc as POD. This involves converting quoted and
# unquoted code and section headings, but not numbered lists. It also
# involves converting Markdown's code-text and link syntax.

use List::Util qw/min/;

my ($attribute, %options) = @_;
my ($adjust, $quote_code) = @options{qw/adjust quote_code/};
$adjust //= 0;

my $extension     = extension_for($attribute =~ /^sdoc::(.*)$/g) || ($attribute =~ /.*?\.([^\.]+)(?:\.sdoc)?$/gi)[0];
my @paragraphs    = split /\n(?:\s*\n)+/, retrieve($attribute);

my $section_level = 0;
my @markup;

my $indent        = sub {'  ' x ($_[0] || $section_level)};
my $unindent      = sub {my $spaces = '  ' x ($section_level - $adjust - 1); s/^$spaces//gm; $_};

my $code          = sub {goto &$quoted if $quote_code;
                         &$unindent(); s/^c\n//;                   push @markup, "=cut\n\n$_\n\n=pod"};
my $quoted        = sub {&$unindent(); s/^\|(\s?)/ \1/; s/^  //mg; push @markup, join "\n", map "  $_", split /\n/};
my $section       = sub {&$unindent(); push @markup, "=head$_[0] $2"};

my $title = sub {
  my $indentation = (length($1) >> 1) + 1 + $adjust;
  &$section($indentation);
  $section_level = $indentation;
};

for (@paragraphs) {
  &$code(),   next unless /^\h*[A-Z|]/;
  &$quoted(), next if     /^\h*\|/;

  # Anything below here is a "normal" (i.e. commented) paragraph, so
  # normal text-transformation rules apply.
  s/`([^`]+?)`/C<<<<< $1 >>>>>/g;       # Markdown inline code
  s/\[([^]]+)\]\(([^)]+)\)/L<$1|$2>/g;  # Markdown link

  &$title(), s/^.*\n// if /^(\s*)(\S.*)\.\n([^\n]+)/ and length("$1$2") < 60 and length("$1$2") - 10 < length($3);

  # Undo any consistent indentation within a paragraph.
  {
    my $paragraph         = $_;
    my $indentation_level = min(map length(s/^(\s*).*/$1/rmg), split /\n/);
    my $spaces            = ' ' x $indentation_level;
    $_ = $paragraph =~ s/^$spaces//mgr;
  }

  push @markup, join "\n", map &$unindent(), split /\n/;
}

join "\n\n", @markup;
__
meta::function('sdocp', <<'__');
# Renders an attribute as SDocP. This logic was taken directly from the sdoc script.
my $attribute = retrieve($_[0]);
sub escape {my @results = map {s/\\/\\\\/go; s/\n/\\n/go; s/'/\\'/go; $_} @_; wantarray ? @results : $results[0]}
"sdocp('" . escape($_[0]) . "', '" . escape($attribute) . "');";
__
meta::function('serialize', <<'__');
my ($options, @criteria) = separate_options(@_);
delete $$options{'-P'};

my $partial  = delete $$options{'-p'};
my $criteria = join '|', @criteria;
my @parents  = grep s/^parent:://, sort keys %data;
my $indirect = delete $$options{'--indirect'} && @parents;

my @attributes = map serialize_single($_),
                 @{$indirect
               ? [map select_keys(%$options, @$_, '--criteria' => $criteria),
                      [qw/-m 1 -d 1/], [qw/-m 1 -u 1/],
                      [qw/-M 1 -d 1/], [qw/-M 1 -u 1/]]
               : [map select_keys(%$options, $_ => 1, '--criteria' => $criteria),
                      qw/-m -M/]};

my @trailing = (@attributes,
                'internal::main();',
                '__DATA__',
                $global_data);

my @final_array = @{$partial  ? [@attributes]
                  : $indirect ? [expanded_bootstrap(),
                                 map(qq[eval `$_ serialize -p`; die \$@ if \$@;],
                                     @parents),
                                 @trailing]
                  :             [expanded_bootstrap(), @trailing]};

join "\n", @final_array;
__
meta::function('serialize-single', <<'__');
# Serializes a single attribute and optimizes for content.

my $name          = $_[0] || $_;
my $contents      = retrieve_trimmed($name);
my $meta_function = 'meta::' . namespace($name);
my $invocation    = attribute($name);

if ($contents !~ /\v/) {
  $contents =~ s/\\/\\\\/go;
  $contents =~ s/'/\\'/go;
  return "$meta_function('$invocation', '$contents');"}

my $delimiter = '__' . fast_hash($contents);
my $chars     = 2;

++$chars until $chars >= length($delimiter) || index("\n$contents", "\n" . substr($delimiter, 0, $chars)) == -1;
$delimiter = substr($delimiter, 0, $chars);

"$meta_function('$invocation', <<'$delimiter');\n$contents\n$delimiter";
__
meta::function('sh', <<'__');
around_hook('sh', @_, sub {
  system(@_)});
__
meta::function('shb', <<'__');
# Backgrounded shell.
with_fork(@_, \&::sh);
__
meta::function('shell', <<'__');
my ($options, @arguments) = separate_options(@_);
$transient{repl_prefix} = $$options{'--repl-prefix'};

terminal::cc(retrieve('data::current-continuation')) if length $data{'data::current-continuation'};
around_hook('shell', sub {shell::repl(%$options)});
__
meta::function('size', <<'__');
my $size = 0;
$size += length $data{$_} for keys %data;
sprintf "   full logical  unique    self\n% 7d % 7d % 7d % 7d", length(serialize()), $size, length(serialize('-up')), length $global_data;
__
meta::function('snapshot', <<'__');
my ($name) = @_;
file::write(my $finalname = temporary_name($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
hook('snapshot', $finalname);
__
meta::function('snapshot-if-necessary', 'snapshot() if state() ne $transient{initial};');
meta::function('state', <<'__');
my ($options, @attributes) = separate_options(@_);
@attributes = grep !is($_, '-v'), sort keys %data unless @attributes;
@attributes = grep is($_, '-iu'), @attributes if $$options{'-i'};
@attributes = grep is($_, '-P'),  @attributes if $$options{'-P'};

my $hash = fast_hash(fast_hash(scalar @attributes) . join '|', @attributes);
$hash = fast_hash(retrieve_trimmed($_) . "|$hash") for @attributes;

$hash = fast_hash(join '|', $hash, grep s/^parent:://, sort keys %data)
if $$options{'-P'};

$$options{'-G'} ? $hash : fast_hash("$global_data|$hash");
__
meta::function('tex', <<'__');
my @documents = @_ ? @_ : qw/main/;
join "\n\n", map preprocess(retrieve("section::$_")), @documents;
__
meta::function('touch', 'associate($_, \'\') for @_;');
meta::function('u', <<'__');
my ($options, $count) = separate_options(@_);
$count //= 1;
rd() while $count--;
__
meta::function('unlock', 'hook(\'unlock\', chmod_self(sub {$_[0] | 0200}));');
meta::function('update', 'update_from(@_, grep s/^parent:://o, sort keys %data);');
meta::function('update-from', <<'__');
# Upgrade all attributes that aren't customized. Customization is defined when the data type is created,
# and we determine it here by checking for $transient{inherit}{$type}.

# Note that this assumes you trust the remote script. If you don't, then you shouldn't update from it.

around_hook('update-from-invocation', separate_options(@_), sub {
  my ($options, @targets) = @_;
  my %parent_id_cache    = cache('parent-identification');
  my %parent_state_cache = cache('parent-state');
  my %already_seen;

  @targets or return;

  my @known_targets     = grep s/^parent:://, parent_ordering(map "parent::$_", grep exists $data{"parent::$_"}, @targets);
  my @unknown_targets   = grep ! exists $data{"parent::$_"}, @targets;
  @targets = (@known_targets, @unknown_targets);

  my $save_state        = $$options{'-s'} || $$options{'--save'};
  my $no_state          = $$options{'-S'} || $$options{'--no-state'};
  my $no_verify         = $$options{'-V'} || $$options{'--no-verify'};
  my $no_parents        = $$options{'-P'} || $$options{'--no-parent'} || $$options{'--no-parents'};
  my $force             = $$options{'-f'} || $$options{'--force'};
  my $clobber_divergent = $$options{'-D'} || $$options{'--clobber-divergent'};

  my $can_skip_already_seen = !($$options{'-K'} || $$options{'--no-skip'}) &&
                              !$force && !$clobber_divergent;

  save_state('before-update') unless $no_state;

  for my $target (@targets) {
    dangerous("updating from $target", sub {
    around_hook('update-from', $target, sub {
      my $target_filename = strip(qx(which $target)) || $target;
      my %parent_metadata = %{metadata_from($target_filename)};
      terminal::warning("$target_filename has no externally visible metadata (makes updating slower)") unless $parent_metadata{id};

      my $identity = $parent_id_cache{$target} ||= $parent_metadata{id} || join '', qx($target identity);
      next if $can_skip_already_seen and
              exists $data{"parent::$target"} and
              $already_seen{$identity} || $parent_state_cache{$identity} eq $parent_metadata{istate};

      my $attributes = join '', qx($target ls -ahiu);
      my %divergent;
      die "skipping unreachable $target" unless $attributes;

      # These need to come after the reachability check so that we retry against
      # other copies in case something fails.
      ++$already_seen{$identity};
      $parent_state_cache{$identity} = $parent_metadata{istate} || join '', qx($target state -iPG);

      for my $to_rm (split /\n/, retrieve("parent::$target")) {
        my ($name, $hash) = split(/\s+/, $to_rm);
        next unless exists $data{$name};

        my $local_hash = fast_hash(retrieve($name));
        if ($clobber_divergent or $hash eq $local_hash or ! defined $hash) {rm($name)}
        else {terminal::info("preserving local version of divergent attribute $name (use update -D to clobber it)");
              $divergent{$name} = retrieve($name)}}

      associate("parent::$target", $attributes) unless $no_parents;

      dangerous('', sub {eval qx($target serialize -ipmu)});
      dangerous('', sub {eval qx($target serialize -ipMu)});

      map associate($_, $divergent{$_}), keys %divergent unless $clobber_divergent;

      reload()})})}

  cache('parent-identification', %parent_id_cache);
  cache('parent-state',          %parent_state_cache);

  if ($no_verify) {hook('update-from-presumably-succeeded', $options, @targets);
                   rm('state::before-update') unless $no_state || $save_state}
  elsif (verify()) {hook('update-from-succeeded', $options, @targets);
                    terminal::info("Successfully updated. Run 'load-state before-update' to undo this change.") if $save_state;
                    rm('state::before-update') unless $no_state || $save_state}
  elsif ($force || $no_state) {hook('update-from-failed', $options, @targets);
                               terminal::warning('Failed to verify: at this point your object will not save properly, though backup copies will be created.',
                                                 $no_state ? 'You should attempt to repair this object since no prior state was saved.'
                                                           : 'Run "load-state before-update" to undo the update and return to a working state.')}
  else {hook('update-from-failed', $options, @targets);
        terminal::error('Verification failed after the upgrade was complete.');
        terminal::info("$0 has been reverted to its pre-upgrade state.", "If you want to upgrade and keep the failure state, then run 'update-from $target --force'.");
        load_state('before-update');
        rm('state::before-update')}});
__
meta::function('usage', '"Usage: $0 action [arguments]\\nUnique actions (run \'$0 ls\' to see all actions):" . ls(\'-u\');');
meta::function('verify', <<'__');
file::write(my $other = $transient{temporary_filename} = temporary_name(), my $serialized_data = serialize());
chomp(my $observed = join '', qx|perl '$other' state|);

unlink $other if my $result = $observed eq (my $state = state());
terminal::error("Verification failed; expected $state but got $observed from $other") unless $result;
hook('after-verify', $result, observed => $observed, expected => $state);
$result;
__
meta::function('vim', <<'__');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for grep s/^vim_highlighter:://o, keys %data;
__
meta::hook('before-save::make-T', <<'__');
make('-T');             # Recompile bootstrap image
vim();                  # Update vim highlighters
__
meta::hook('before-shell::ad', 'ad(\'section::|note::|sdoc::\');');
meta::indicator('cc', 'length ::retrieve(\'data::current-continuation\') ? "\\033[1;36mcc\\033[0;0m" : \'\';');
meta::indicator('locked', 'is_locked() ? "\\033[1;31mlocked\\033[0;0m" : \'\';');
meta::indicator('path', <<'__');
my @highlighted = map join("\033[1;30m|\033[0;0m", split /\|/, $_), @{$transient{path}};
join "\033[1;30m/\033[0;0m", @highlighted;
__
meta::internal_function('around_hook', <<'__');
# around_hook('hookname', @args, sub {
#   stuff;
# });

# Invokes 'before-hookname' on @args before the sub runs, invokes the
# sub on @args, then invokes 'after-hookname' on @args afterwards.
# The after-hook is not invoked if the sub calls 'die' or otherwise
# unwinds the stack.

my $hook = shift @_;
my $f    = pop @_;

hook("before-$hook", @_);
my @result = &$f(@_);
hook("after-$hook", @_, @result);
wantarray ? @result : $result[0];
__
meta::internal_function('associate', <<'__');
my ($name, $value, %options) = @_;
die "Namespace does not exist" unless exists $datatypes{namespace($name)};
$data{$name} = $value;
execute($name) if $options{execute};
$value;
__
meta::internal_function('attribute', <<'__');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__
meta::internal_function('attribute_is', <<'__');
my ($a, %options) = @_;
my %inherited     = parent_attributes(grep /^parent::/o, sort keys %data) if grep exists $options{$_}, qw/-u -U -d -D/;
my $criteria      = $options{'--criteria'} || $options{'--namespace'} && "^$options{'--namespace'}::" || '.';

my %tests = ('-u' => sub {! $inherited{$a}},
             '-d' => sub {$inherited{$a} && fast_hash(retrieve($a)) ne $inherited{$a}},
             '-i' => sub {$transient{inherit}{namespace($a)}},
             '-v' => sub {$transient{virtual}{namespace($a)}},
             '-p' => sub {$a =~ /^parent::/o},
             '-s' => sub {$a =~ /^state::/o},
             '-m' => sub {$a =~ /^meta::/o});

return 0 unless scalar keys %tests == scalar grep ! exists $options{$_}    ||   &{$tests{$_}}(), keys %tests;
return 0 unless scalar keys %tests == scalar grep ! exists $options{uc $_} || ! &{$tests{$_}}(), keys %tests;

$a =~ /$_/ || return 0 for @{$options{'--path'}};
$a =~ /$criteria/;
__
meta::internal_function('cache', <<'__');
my ($name, %pairs) = @_;
if (%pairs) {associate("cache::$name", join "\n", map {$pairs{$_} =~ s/\n//g; "$_ $pairs{$_}"} sort keys %pairs)}
else        {map split(/\s/, $_, 2), split /\n/, retrieve("cache::$name")}
__
meta::internal_function('chmod_self', <<'__');
my ($mode_function)      = @_;
my (undef, undef, $mode) = stat $0;
chmod &$mode_function($mode), $0;
__
meta::internal_function('dangerous', <<'__');
# Wraps a computation that may produce an error.
my ($message, $computation) = @_;
terminal::info($message) if $message;
my @result = eval {&$computation()};
terminal::warning(translate_backtrace($@)), return undef if $@;
wantarray ? @result : $result[0];
__
meta::internal_function('debug_trace', <<'__');
terminal::debug(join ', ', @_);
wantarray ? @_ : $_[0];
__
meta::internal_function('execute', <<'__');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{$datatypes{$namespace}}(attribute($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__
meta::internal_function('exported', <<'__');
# Allocates a temporary file containing the concatenation of attributes you specify,
# and returns the filename. The filename will be safe for deletion anytime.
my $filename = temporary_name();
file::write($filename, cat(@_));
$filename;
__
meta::internal_function('extension_for', <<'__');
my $extension = $transient{extension}{namespace($_[0])};
$extension = &$extension($_[0]) if ref $extension eq 'CODE';
$extension || '';
__
meta::internal_function('fast_hash', <<'__');
use Digest::SHA qw/sha256_base64/;
sha256_base64(@_);
__
meta::internal_function('file::nuke', <<'__');
# Nukes a file with the preferred mechanism.
my ($file)  = @_;
my $backend = eval {file_nuke_backend()} // 'shred';
return system("shred -u '$file'") if $backend eq 'shred';
return unlink $file if $backend eq 'unlink';
die "unknown file::nuke backend: $backend";
__
meta::internal_function('file::read', <<'__');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__
meta::internal_function('file::write', <<'__');
use File::Path     'mkpath';
use File::Basename 'dirname';

my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{noclobber} and -f $name;
mkpath(dirname($name)) if $options{mkpath};

my $open_name = $name =~ /^[>|]/ ? $name : $options{append} ? ">> $name" : "> $name";
open my($handle), $open_name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__
meta::internal_function('fnv_hash', <<'__');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

$hash = ($hash ^ ($_ & 0xffff) ^ ($_ >> 16)) * $fnv_prime % $modulus for unpack 'L*', $data . substr($data, -4) x 8;
$hash;
__
meta::internal_function('hypothetically', <<'__');
# Allows you to make changes to the data without committing them.
# Usage:
#
# hypothetically(sub {
#   ...
# });
#
# Changes to %data made inside the sub {} are discarded.

my %data_backup   = %data;
my ($side_effect) = @_;
my @result        = eval {&$side_effect()};
%data = %data_backup;

die $@ if $@;
wantarray ? @result : $result[0];
__
meta::internal_function('internal::main', <<'__');
disable();

$SIG{'INT'}              = sub {snapshot_if_necessary(); exit 1};
$transient{initial}      = state();
chomp(my $default_action = retrieve('data::default-action'));

my $function_name = shift(@ARGV) || $default_action;
my @effective_argv = @ARGV;

unshift @effective_argv, $function_name and $function_name = 'method_missing'
unless exists $externalized_functions{$function_name};

around_hook('main-function', $function_name, @effective_argv, sub {
  dangerous('', sub {
    chomp(my @result = &$function_name(@effective_argv));
    print join("\n", @result), "\n" if @result})});

save() unless state() eq $transient{initial};

END {enable()}
__
meta::internal_function('invoke_editor_on', <<'__');
my ($data, %options) = @_;
my $editor    = $options{editor} || $ENV{VISUAL} || $ENV{EDITOR} || die 'Either the $VISUAL or $EDITOR environment variable should be set to a valid editor';
my $options   = $options{options} || $ENV{VISUAL_OPTS} || $ENV{EDITOR_OPTS} || '';
my $attribute = $options{attribute};
$attribute =~ s/\//-/g;
my $filename  = temporary_name() . "-$attribute$options{extension}";

file::write($filename, $data);
system("$editor $options '$filename'");

my $result = file::read($filename);
file::nuke($filename);
$result;
__
meta::internal_function('is_locked', '!((stat($0))[2] & 0222);');
meta::internal_function('metadata_from', <<'__');
my ($filename) = @_;
my %metadata;

# Not using file::read because we only need the first few lines.
open my($fh), '<', $filename or return {};
while (<$fh>) {
  $metadata{$1} = $2 if /^#\s*(\w+):\s*(.*)$/;
  last unless /^#/;
}
close $fh;

\%metadata;
__
meta::internal_function('namespace', <<'__');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__
meta::internal_function('parent_attributes', <<'__');
my $attributes = sub {my ($name, $value) = split /\s+/o, $_; $name => ($value || 1)};
map &$attributes(), split /\n/o, join("\n", retrieve(@_));
__
meta::internal_function('parent_ordering', <<'__');
# Topsorts the parents by dependency chain. The simplest way to do this is to
# transitively compute the number of parents referred to by each parent.

my @parents = @_;
my %all_parents = map {$_ => 1} @parents;

my %parents_of = map {
  my $t = $_;
  my %attributes = parent_attributes($_);
  $t => [grep /^parent::/, keys %attributes]} @parents;

my %parent_count;
my $parent_count;
$parent_count = sub {
  my ($key) = @_;
  return $parent_count{$key} if exists $parent_count{$key};
  my $count = 0;
  $count += $parent_count->($_) + exists $data{$_} for @{$parents_of{$key}};
  $parent_count{$key} = $count};

my %inverses;
push @{$inverses{$parent_count->($_)} ||= []}, $_ for @parents;
grep exists $all_parents{$_}, map @{$inverses{$_}}, sort keys %inverses;
__
meta::internal_function('retrieve', <<'__');
my @results = map defined $data{$_} ? $data{$_} : retrieve_with_hooks($_), @_;
wantarray ? @results : $results[0];
__
meta::internal_function('retrieve_trimmed', <<'__');
return strip(retrieve($_[0])) if $transient{trim}{namespace($_[0])};
retrieve($_[0]);
__
meta::internal_function('retrieve_with_hooks', <<'__');
# Uses the hooks defined in $transient{retrievers}, and returns undef if none work.
my ($attribute) = @_;
my $result      = undef;

defined($result = &$_($attribute)) and return $result for map $transient{retrievers}{$_}, sort keys %{$transient{retrievers}};
return undef;
__
meta::internal_function('select_keys', <<'__');
my %options = @_;
grep attribute_is($_, %options), sort keys %data;
__
meta::internal_function('separate_options', <<'__');
# Things with one dash are short-form options, two dashes are long-form.
# Characters after short-form are combined; so -auv4 becomes -a -u -v -4.
# Also finds equivalences; so --foo=bar separates into $$options{'--foo'} eq 'bar'.
# Stops processing at the -- option, and removes it. Everything after that
# is considered to be an 'other' argument.

# The only form not supported by this function is the short-form with argument.
# To pass keyed arguments, you need to use long-form options.

my @parseable;
push @parseable, shift @_ until ! @_ or $_[0] eq '--';

my @singles = grep /^-[^-]/, @parseable;
my @longs   = grep /^--/,    @parseable;
my @others  = grep ! /^-/,   @parseable;

my @singles = map /-(.{2,})/ ? map("-$_", split(//, $1)) : $_, @singles;

my %options;
/^([^=]+)=(.*)$/ and $options{$1} = $2 for @longs;
++$options{$_} for grep ! /=/, @singles, @longs;

({%options}, grep length, @others, @_);
__
meta::internal_function('strip', 'wantarray ? map {s/^\\s*|\\s*$//sgo; $_} @_ : $_[0] =~ /^\\s*(.*?)\\s*$/so && $1;');
meta::internal_function('table_display', <<'__');
# Displays an array of arrays as a table; that is, with alignment. Arrays are
# expected to be in column-major order.

sub maximum_length_in {
  my $maximum = 0;
  length > $maximum and $maximum = length for @_;
  $maximum;
}

my @arrays    = @_;
my @lengths   = map maximum_length_in(@$_), @arrays;
my @row_major = map {my $i = $_; [map $$_[$i], @arrays]} 0 .. $#{$arrays[0]};
my $format    = join '  ', map "%-${_}s", @lengths;

join "\n", map strip(sprintf($format, @$_)), @row_major;
__
meta::internal_function('temporary_name', <<'__');
use File::Temp 'tempfile';
my (undef, $temporary_filename) = tempfile("$0." . 'X' x 4, OPEN => 0);
$temporary_filename;
__
meta::internal_function('translate_backtrace', <<'__');
my ($trace) = @_;
$trace =~ s/\(eval (\d+)\)/$locations{$1 - 1}/g;
$trace;
__
meta::internal_function('with_cwd', <<'__');
my ($dir, $f) = @_;
my $cwd = cwd();

my @result = eval {chdir $dir && &$f()};
chdir $cwd;
die $@ if $@;
wantarray ? @result : $result[0];
__
meta::internal_function('with_exported', <<'__');
# Like exported(), but removes the file after running some function.
# Usage is with_exported(@files, sub {...});
my $f      = pop @_;
my $name   = exported(@_);
my $result = eval {&$f($name)};
terminal::warning("$@ when running with_exported()") if $@;
file::nuke($name);
$result;
__
meta::internal_function('with_fork', <<'__');
my (@args) = @_;
my $f = pop @args;

return process->new($child_pid) if my $child_pid = fork;

# This is the child process. Disable saving to prevent contention, and then
# exit with the given status code.
*::save = sub {};
exit &$f(@args);
__
meta::library('process', <<'__');
package process;

sub new  {my ($class, $pid) = @_; bless \$pid, $class}
sub kill {my ($self, $signal) = @_; ::kill $signal // 'KILL', $$self; $self->wait()}
sub term {my ($self) = @_; $self->kill('TERM')}
sub int  {my ($self) = @_; $self->kill('INT')}
sub stop {my ($self) = @_; $self->kill('STOP')}
sub cont {my ($self) = @_; $self->kill('CONT')}

sub wait {my ($self) = @_; ::wait($$self)}
__
meta::library('shell', <<'__');
# Functions for shell parsing and execution.
package shell;
use Term::ReadLine;

sub tokenize {grep length, split /\s+|("[^"\\]*(?:\\.)?")/o, join ' ', @_};

sub parse {
  my ($fn, @args) = @_;
  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;
  {function => $fn, args => [@args]}}

sub execute {
  my %command = %{$_[0]};
  if (exists $externalized_functions{$command{function}})
    {&{"::$command{function}"}(@{$command{args}})}
  elsif (exists $externalized_functions{'method-missing'})
    {::method_missing($command{function}, @{$command{args}})}
  else
    {die "undefined command: $command{function}"}}

sub run {execute(parse(tokenize(@_)))}

sub prompt {
  my %options = @_;
  my $name    = $options{name} // ::name();

  my $indicators = join '', map &{"::$_"}(), ::select_keys('--namespace' => 'indicator');
  my $prefix     = $transient{repl_prefix} // '';

  "$prefix\033[1;32m$name\033[0;0m$indicators "}

sub repl {
  my %options = @_;

  my $term = new Term::ReadLine "$0 shell";
  $term->ornaments(0);
  my $attribs = $term->Attribs;
  $attribs->{completion_entry_function} = $attribs->{list_completion_function};

  my $autocomplete = $options{autocomplete} || sub {[sort(keys %data), grep !/-/, sort keys %externalized_functions]};
  my $prompt       = $options{prompt}       || \&prompt;
  my $parse        = $options{parse}        || sub {parse(tokenize(@_))};
  my $output       = $options{output}       || sub {print join("\n", @_), "\n" if grep length, @_};
  my $command      = $options{command}      || sub {my ($command) = @_; ::around_hook('shell-command', $command, sub {&$output(::dangerous('', sub {execute($command)}))})};

  length $_ && &$command(&$parse($_)) while ($attribs->{completion_word} = &$autocomplete(), defined($_ = $term->readline(&$prompt())))}
__
meta::library('terminal', <<'__');
# Functions for nice-looking terminal output.
package terminal;

my $process = ::name();

sub message {print STDERR "[$_[0]] $_[1]\n"}
sub color {
  my ($name, $color) = @_;
  *{"terminal::$name"} = sub {chomp($_), print STDERR "\033[1;30m$process(\033[1;${color}m$name\033[1;30m)\033[0;0m $_\n" for map join('', $_), @_}}

my %preloaded = (info => 32, progress => 32, state => 34, debug => 34, warning => 33, error => 31);
color $_, $preloaded{$_} for keys %preloaded;
__
meta::message_color('cc', '36');
meta::message_color('state', 'purple');
meta::message_color('states', 'yellow');
meta::parent('/home/spencertipping/r/initiative/perl-objects/tex-document', <<'__');
function::compile-tex          1aU7yfeprcTdi5jtVg9D8qNFN6k5Z10MIwh78OaElOQ
function::tex                  vSLEcsHFFwXuYQU+U92quhZeytY4UGnrRdv/NIRj8f8
meta::externalize_template     99ls6D48caTrj4sNOD5U8kZIVKM+UKGodTsuIdemoow
meta::functor::code-templates  yIgx4ZtSh0bgaqmJf9QLxW0eEzKg6anynKXNrnDaVOU
meta::functor::tex-templates   frgH3U2KUE/bpOnVQdZZ//N8dd96ZudeXZtbfKpSROc
meta::template::beamer         XXhL4W5V+hlDETX71+6RX2r2J3xdvdb3if22e+zlijk
meta::template::code           QEz+0uogL3PayY55ZuU05VMf1KK8GfuHv8wrWKMRnjY
meta::template::document       MHlj293tE0RiuQ2WI/t1F110wHpQBfPQ4GAEvOyLDfY
meta::template::enumeration    jjwylQxn+TR3MxlKLuZxvpxhjKkqO2hWhd8zBOcVjrI
meta::template::math           S0kE11xCtBgTBMqu3Q8qF0zlrm5QWRuwzlXd4rZKS6M
meta::template::quotations     u5BEmXEb3b/YiFJcq7SvL7ppAfeAhkWi+o/LaPYGQnI
meta::template::sections       LYldyfJJTic+/KaBJVR1TYiVqqWTWUZDgxPbFcc0PYo
meta::type::psection           mldc2SZmf1Anc2A9yDHHoFfZi7mEIQmlN1GS5oWheI4
meta::type::resource           5SajN55K0xl4RzLLyWV6x3f8UnBeeSTkFjK55XNlkzw
meta::type::section            4Iq24yQH88Mbx0s0iQ9RERa76GoQpOGP58OogVZdlOQ
parent::preprocessor           0MHwm213wNg2GxFDBITELQ5rM8jcJ/iGRZo8PjtC6TU
parent::sdoc                   67pQdEUgI5ftzFIxAdEjAQwPyOJbcPa9x8aSPod1N8M
parent::vim-highlighters       Ciu+jISeDhWeNTsgX2XF3ivTuZvxeoERrb0ymgBrnS4
resource::header               TVm38wY1C+uwP+8Id0UxEbk4ZjI/vKtO/cR8kj92WDs
resource::header-languages     kMAe7vlErAnTSSW6JkPQnDQhroDGp4ZNv4wXQGjFH64
resource::header-listings      5TiVUmOp6EaRewZrHVoNVfzYNmq9zxpxvbHDvSzoW3U
resource::header-packages      9lccyZaHHtMC3SK7piGf6p1v+oTBt2vZsud1WKZKHu8
resource::header-refs          Aos0EtTHdFEyT4Rc7Qoc7GREFFUoEFmCWDzVXCmf5A0
resource::header-resource      +eY+XB4HTX0Vxfs2ddkbUJ5knu9Rg1LUYviZVzUmtHY
template::item[]               GCQvcO79cQb6288uEIfPrXlpwKXMgIVMdnr6ikbQYYs
template::label                E8eUUYXvUlcHXcvd6keVzZ1R+WkDeW+2bPehzoO/ktk
template::logical              tXrUGDhma3Ipze3wjdrzzBsX0jUTYGHtIgUscIWJ4eg
vim_highlighter::cltex         C/FTNRGbWC9bPXrKcxnn+DJPiV2BiMbOl/ocJyx/QZA
vim_highlighter::perltex       6QAVunvCpmdozTRbxQxV0k0v8h5rZeVZ3kuD8wwJ/9c
__
meta::parent('notes', <<'__');
function::note    b96+lYUBUJIx1rD5Ay9018BBRP5h++6/90bEaOx7+IY
function::notes   zvS1hx63x9gpPdLMcF68585BXdVWdSlqkkssFxqXZU4
meta::type::note  4P8m6fY9qL46kdlhIixbEVXgoGPCbIPKW6THhUtZd/0
parent::object    4vJJossUOfKUL2MiuYrqO9z+DK0xvPSw3lOcXwFdu2E
__
meta::parent('object', <<'__');
bootstrap::html                         /9nKOzNlCVjt5KpPCw6ktpNdorICJPOmdsxw8gRbQgs
bootstrap::initialization               TvbsjnluOC8KVyAVtB4a6Yzd+QlZ0Caz+PywmbS+RsE
bootstrap::perldoc                      Yun55m+nTQKU5l0UCuImJQGrDnrhsJ18adHGKgtzQ6M
function::ad                            TDzQEoFVHn4cxoMC1v2lQtvbymt7TDA+fzzf8ZdKBTY
function::alias                         76cEB7oBB2F8XdFTKnJy1lDh45nPgZ0c0xeoQUesLDk
function::cat                           6DwhwhDw7GTCE8Ll4Hwi13L3agMbCK7nbX0tDdC4MNU
function::cc                            YUoFsxNwVjmiHsdz9J7A13fBhp0++EiinFxETzF8+3g
function::ccc                           T3ySqmDsgIDdk55Fm4agtCEe1OOYWihhUcfiPtTupAs
function::cd                            cH/fs1az9tELnBgTC7JW/eb/ZSsf7s+K8Os8cMCeEG8
function::child                         y8XMjuUj//66Rj5jSs4HdEn1SqEIT1UVO6/2zb12Ln8
function::clone                         3ImmJEgQg9iM1gqe/hfKBFBm/Ky0HR/+xWj6XLXF3xk
function::cp                            +586T+V2LWthllDZvvTJzGNtngNo5c1pcS36XgTh1gs
function::create                        EG9exU+k3oTxSMX2TJHp660yAjhAe7+KZd4qBC1+vR8
function::current-state                 BPu6xpOyr3Ns0vYdawRlNxsmeRPITGp1bm0QtMaXFw4
function::cwd                           kUuYtqZpgzhXPJOe4f+SLRCFTG+tNl5j8p7+0yqE6C0
function::disable                       ETVjo3v6gmGncp7YgrEmQiDlF7GTHP0EX3yMOsn0M98
function::edit                          QgBU/tNoicpE+PHlVDKuUZ5vn5Da36GrycIxE0MwbA0
function::edit-self                     CnLk1bZDZ7VYrDQlYzfHXZ1aP5+0FrGCRBU1CUhel5I
function::enable                        uj6pBBIjv0ahKWcnbyL1IU4bsvDQqVJrQt6LrsUMzc4
function::expanded-bootstrap            20atbt3JeNY20woVBrxVH1IRnx/Sk8gPrY/nayXBIvs
function::export                        a/OWMZFsFsvHwnlvCBEZMg8WhZ9IP9ZwqJZBj7Garq8
function::extern                        EG6Lhkqo4xNy3xxWJgDv22Ij987xFAYgtwSXWNzwgDw
function::grep                          V4XnzOTDllwCW/e2EMuFITuX/q6stdhIQaCCOPo6ob4
function::hash                          +KkJP3kfAnYIXy1BBSEDdfzhnLpQPqz52RJpwgk+OCc
function::hook                          rhEyOmCy+ZDyO727aPXfTrEtkOOGaGKcezlkYf9BK0k
function::hooks                         2rZQUo7p9iu9gmM4wR+G6/RukNXgAk+ZcFepCgnfef8
function::identity                      6+JeD3ohDjevZF5UG7V3iRFkxIwp4KwwibpVc9dwcm4
function::import                        9HGjc6wuWn6+ElU//UxgjcG8dTo4aml/Bs117zcBdXY
function::initial-state                 E45KKMXa7YYzleuQNeMa+2XTkvSxKw40KaWN0lHLhV0
function::is                            R4wqjFaGUQnk3q8Ru9HEoyuoiTd0nEXs8655T50bO3I
function::load-state                    eLPBMJvlKzYr+6ZrhVj3kwYhpyxc9NS6veacMaV3sLk
function::lock                          rgtPo1uxq+ZA8QVPi2hstfNkbTojY7P7S4KmEwad/J4
function::ls                            qrAno4J3gk8dgDQv2/uX4Tf2Togs4RA6ijzCGuyCS4U
function::mv                            oGOOV1RR5dS32B/rTSJI2w/8FEt7LbMwDfMMZwjpqLY
function::name                          CJWkv4fyzTENKSfoZBLH4yjeaP9YkzqCiNcsULOibaE
function::parents                       PvAkixp0hXE4Q/1z7CKPil5BLkSGdGwMfg6QCGgW0EY
function::perl                          pOOr9RtVKIQI6kNIDkC1HmsIDll4TPio8OM3Cmi3htE
function::rd                            HC6cTSNHAtUtreuzLHKP6HkkDTCgI4gkzTY7t9EO//Q
function::reload                        FK+ITbNziplYOjLH/y5f4MzIJOaq/dQlHJ2CLp3+RDo
function::rm                            EwSp4uAK0uVy4lCYpJYvd0qu12q24rIlEiDUbfcW+YA
function::rmparent                      3RgK0wVGkKinmoqBJ0fZEyv72qWiL6a3unkz3etJC+M
function::save                          r7HLe7LppWXiaooOuUztnOK04LpIb+ck3bEvQ2SzY14
function::save-state                    KyoEB2NXy0ko1IYUVujXqEfbNbsoDckiKjwn8+zjvxs
function::serialize                     wGWkVgwClONRAAC0P+m5biPd+tJTjtrYWQa8VS3XL8Y
function::serialize-single              bOoEGNxf7jcYMAbvT4n492g5aUQ9e+umiaYC574Re6E
function::sh                            PA9Q/R+AEXXCDtU8QIPNFbZr/iITh4DXEG6EWY6n4DM
function::shb                           /COiQpKD0k/4B4/fnj1q1GtH+Z+ZQV0fJUwX6kSseks
function::shell                         vmp2+XW/dSS4KbXsVcimZAzAuJloTDaQASZgG0Y07Dg
function::size                          UFrBxczp+lDNQsbGtXE7IlZULMMP2NWLqJQsUvHlr1Y
function::snapshot                      zTuPSITfomNBxxegaGuSzov/JMWJ3vUWGqAAbYx/MsY
function::snapshot-if-necessary         V2hG5mBuDkIzwasK2iNJt5v+7iK2yAYD1/Omir19AmM
function::state                         EmD3LgRcBLmEIu1loHDBwhS+F73W0KLjm9mRNws0BVI
function::touch                         MvxEZzMCnQsgc44DzkQmPpuY/gVpZjNIVGgAqznIUPE
function::u                             hxjOve/ti/MyoyBAl/1EkoXIEAB/4bOdIh8eXM3oNJs
function::unlock                        ab+C+O37Wm9wHXqiOaF+0uwd3asIzlcJcChqOpFqiwk
function::update                        67tiKQo3l50gnH1KAXcfUH6tf/tB3K64UEM2lKrcge4
function::update-from                   ZnceaN1aTEkye6SRPhI/eLnjd56gyBdAAC74YAzKkbI
function::usage                         ITBRGF9rUVDwVE+YpFc2XXNeU2tD+IJKuvUGzqp30BA
function::verify                        nRZZh97ekQOHcDQUnxrHxMhybS2RlZifwYbH56KrL3M
indicator::cc                           2ikhlSjKzneE/3j6mqjUwNQe7gyTJ6IP39JuZJXB8ow
indicator::locked                       ZtHtnMoF2VDZ6rNdzy8JHnnrO71UXJgLN+OUoiQr9Fs
indicator::path                         XVIgNhtNzG44gG2fWuZOsKqfInEUa7hFABIN1mkM6S4
internal_function::around_hook          zWPc/eIWZMVUXDctAd/u34J1WA40nlbh8SvBx2tE2VA
internal_function::associate            aRtHj4eVjuRHamUSAHaI9DVezimcdFaqFkva+dz0x7M
internal_function::attribute            T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw
internal_function::attribute_is         O+KJhA7B6+N7gkDV2ajInPi947wIMEDHzAaRvWqB0a0
internal_function::cache                H0Rgkwopfv+3kVOCYBuUrh32L0pwHwBzy3LK6jhG2nU
internal_function::chmod_self           jwP33VbXCB7ZGtZ6rAm3ITeudyt+gq8wdkK/JYFvu8c
internal_function::dangerous            hpmVjFqxl2K7Kn+JMjADIOB4ZRwpsNKjulPWkUnwqng
internal_function::debug_trace          Py4lyrgkcj9TD3WxREcAOIu5qSk5ovMw/NJX/hsezMw
internal_function::execute              u5QsUyqazbIXg102zvkkR9c+U70uoAExjjTtRVss4SI
internal_function::exported             lt+j/oJ17agFjOp8QSeb2GN3j4iwEOqMulXaoAj91rI
internal_function::extension_for        VeNEZFjlo6u8rC3yvntP4xu/xpjW36Rq3PCPqlkjTiI
internal_function::fast_hash            BP8vJF0piDed/aGYR1H8SLjk9XqoGdhjpOH3wqUEFLU
internal_function::file::nuke           vRgROFbL2G7rrwziDIcamYLXWb4Sd6q325jGfqSk1f0
internal_function::file::read           ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg
internal_function::file::write          nMg2QO30cjzzI8/maAYtxQ76Ny3Tn0+67CX7xPkMu64
internal_function::fnv_hash             N2uv6uAkri1qLYjFmFOzWITS8UX0nj29kSN/Y1Z2+MM
internal_function::hypothetically       5h4k5A1NACvCeZF+auxnVnBOTfHvGYMINpFARejGqAA
internal_function::internal::main       MJVtZ4FOaoIiqG+CM+fMjVugUyU7+S6xLeirkoamEzU
internal_function::invoke_editor_on     T6uVYs1mq/VotsBwgqfn3aCoJD6JIG9+jp5M7y38ciw
internal_function::is_locked            EN0WP8v+JfHjxrEUDR5BMAJ4pMfNwj3UgG7zuj3B+yU
internal_function::metadata_from        fdIYuVCLs5te7JJdp7n2GhcSZRhZBp9O9hDdFZ3MV1s
internal_function::namespace            D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug
internal_function::parent_attributes    R4t2hz0vRzfeLwj0BJWd6tIG92nhwgnJ0ghbwM9+074
internal_function::parent_ordering      jYxqyDRm6Gp0MgwofcisBAy0mFiD+TzRO4kGUo0AfW8
internal_function::retrieve             x/cC8A6IVrv7cGYc06LjgxCmn9bXFKUIWx12NXRJP8U
internal_function::retrieve_trimmed     zCzstBKNEuJKINlRSdyhF8TA812YClYWNPh6b3mhtXc
internal_function::retrieve_with_hooks  Ed7iEFKqmGXxS3JPwmygtLjlOhycYvGsGlxNt3m2vk4
internal_function::select_keys          Kpg0B01VaBHfRb1YeI3/J8KpycHwXi1c0VdLNYkagqQ
internal_function::separate_options     qvGsY0MQiEVjugLRXbi/QfHvEI+3kQr+7jDZMbapfX4
internal_function::strip                jnRBmqPwpXGicECRagXsULSsEzBuO19OHHxvE0R4zVA
internal_function::table_display        qe/73ZK9+GlMti8pCl/CPvcJYK5q5moMUiXzDgKqoJg
internal_function::temporary_name       I6v0e9aXFvCgVCeVSb84b22rwrAIOX2ywYdcr44s3Vg
internal_function::translate_backtrace  n8iPtziEsVmBboZKnIsoUXc3mbe1RLOKJFenszUeHus
internal_function::with_cwd             DCrQF2lCsAa/lbEA3i1fimbTRS//b/L4qxicIsxg+Tg
internal_function::with_exported        sFgG++rvoIvOTTIZ2QlxgblZQ7R2W9kHUn48wVvIxXI
internal_function::with_fork            fB68GdZBM7LfsOmfVsCLBv2+blwEpLgg5aXOphf7P7E
library::process                        27/7yTUHKovr2X+dF2BhebepYF81cYQA1z9Ku97kiKk
library::shell                          z9Whrvl2xc4VLK7zIYdiYnODlXqrNXY1h3TWWNip4z4
library::terminal                       Iw5HMLpx/iJYD3QzZEU7GMDAsEGK700ormCZ+biuDz0
message_color::cc                       dqUIh9jxwukwF1VCiZCtgUee4hwltDIVz1JFQeBQMmk
message_color::state                    jgobCtpCFyiG/RKX4lq/mfFDlqlACsvV8g2iAonP8C8
message_color::states                   xoWiybqyNczdKrDqkigaUhyKrzeJVJPQgAcOoA/H9dc
meta::configure                         wNvmS+fdr/xIUde0ah7ZA51enuGxvC34oW+5c+xeXIM
meta::externalize                       SAxyF6wDNTRSGW2MB+K/k5/kvjykbj5X/xtTandqrQI
meta::functor::editable                 YCK6idpseu9YEyQOH/VIRmaixSpD2Fh9/Zae85p3Z5o
meta::type::alias                       GXKpeJdADYWyo/tSo2INXijrQlakqaBtfPEHcOI5BGI
meta::type::bootstrap                   pvkTkoPACRd4InQ7QezB82EYxJJMhbvFZKPGJeN44R0
meta::type::cache                       R/GhPTCblttoS9U3XHP/UnmfQAv3pH9Q4Wt0oCKWTlc
meta::type::data                        r27u83LwuNHMNErij+j31pmG0/YiHc9Cz0JS3g0AKPA
meta::type::function                    +aTLimxYFh3zNR3AwTblpHo32WMmzet3MgkvTQNfU7I
meta::type::hook                        ivXS9PJvGTKPUaGpYgAqV2dam2DMKwIj5GFUBHstKIg
meta::type::inc                         utWgF45+/EOqDQ+Yiez7nwDBcBacz+oxdzX3G6AKxHs
meta::type::indicator                   0kZ6fU5Gw7XVjKac1A6kna6UOwjWiJB2nTtM+bWYFS8
meta::type::internal_function           i5Z/e6riR0QCY6XoP1PZNGqe29wUhWMP2iNbpMakhT0
meta::type::library                     2LKXPuOHFk8JgPJF4c/PDwpbg+jWK4/E+jeZaZd+fQY
meta::type::message_color               pxp5xSe9bUnOdskJ78dpsSeJO17phMFhVyT12w/YCGA
meta::type::meta                        E78aF6OgcaZMsgJiEo3sIPzmwen+ib/V8iFLEE2rHaU
meta::type::parent                      MH85O3I0OH6/ZemosX9G8TmHGyWVcR2TPR9LTp8WldU
meta::type::retriever                   3YDISpeCeZ0ymbeXkLIhryRyK1R7fYA8SZkQxwD1d7c
meta::type::state                       cy3e7h9soIZRo3LkUS85L+6Pz9s2pf4LKBwY7La/YII
retriever::file                         lOSZ5sIxv78zFrly1i7NEp608wPPnFvPLcAwja2WmyI
retriever::global                       RQa5dsjawOzXJqAEeMc1PWKmWZqEZYnEtbseQDph3kk
retriever::id                           uWjP6vgjXeyfpsYSJVVeS5MxmFgSAcyDWvK42znkd9c
retriever::object                       /qBb5wkKa+URfmjZ3iQFnol8IgPV9lF0UOi6PmIfLWw
retriever::perl                         DD0+Y+2YiFJ997xsJ33MrySz5MDYb2FTx9SckMnfgPI
__
meta::parent('preprocessor', <<'__');
function::preprocess           m2lx3y4p2o25GXwhDdVji++Nc/TDAVLTap0dd7EflZ8
meta::type::template           g4/O5GtNM1bJKhesmvljZcmZBe/Du1fbma/8Sf2p9xY
parent::object                 Q4+42U+xCxGddLIZDnUc031ma2zMh4LJa3dm9v3H8IM
retriever::pp                  9la40Aol4Q7whkseOeOSByfjW/BzvMg4KThB6onv7fw
template::comment              Q0To1pu8fZ9GuKpTR5R85/OUDQPomqhoHvJHDCwklNQ
template::def                  w1j2n7Dtwc1kIhyH4kdYf3PU4/XKDXeL6EQjdZGGMsI
template::eval                 X4oZfu11/AhIuw2x/jZPwNvxUNeU2yhdhmowc9gLPiE
template::failing_conditional  dcTs2GkHghjI0ymFxNUW4jVHnvghSd4o1Unetur07oA
template::include              DO+8i6ZyEffTITDndTmpbIawHeNZNnA+HLUGY72xWO8
template::include!             g1BkMwjb+IPd0bi9wjTM2dx9EQqtMxrgmF7bHPkjA+U
template::pinclude             6mEhgXKTYooU7F1mkKeXK7kMkTF3MfyEbuNYBvrucfI
__
meta::parent('sdoc', <<'__');
function::sdoc            KqTDWyAjS5Q4rG8uAtDSyLQ6Dh6UPi7drVll5ctyfr8
function::sdoc-html       FLAGAgN9dvYdN/ZEKBVtZnBlZjx/MPB36y+NHkiqQ8A
function::sdoc-markdown   9D2GdBMV+yOwSF7SruQbiw/07Wh44y3yOEOdsxptoq8
function::sdoc-packed     eKkwP/gK2szEB/r0/ajr4jTuLNwuJHIhBpIMXSjvyHc
function::sdoc-pod        M0IYmNg1XZ58Nwxsrf6dkaNEJMJtFWkiTwXn98T/JmQ
function::sdocp           /mf9LC4xggw92hItse5u0RHx8hd6T3HCJgPv863vb5s
meta::type::sdoc          QhRTppEkfsRxF/ymQNFO/Lm5eL8zYA0eFw6ytuvlFt8
meta::type::slibrary      hwtjXzvMlFVe+2fnDbwVGjYSPtnu8Q2///1ySncXJy4
parent::object            4vJJossUOfKUL2MiuYrqO9z+DK0xvPSw3lOcXwFdu2E
retriever::code-sdoc      W8giWQGFB5AYBkD20lG+Pco4o4v4IBf6ba39HK7tlws
retriever::html-sdoc      O05S66RLWpugNJ4WdgHuFnFQNVo3AHdCkDyVH94tXVo
retriever::markdown-sdoc  O7mQ7IvSshQWDaiIGHbGLpy8XdDQWGVmBaPFqHfxS5k
retriever::pod-sdoc       hpLmOLKEJWEO9Xi6IldtM/iwNbM7L7qdsQmtw6mYPGg
retriever::sdoc           5iFtjMdcChKamkboF1vxa9cN0eM6GooEPPoxsBM7mgI
retriever::sdoc-packed    YEF5wR10IRAP4RpW2VbXilFpUudDen+A3oOit7iib/A
retriever::sdocp          5Py67HDgLP2JxQXwlARbemwD1B/3OkeXMpEeNBrCnLI
__
meta::parent('vim-highlighters', <<'__');
function::vim                eUhfd6Sep9M3E7FrDV9ftutQ/lyiJDeTcfO+zrvumio
meta::type::vim_highlighter  4B7NW92I4SsTQcUgmXrihu6wI+BiJe2SvV3TYcLAwQU
parent::object               4vJJossUOfKUL2MiuYrqO9z+DK0xvPSw3lOcXwFdu2E
__
meta::psection('implementation', <<'__');

- sp design | part:design
- sc constraints | chp:design-constraints
  xh is designed to be a powerful and ergonomic interface to multiple systems,
  many of which are remote. As such, it's subject to programming language,
  shell, and distributed-systems constraints:

  - enumerate << end
    - nitem | i:real-programming | realprog
      xh will be used for real programming.
      - antecedents \initial
    - nitem | i:shell | shell
      xh will be used as a shell.
      - antecedents \initial
    - nitem | i:distributed-computation | distributed
      xh will be used to manage any machine on which you have a login, which
      could be hundreds or thousands.
      - antecedents \initial
    - nitem | i:no-root-access | noroot
      You will not always have root access to machines you want to use, and
      they may have different architectures.
      - antecedents \initial
    - nitem | i:ergonomic-limit | ergonomic
      xh should approach the limit of ergonomic efficiency as it learns more
      about you.
      - antecedents \initial
    - nitem | i:security | security
      xh should never compromise your security, provided you understand what
      it's doing.
      - antecedents \initial

    - nitem | i:quick-webserver | webserver
      It should be possible to write a ``hello world'' HTTP server on one line.
      - antecedents << end
        \initial
        \refboth{i:real-programming}
        \refboth{i:shell}
      - end
    - nitem | i:live-preview | liveprev
      It should be possible to preview the evaluation of any well-formed
      expression without causing side-effects.
      - antecedents << end
        \initial
        \refboth{i:shell}
        \refboth{i:ergonomic-limit}
        \refboth{i:trivial-debugging}
      - end
    - nitem | i:not-slow | notslow
      xh should never cause an unresolvable performance problem that could be
      worked around by using a different language.
      - antecedents << end
        \initial
        \refboth{i:real-programming}
        \refboth{i:ergonomic-limit}
      - end
    - nitem | i:unreliable-connections | unreliable
      Connections between machines may die at any time, and remain down for
      arbitrarily long. xh must never become unresponsive when this happens,
      and any data coming from those machines should block until it is
      available again (i.e.~xh's behavior should be invariant with connection
      failures).
      - antecedents << end
        \initial
        \refboth{i:real-programming}
        \refboth{i:shell}
        \refboth{i:distributed-computation}
      - end
    - nitem | i:trivial-debugging | nodebug
      Debugging should require little or no effort; all error cases should be
      trivially obvious.
      - antecedents << end
        \initial
        \refboth{i:real-programming}
        \refboth{i:distributed-computation}
        \refboth{i:ergonomic-limit}
      - end
    - nitem | i:trivial-database | database
      An xh instance should trivially function as a database; there should be
      no distinction between data in memory and data on disk.
      - antecedents << end
        \initial
        \refboth{i:real-programming}
        \refboth{i:ergonomic-limit}
        \refboth{i:trivial-debugging}
        \refboth{i:no-oome}
        \refboth{i:not-slow}
      - end

    - nitem | i:universal-prediction | prediction
      xh should use every keystroke to build/refine a model it uses to predict
      future keystrokes and commands.
      - antecedents \refboth{i:ergonomic-limit}
    - nitem | i:forgetful-history | history
      The likelihood that xh forgets anything from your command history should
      be inversely proportional to the amount of effort required to
      retype/recreate it.
      - antecedents << end
        \refboth{i:ergonomic-limit}
        \refboth{i:universal-prediction}
      - end
    - nitem | i:locally-anonymous | anonymous
      xh must provide a way to accept input and execute commands without
      updating its prediction model.
      - antecedents \refboth{i:security}
    - nitem | i:http-client | pastebin
      xh should be able to submit an encrypted version of its current state to
      HTTP services like Github gists or pastebin.
      - antecedents << end
        \refboth{i:ergonomic-limit}
        \refboth{i:security}
        \refboth{i:unreliable-connections}
        \refboth{i:transparent-self-install}
        \refboth{i:www-initialization}
      - end

    - nitem | i:feel-like-shell | likeshell
      xh-script needs to feel like a regular shell for most purposes.
      - antecedents \refboth{i:shell}
    - nitem | i:imperative | imperative
      xh-script should be fundamentally imperative.
      - antecedents << end
        \refboth{i:real-programming}
        \refboth{i:shell}
        \refboth{i:feel-like-shell}
      - end
    - nitem | i:no-oome | no-oome
      xh must never run out of memory or swap pages to disk, regardless of what
      you tell it to do.
      - antecedents << end
        \refboth{i:real-programming}
        \refboth{i:shell}
        \refboth{i:not-slow}
        \refboth{i:ergonomic-limit}
      - end
    - nitem | i:nonblocking | nonblock
      xh must respond to every keystroke within 20ms; therefore, SSH must be
      used only for nonblocking RPC requests (i.e.~the shell always runs
      locally).
      - antecedents << end
        \refboth{i:shell}
        \refboth{i:not-slow}
        \refboth{i:ergonomic-limit}
      - end
    - nitem | i:remote-resources | remotestuff
      All resources, local and remote, must be uniformly accessible;
      i.e.~autocomplete, filename substitution, etc, must all just work (up to
      random access, which is impossible without FUSE or similar).
      - antecedents << end
        \refboth{i:shell}
        \refboth{i:distributed-computation}
        \refboth{i:ergonomic-limit}
      - end

    - nitem | i:prefix-notation | prefix
      xh-script uses prefix notation.
      - antecedents \refboth{i:shell}
    - nitem | i:quasiquoting | quasiquote
      xh-script quasiquotes values by default.
      - antecedents \refboth{i:shell}
    - nitem | i:unquoting | unquote
      xh-script defines an unquote operator.
      - antecedents << end
        \refboth{i:shell}
        \refboth{i:quasiquoting}
      - end

    - nitem | i:real-data-structures | datastruct
      The xh runtime provides real, garbage-collected data structures.
      - antecedents \refboth{i:real-programming}
    - nitem | i:data-structures-can-be-quoted | quotestruct
      Every xh data structure has a quoted form.
      - antecedents << end
        \refboth{i:real-data-structures}
        \refboth{i:shell}
        \refboth{i:trivial-debugging}
        \refboth{i:live-preview}
      - end
    - nitem | i:data-structures-can-be-serialized | printstruct
      Every xh data structure can be losslessly serialized by quoting it. In
      addition, every type of list can be losslessly serialized by coercing it
      to a string; the result can be unquoted to coerce it back to its original
      form.
      - antecedents << end
        \refboth{i:shell}
        \refboth{i:distributed-computation}
        \refboth{i:trivial-database}
        \refboth{i:data-structures-can-be-quoted}
        \refboth{i:settings-contain-variable-definitions}
        \refboth{i:image-merging}
      - end
    - nitem | i:data-structures-are-immutable | immutable
      Data structures have no identity and therefore are immutable. By
      extension, circular references can't be created except by indirection
      through a mutable value.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:data-structures-can-be-serialized}
      - end

    - nitem | i:opaque-resources | opaques
      xh-script must have access to machine-specific opaque resources like PIDs
      and file handles.
      - antecedents << end
        \refboth{i:real-programming}
        \refboth{i:shell}
      - end
    - nitem | i:mutable-symbol-table | mutablesyms
      Each xh instance should implement a mutable symbol table with weak
      reference support, subject to safe distributed garbage collection.
      - antecedents << end
        \refboth{i:data-structures-are-immutable}
        \refboth{i:opaque-resources}
        \refboth{i:no-oome}
        \refboth{i:xh-heap}
      - end
    - nitem | i:state-ownership | stateown
      Every piece of mutable state, including symbol tables, must have at most
      one authoritative copy (mutable state ownership within xh is managed by a
      CP system, and the state itself is trivially CP).
      - antecedents << end
        \refboth{i:unreliable-connections}
        \refboth{i:opaque-resources}
        \refboth{i:mutable-symbol-table}
        \refboth{i:thread-mobility}
      - end
    - nitem | i:checkpointing | checkpoint
      An xh instance should be able to save checkpoints of itself in case of
      failure. If you do this, xh becomes an AP system.
      - antecedents << end
        \refboth{i:unreliable-connections}
        \refboth{i:state-ownership}
      - end

    - nitem | i:lazy-evaluation | lazy
      xh's evaluator must support some kind of laziness.
      - antecedents << end
        \refboth{i:real-programming}
        \refboth{i:no-oome}
        \refboth{i:remote-resources}
        \refboth{i:not-slow}
      - end
    - nitem | i:laziness-serializable | printlazy
      Lazy values must have well-defined quoted forms and be losslessly
      serializable.
      - antecedents << end
        \refboth{i:data-structures-can-be-quoted}
        \refboth{i:data-structures-can-be-serialized}
        \refboth{i:lazy-evaluation}
        \refboth{i:thread-mobility}
        \refboth{i:xh-heap}
      - end
    - nitem | i:lazy-introspection | introspectlazy
      All lazy values can be subject to introspection to identify why they
      haven't been realized. This introspection must fully encode xh's
      knowledge about a value, modulo outstanding IO or CPU requests.
      - antecedents << end
        \refboth{i:trivial-debugging}
        \refboth{i:not-slow}
        \refboth{i:unreliable-connections}
        \refboth{i:nonblocking}
        \refboth{i:lazy-evaluation}
        \refboth{i:priority-scheduler}
      - end
    - nitem | i:abstract-evaluation | abstract
      xh must be able to partially evaluate expressions that contain unknown
      quantities.
      - antecedents << end
        \refboth{i:live-preview}
        \refboth{i:lazy-evaluation}
        \refboth{i:lazy-introspection}
        \refboth{i:laziness-serializable}
      - end
    - nitem | i:code-as-data | code=data
      xh-script code should be a reasonable data storage format.
      - antecedents << end
        \refboth{i:shell}
        \refboth{i:abstract-evaluation}
      - end
    - nitem | i:parse-self | selfparse
      xh-script must contain a library to parse itself.
      - antecedents \refboth{i:code-as-data}
    - nitem | i:homoiconic | homoiconic
      xh-script must be homoiconic.
      - antecedents << end
        \refboth{i:code-as-data}
        \refboth{i:parse-self}
        \refboth{i:self-hosting-runtime}
        \refboth{i:representational-abstraction}
      - end

    - nitem | i:compile-to-c | xh2c
      xh should be able to compile any function to C, compile it if the host
      has a C compiler, and transparently migrate execution into this process.
      - antecedents << end
        \refboth{i:real-programming}
        \refboth{i:thread-mobility}
        \refboth{i:not-slow}
      - end
    - nitem | i:compile-to-perl | xh2perl
      xh should be able to compile any function to Perl rather than
      interpreting its execution.
      - antecedents << end
        \refboth{i:real-programming}
        \refboth{i:no-root-access}
        \refboth{i:not-slow}
      - end
    - nitem | i:compile-to-js | xh2js
      xh should be able to compile any function to Javascript so that browser
      sessions can transparently become computing nodes.
      - antecedents << end
        \refboth{i:real-programming}
        \refboth{i:distributed-computation}
        \refboth{i:not-slow}
      - end
    - nitem | i:self-hosting-runtime | selfhost
      xh should follow a bootstrapped self-hosting runtime model.
      - antecedents << end
        \refboth{i:compile-to-c}
        \refboth{i:compile-to-perl}
        \refboth{i:compile-to-js}
        \refboth{i:representational-abstraction}
      - end
    - nitem | i:tracing-jit | dynamiccompiler
      xh-script should be executed by a profiling/tracing dynamic compiler that
      automatically compiles certain pieces of code to alternative forms like
      Perl or C.
      - antecedents \refboth{i:not-slow}
    - nitem | i:representational-abstraction | abstractstruct
      The xh compiler should optimize data structure representations for the
      backend being targeted.
      - antecedents << end
        \refboth{i:not-slow}
        \refboth{i:thread-mobility}
        \refboth{i:tracing-jit}
      - end

    - nitem | i:xh-heap | heap
      xh needs to implement its own heap and memory manager, and swap values to
      disk without blocking.
      - antecedents << end
        \refboth{i:real-programming}
        \refboth{i:no-oome}
        \refboth{i:trivial-database}
        \refboth{i:written-in-perl}
      - end
    - nitem | i:xh-threading | threading
      xh should implement its own threading model to accommodate blocked IO
      requests.
      - antecedents << end
        \refboth{i:shell}
        \refboth{i:distributed-computation}
        \refboth{i:quick-webserver}
        \refboth{i:lazy-evaluation}
        \refboth{i:xh-heap}
      - end
    - nitem | i:priority-scheduler | threadscheduler
      xh threads should be subject to scheduling that reflects the user's
      priorities.
      - antecedents << end
        \refboth{i:shell}
        \refboth{i:distributed-computation}
        \refboth{i:lazy-evaluation}
        \refboth{i:xh-threading}
      - end
    - nitem | i:thread-mobility | threadmobility
      Running threads must be transparently portable between machines and
      compiled backends.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:xh-threading}
        \refboth{i:tracing-jit}
        \refboth{i:representational-abstraction}
        \refboth{i:priority-scheduler}
      - end
    - nitem | i:reference-locality | refaffinity
      All machine-specific references must encode the machine for which they
      are defined.
      - antecedents << end
        \refboth{i:opaque-resources}
        \refboth{i:thread-mobility}
      - end
    - nitem | i:unique-ids | uniqueid
      Every xh instance must have a unique ID, ideally one that can be typed
      easily.
      - antecedents << end
        \refboth{i:ergonomic-limit}
        \refboth{i:reference-locality}
      - end

    - nitem | i:transparent-self-install | selfinstall
      xh needs to be able to self-install on remote machines with no
      intervention (assuming you have a passwordless SSH connection).
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:no-root-access}
      - end
    - nitem | i:www-initialization | wwwinit
      You should be able to upload your xh image to a website and then install
      it with a command like this:~\verb+curl me.com/xh | perl+.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:no-root-access}
      - end
    - nitem | i:self-modifying-image | selfmodifying
      Your settings should be present as soon as you download your image, so
      the image must be self-modifying and contain your settings.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:ergonomic-limit}
        \refboth{i:universal-prediction}
        \refboth{i:transparent-self-install}
        \refboth{i:www-initialization}
      - end
    - nitem | i:settings-contain-variable-definitions | varsinrc
      Your settings should be able to contain any value you can create from the
      REPL (with the caveat that some are defined only with respect to a
      specific machine).
      - antecedents << end
        \refboth{i:real-programming}
        \refboth{i:shell}
        \refboth{i:ergonomic-limit}
        \refboth{i:real-data-structures}
        \refboth{i:www-initialization}
      - end
    - nitem | i:written-in-perl | inperl
      xh should probably be written in Perl 5.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:no-root-access}
        \refboth{i:transparent-self-install}
        \refboth{i:www-initialization}
        \refboth{i:self-modifying-image}
      - end
    - nitem | i:no-perl-modules | perlcoreonly
      xh can't have any dependencies on CPAN modules, or anything else that
      isn't in the core library.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:no-root-access}
        \refboth{i:transparent-self-install}
      - end
    - nitem | i:image-merging | imagemerging
      It should be possible to address variables defined within xh images (as
      files or network locations).
      - antecedents << end
        \refboth{i:self-modifying-image}
        \refboth{i:settings-contain-variable-definitions}
      - end

    - nitem | i:rpc-via-ssh | sshrpc
      xh's RPC protocol must work via stdin/out communication over an SSH
      channel to a remote instance of itself.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:security}
        \refboth{i:transparent-self-install}
        \refboth{i:nonblocking}
        \refboth{i:remote-resources}
      - end
    - nitem | i:rpc-multiplexing | rpcmulti
      xh's RPC protocol must support request multiplexing.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:not-slow}
        \refboth{i:nonblocking}
        \refboth{i:remote-resources}
        \refboth{i:lazy-evaluation}
        \refboth{i:rpc-via-ssh}
      - end
    - nitem | i:xh-self-connection | hostswitch
      Two xh servers on the same host should automatically connect to each
      other. This allows a server-only machine to act as a VPN.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:no-root-access}
        \refboth{i:rpc-via-ssh}
        \refboth{i:transitive-topology}
      - end
    - nitem | i:domain-sockets | domainsockets
      xh should create a UNIX domain socket to listen for other same-machine
      instances.
      - antecedents << end
        \refboth{i:security}
        \refboth{i:xh-self-connection}
      - end
    - nitem | i:transitive-topology | transitive
      xh's network topology should forward requests transitively.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:no-root-access}
        \refboth{i:rpc-via-ssh}
      - end
    - nitem | i:network-routing | routing
      xh should implement a network optimizer that responds to observations it
      makes about latency and throughput.
      - antecedents << end
        \refboth{i:not-slow}
        \refboth{i:rpc-via-ssh}
        \refboth{i:transitive-topology}
      - end
  - end

- sc xh-script | chp:design-xh-script
  These constraints are based on the ones in
  \Ref{chapter}{chp:design-constraints}.

  - enumerate << end
    - nitem | is:data-types | xhs.datatypes
      xh has two fundamental data types, lists and strings.
      - antecedents \initial
    - nitem | is:list-types | xhs.listtypes
      Lists have three types, {\tt list}, {\tt array}, and {\tt map},
      corresponding to \verb|()|, \verb|[]|, and \verb|{}|, respectively.
      - antecedents << end
        \initial
        \refboth{is:data-types}
      - end

    - nitem | is:evaluation-identities | xhs.eval-identities
      Evaluation of any expression may happen at any time; the only scheduling
      constraint is the realization of lazy expressions, whose status is
      visible by looking at their quoted forms. Therefore, the evaluator is, to
      some degree, associative, commutative, and idempotent.
      - antecedents << end
        \initial
        \refboth{i:distributed-computation} above
        \refboth{i:trivial-debugging} above
        \refboth{i:live-preview} above
        \refboth{i:nonblocking} above
        \refboth{i:lazy-evaluation} above
        \refboth{i:lazy-introspection} above
        \refboth{i:abstract-evaluation} above
      - end

    - nitem | is:relational-evaluation | xhs.relational
      Relational evaluation is possible by using {\tt amb}, which returns any
      of the given presumably-equivalent values. xh-script is relational and
      invertible, though inversion is not always lossless and may produce
      perpetually-unresolved unknowns representing degrees of freedom.
      - antecedents << end
        \initial
        \refboth{i:trivial-debugging} above
        \refboth{i:lazy-evaluation} above
        \refboth{i:lazy-introspection} above
        \refboth{i:abstract-evaluation} above
        \refboth{i:self-hosting-runtime} above
        \refboth{i:representational-abstraction} above
        \refboth{i:priority-scheduler} above
        \refboth{is:evaluation-identities}
      - end
    - nitem | is:best-first-search | xhs.bestfirst
      Due to functions like {\tt amb}, evaluation proceeds as a best-first
      search through the space of values. You can influence this search by
      defining the {\tt abstraction} relation for a particular class of
      expressions.
      - antecedents << end
        \refboth{i:not-slow} above
        \refboth{is:relational-evaluation}
      - end
    - nitem | is:no-cut-operator | xhs.nocut
      Unlike Prolog, xh defines no cut primitive. You should use {\tt
      abstraction} to locally grade the search space instead.
      - antecedents << end
        \refboth{i:trivial-debugging} above
        \refboth{is:evaluation-identities}
        \refboth{is:best-first-search}
      - end

    - nitem | is:unquote-structure-preserving | xhs.unquote-structure
      Unquoting is structure-preserving with respect to parsing; that is, it
      will never force a reparse if its argument has already been parsed.
      - antecedents << end
        \initial
        \refboth{i:real-programming} above
        \refboth{i:unquoting} above
        \refboth{i:not-slow} above
        \refboth{i:abstract-evaluation} above
      - end
    - nitem | is:stack-local-scoping | xhs.stackscope
      All scoping is done by passing a second argument to {\tt unquote}; this
      enables variable resolution during the unquoting operation.
      - antecedents << end
        \initial
        \refboth{i:unquoting} above
        \refboth{i:mutable-symbol-table} above
        \refboth{is:evaluation-identities}
      - end
    - nitem | is:no-variable-shadowing | xhs.noshadow
      Variable shadowing is impossible.
      - antecedents << end
        \refboth{is:evaluation-identities}
        \refboth{is:stack-local-scoping}
      - end
    - nitem | is:unquoting-vs-parsing | xhs.unquote-parse
      Unquoting and structural parsing are orthogonal operations provided by
      {\tt unquote} and {\tt read}, respectively.
      - antecedents << end
        \refboth{i:data-structures-can-be-quoted} above
        \refboth{i:lazy-introspection} above
        \refboth{is:evaluation-identities}
        \refboth{is:unquote-structure-preserving}
      - end

    - nitem | is:runtime-as-receiver | xhs.runtimereceiver
      Whether via RPC or locally, statements issued to an xh runtime can be
      interpreted as messages being sent to a receiver; the reply is sent along
      whatever continuation is specified. The runtime doesn't differentiate
      between local and remote requests, including those made by functions.
      - antecedents << end
        \refboth{i:imperative} above
        \refboth{i:xh-threading} above
        \refboth{i:thread-mobility} above
        \refboth{i:state-ownership} above
      - end
    - nitem | is:function-variable-namespaces | xhs.namespaces
      Functions and variables exist in separate namespaces.
      - antecedents << end
        \refboth{i:feel-like-shell} above
        \refboth{i:unquoting} above
        \refboth{is:stack-local-scoping}
        \refboth{is:runtime-as-receiver}
      - end
    - nitem | is:function-literals-as-messages | xhs.fnliterals
      Function literals are self-invoking when used as messages.
      - antecedents \refboth{is:function-variable-namespaces}
    - nitem | is:no-real-continuations | nocallcc
      Continuations are simulated in terms of lazy evaluation, but are never
      first-class.
      - antecedents << end
        \refboth{i:tracing-jit} above
        \refboth{i:lazy-introspection} above
        \refboth{i:abstract-evaluation} above
        \refboth{is:runtime-as-receiver}
      - end
    - nitem | is:transient-definitions | xhs.transientdefs
      Some definitions are ``transient,'' in which case they are used to
      resolve blocked lazy values but then may be discarded at any point.
      - antecedents << end
        \refboth{i:distributed-computation} above
        \refboth{i:no-oome} above
        \refboth{i:lazy-evaluation} above
        \refboth{is:runtime-as-receiver}
      - end
    - nitem | is:global-definition-universality | xhs.globaldefs
      Global definitions can apply to values at any time, and to values on
      different machines (i.e.~their existence is broadcast).
      - antecedents << end
        \refboth{i:lazy-evaluation} above
        \refboth{is:transient-definitions}
      - end

    - nitem | is:macros-cannot-exist | xhs.nomacros
      Syntactic macros cannot exist because invocation commutes with expansion,
      but functions may operate on terms whose values are undefined.
      - antecedents << end
        \refboth{is:evaluation-identities}
        \refboth{is:unquote-structure-preserving}
      - end
    - nitem | is:errors-cannot-exist | xhs.noerrors
      Errors cannot exist, but are represented by lazy values that contain
      undefined quantities that will never be realized. These undefined
      quantities are the unevaluated backtraces to the error-causing
      subexpressions.
      - antecedents << end
        \refboth{i:trivial-debugging} above
        \refboth{i:lazy-evaluation} above
        \refboth{i:abstract-evaluation} above
        \refboth{is:evaluation-identities}
      - end

    - nitem | is:arbitrary-destructuring | xhs.destructuring
      Any value can be used as a destructuring bind pattern.
      - antecedents << end
        \initial
        \refboth{is:relational-evaluation}
      - end
    - nitem | is:amb-destructuring | xhs.ambdestructure
      \verb|(amb)| can be used to destructure values, and it behaves as a
      disjunction.
      - antecedents << end
        \initial
        \refboth{is:relational-evaluation}
        \refboth{is:arbitrary-destructuring}
      - end
    - nitem | is:abstract-dof | xhs.dof
      Degrees of freedom within an inversion are represented by abstract values
      that will prevent the result from being realized. They are visible as
      unevaluated expressions within the quoted form, usually taking the form
      of calls to \verb|(amb)|.
      - antecedents << end
        \initial
        \refboth{is:relational-evaluation}
        \refboth{is:amb-destructuring}
      - end
    - nitem | is:no-bareword-synthesis | xhs.nosynbareword
      Barewords are considered unique symbols; that is, xh will never try to
      synthesize a bareword using string-style semantics.
      - antecedents \initial

    - nitem | is:side-effects-as-axioms | xhs.se-axioms
      Side effects and axioms are the same thing in xh. Once it commits to a
      side-effect, it must always assume that it happened (since it did). In
      particular, this means that imperative forms like {\tt (def)} are
      actually ways to assume new ground truths.
      - antecedents << end
        \initial
        \refboth{i:imperative}
        \refboth{is:relational-evaluation}
        \refboth{is:global-definition-universality}
      - end
    - nitem | is:hypotheses-are-virtualization | xhs.virtualization
      Every side effect can be replaced by a temporary assumption that models
      the effect. If you do this, you're replacing an axiom with a hypothesis.
      - antecedents << end
        \initial
        \refboth{is:side-effects-as-axioms}
      - end
    - nitem | is:amb-side-effects | xhs.amb-se
      \verb|(amb)| hypothesizes all side effects until you commit to a branch
      using \verb|(def)|.

    - nitem | is:maps-as-relations | xhs.mapsasrelations
      Maps and relations are isomorphic, which means that \verb|(def)| is a
      stateful form of \verb|(assoc)|, and that map literals can be used as
      functions.
      - antecedents \initial
    - nitem | is:stable-values | xhs.stablevalues
      Maps, arrays, and unquoted atoms are stable under unquoting (e.g.~there
      is no distributive property that would unquote individual values within
      these structures).
      - antecedents << end
        \initial
        \refboth{is:maps-as-relations}
      - end
  - end

- sc xh-script syntax | chp:xhs-syntax
  Design constraints for the syntax in particular.

  - enumerate << end
    - nitem | isyn:reversible-parsing | syn.reversibleparsing
      The parser for xh is losslessly reversible:~comment data, whitespace, and
      any other aspect of valid xh code is encoded in the parsed
      representation.
      - antecedents \initial
    - nitem | isyn:tags | syn.tags
      Lists, vectors, and maps can each be tagged by immediately prefixing the
      opening brace with a word.
      - antecedents \initial
    - nitem | isyn:splicing | syn.splice
      A quoted form prefixed with \verb|@| causes list splicing to occur, just
      like Common Lisp's \verb|,@| and Clojure's \verb|~@|. Technically
      \verb|@| is a distributive, right-associative prefix expansion operator
      (sort of like \verb|$| in some ways), so you can layer it to expand
      multiple layers of lists. Any non-lists are treated as lists of a single
      item; \verb|@| is well-defined for all values.
      - antecedents << end
        \initial
        \refboth{i:real-programming}
        \refboth{i:ergonomic-limit}
      - end
    - nitem | isyn:escaping | syn.escaping
      Any character can be prefixed with {\tt \textbackslash} to cause it to be
      interpreted as a string. The only exception is that some escape sequences
      are interpreted, including \verb|\n|, \verb|\t|, and similar.
      - antecedents << end
        \initial
        \refboth{i:feel-like-shell}
      - end

    - nitem | isyn:hash-comments | syn.hashcomments
      Comments begin with \verb|#| preceded either by whitespace or the
      beginning of a line. Unlike in many languages, comment data is available
      in the parsed representation of xh source code.
      - antecedents << end
        \refboth{i:feel-like-shell}
        \refboth{isyn:reversible-parsing}
      - end
    - nitem | isyn:string-quoting | syn.stringquoting
      Single-quoted and double-quoted strings have exactly the semantics they
      do in Perl or bash; that is, single-quoted strings are oblivious to most
      unquoting features, whereas double-quoted strings are interpolated.
      - antecedents \refboth{i:feel-like-shell}
    - nitem | isyn:expression-interpolation | syn.stringexpressions
      Within a double-quoted string, you need to prefix any interpolating
      \verb|()| group with a \verb|$| to make it active.
      - antecedents << end
        \refboth{i:trivial-debugging}
        \refboth{i:feel-like-shell}
      - end
    - nitem | isyn:toplevel-expressions | syn.toplevelexpressions
      Outside words and quoted strings, \verb|()| does not require a \verb|$|
      prefix to interpolate. Put differently, the \verb|$| is required if and
      only if you are interpolating by same-word string concatenation.
      - antecedents << end
        \refboth{i:real-programming}
        \refboth{i:ergonomic-limit}
      - end

    - nitem | isyn:flat-toplevel-lists | syn.flattoplevel
      xh's toplevel grammar is based on Tcl, not Lisp; this means that you
      don't need to wrap each statement in parentheses. Line breaks are
      significant unless preceded with {\tt \textbackslash} or inside a list.
      Unlike bash and tcl, all sub-lists are parsed as in Lisp; that is, this
      toplevel syntax applies only at the outermost level.
      - antecedents << end
        \initial
        \refboth{i:feel-like-shell}
        \refboth{i:ergonomic-limit}
      - end
  - end

- sc runtime | chp:runtime
  xh-script operates within a hosting environment that manages things like
  memory allocation and thread/evaluation scheduling. Beyond this, we also need
  a quoted-value format that's more efficient than doing a bunch of string
  manipulation (\refboth{ir:expression-representation},
  \refboth{ir:flat-containers}, \refboth{ir:deduplication}).

  - enumerate << end
    - nitem | ir:priority-queue | xhr.priorityqueue
      Evaluation always happens as a process of pulling expressions from a
      priority queue.
      - antecedents << end
        \initial
        \refboth{is:relational-evaluation}
        \refboth{is:best-first-search}
      - end
    - nitem | ir:priority-tracing | xhr.prioritytracing
      Every expression in the queue knows its ``origin'' for scheduling
      purposes.
      - antecedents << end
        \refboth{is:best-first-search}
        \refboth{ir:priority-queue}
      - end

    - nitem | ir:static-inlining | xhr.staticinline
      Function compositions should be added as derived definitions to minimize
      the number of symbol-table lookups per unit rewriting distance.
      - antecedents << end
        \initial
        \refboth{i:not-slow}
        \refboth{is:relational-evaluation}
      - end
    - nitem | ir:latency | xhr.latency
      The runtime should provide low enough latency that it can be used as the
      graph-solving backend for RPC routing.
      - antecedents << end
        \initial
        \refboth{i:not-slow}
        \refboth{i:network-routing}
      - end
    - nitem | ir:value-caching | xhr.valuecache
      To guarantee low latency, the runtime should emit transient values for
      solutions it finds. These become cached bindings that can be kicked out
      under memory pressure, but reduce the load on the optimizer.
      - antecedents << end
        \initial
        \refboth{i:not-slow}
        \refboth{ir:latency}
      - end

    - nitem | ir:expression-representation | xhr.representation
      Every quasiquoted form with variant pieces should be represented as a
      separate instantiable class.
      - antecedents << end
        \initial
        \refboth{i:quasiquoting}
        \refboth{i:not-slow}
        \refboth{is:evaluation-identities}
      - end
    - nitem | ir:flat-containers | xhr.flatcontainers
      Quasiquoted structures are profiled for the distributions of their
      children (upon expansion); for strongly nonuniform distributions,
      specialized flattened container types are generated.
      - antecedents << end
        \initial
        \refboth{i:quasiquoting}
        \refboth{i:not-slow}
        \refboth{is:evaluation-identities}
        \refboth{ir:static-inlining}
        \refboth{ir:expression-representation}
      - end
    - nitem | ir:flat-container-limit | xhr.flatlimit
      Containers should be flattened until the type-encoding overhead is
      minimized for the given (possibly-contextful) distribution of values. In
      practice, this probably means using PPM and Huffman coding with an
      initial noise floor to prevent short-run overfitting.
      - antecedents << end
        \initial
        \refboth{i:not-slow}
        \refboth{ir:flat-containers}
      - end
    - nitem | ir:deduplication | xhr.deduplication
      Every independent value within a quasiquoted form should be referred to
      by a structural signature, in our case SHA-256. This trivially causes
      strings, and by extension execution paths, to be deduplicated. Because we
      assume no hash collisions, xh string values have no defined instance
      affinity (apropos of \refboth{i:reference-locality}).
      - antecedents << end
        \refboth{i:xh-heap}
        \refboth{ir:static-inlining}
        \refboth{ir:expression-representation}
        \refboth{ir:hinting}
      - end
    - nitem | ir:pointer-entropy | xhr.pointerentropy
      256 bits is sufficient to encode any pointer.
      - antecedents << end
        \initial
        \refboth{i:unique-ids}
        \refboth{i:reference-locality}
        \refboth{ir:deduplication}
      - end

    - nitem | ir:hinting | xhr.hinting
      Expressions should be hinted with tags that track and influence their
      paths through the search space. The optimizer uses machine learning
      against these tags to predict successful search strategies.
      - antecedents << end
        \initial
        \refboth{i:not-slow}
        \refboth{is:best-first-search}
        \refboth{is:no-cut-operator}
      - end
    - nitem | ir:hashing | xhr.hashing
      The runtime should use some type of masked hashing strategy (or other
      decision tree) to minimize the expected resolution time for each
      expression.
      - antecedents << end
        \initial
        \refboth{ir:hinting}
      - end
    - nitem | ir:transient-prediction | xhr.transientprediction
      Many functions will end up returning lazy values, and most of the time
      those lazy values will eventually be realized. The runtime should have
      some expectation of which lazy sub-values will be realized, and with what
      probability; this influences its search strategy in the future.
      - antecedents << end
        \initial
        \refboth{i:not-slow}
        \refboth{is:transient-definitions}
        \refboth{is:best-first-search}
        \refboth{ir:hinting}
      - end

    - nitem | ir:override | xhr.override
      The user must be able to completely override any strategy preferences the
      runtime has. The runtime can be arbitrarily wrong and the user can be
      arbitrarily right.
      - antecedents << end
        \initial
        \refboth{is:best-first-search}
        \refboth{ir:hinting}
        \refboth{ir:transient-prediction}
      - end
    - nitem | ir:external-strategy | xhr.externalstrategy
      The xh runtime does not itself define the evaluation strategy, nor does
      it internally observe things; this is done as part of the evaluation
      functions in the standard library. The only thing the xh runtime provides
      is a scheduled/prioritized event loop.
      - antecedents << end
        \initial
        \refboth{i:abstract-evaluation}
        \refboth{i:code-as-data}
        \refboth{ir:override}
      - end
    - nitem | ir:evaluator-api | xhr.evaluatorapi
      Evaluator functions are straightforward to write, and the standard
      library includes several designed for different use cases (e.g.~local,
      distributed, profiling). Any significantly nontrivial aspect of it is
      factored off into an API.
      - antecedents << end
        \initial
        \refboth{ir:override}
        \refboth{ir:external-strategy}
      - end
    - nitem | ir:evaluator-base | xhr.evaluatorbase
      The runtime is itself subject to evaluation (since it's self-hosting),
      and the base evaluator is implemented in Perl, C, or Javascript. This
      base evaluator runs locally; the distributed evaluator runs on top of it.
      - antecedents << end
        \initial
        \refboth{i:compile-to-perl}
        \refboth{i:compile-to-c}
        \refboth{i:compile-to-js}
        \refboth{i:written-in-perl}
        \refboth{i:self-hosting-runtime}
        \refboth{ir:override}
        \refboth{ir:evaluator-api}
      - end

    - nitem | ir:cryptographic-limit | xhr.cryptographic
      Any function can be modeled as a cipher and subject to forms of
      cryptanalysis to discover structure. The worst case is a truly random
      mapping that requires each permutation to be evaluated independently.
      (This is relevant for code synthesis, which is an inversion of the
      evaluator.)
      - antecedents << end
        \initial
        \refboth{is:relational-evaluation}
      - end
    - nitem | ir:uniformity-reduction | xhr.uniformityreduction
      Entropy can be reduced by biasing otherwise uniform distributions of
      \verb|(amb)| alternatives, possibly by looking at context. This can be
      done using real-world data, if any exists.
      - antecedents \refboth{ir:cryptographic-limit}
    - nitem | ir:separability | xhr.separability
      Entropy can be reduced by identifying input separability or other such
      structure. This is done through cryptanalysis, which must ultimately be
      verified structurally even if observed empirically.\footnote{{\bf
      TODO:}~is this really true? If so, we're in an awkward place where
      inference is concerned.}
      - antecedents \refboth{ir:cryptographic-limit}
  - end

- sc computational abstraction | chp:computational-abstraction
  - enumerate << end
    - nitem | ica:structured-programming | ca.structured
      All compilation is run through a structured programming layer that has
      abstractions for numeric operations and basic control flow. Shortcuts for
      higher-level operations are provided to leverage platform-specific
      optimized libraries.
      - antecedents << end
        \initial
        \refboth{i:compile-to-c}
        \refboth{i:compile-to-perl}
        \refboth{i:compile-to-js}
      - end

    - nitem | ica:variable-width-integers | ca.varwidthint
      Integer operations have signed and unsigned variants, and exist at any
      bit width. xh doesn't restrict to 32/64 bits (or other common values)
      because not all backends, e.g.~Perl and Javascript, support all bit
      widths natively.
      - antecedents << end
        \initial
        \refboth{i:written-in-perl}
      - end
    - nitem | ica:floating-point | ca.float
      Floating-point operations are defined for 32-bit and 64-bit floats. These
      are present on every sane platform.
      - antecedents \initial
    - nitem | ica:flat-memory | ca.flatmemory
      We can't assume that the underlying backend provides any data structures
      for us; we just address memory as a flat bunch of bytes. It's necessary
      to do this because we implement our own memory paging.
      - antecedents << end
        \refboth{i:not-slow}
        \refboth{i:no-oome}
      - end

    - nitem | ica:harvard-architecture | ca.harvard
      Data memory is separate from instructions; this abstraction has no
      homoiconicity at all. It's ok to do this here because all code at this
      level is backend-specific and machine generated. The only exception to
      this is that you can refer to function pointers, but they're assumed to
      be untyped and opaque.
      - antecedents << end
        \initial
        \refboth{i:compile-to-c}
        \refboth{i:compile-to-perl}
        \refboth{i:compile-to-js}
        \refboth{ica:flat-memory}
      - end

    - nitem | ica:user-gc | ca.usergc
      All garbage collectors are implemented in xh-script and compiled into the
      flat memory model.
      - antecedents << end
        \initial
        \refboth{i:real-programming}
        \refboth{i:imperative}
        \refboth{i:compile-to-c}
        \refboth{i:compile-to-perl}
        \refboth{i:compile-to-js}
        \refboth{ica:flat-memory}
        \refboth{ica:harvard-architecture}
      - end
    - nitem | ica:lazy-gc | ca.lazygc
      Garbage collectors are lazy, since the heap is useful as a cache and is
      swapped to disk.
      - antecedents << end
        \refboth{i:no-oome}
        \refboth{is:relational-evaluation}
        \refboth{is:best-first-search}
        \refboth{is:transient-definitions}
        \refboth{is:global-definition-universality}
        \refboth{ica:flat-memory}
      - end
    - nitem | ica:gc-locality | ca.gclocality
      GC is a strictly local process; all values sent over RPCs are quoted. The
      only exception is for mutable resources, which can be referred to
      remotely by acquiring a unique reference to it. When those references are
      no longer referred to, the remote instance notifies the owner. If the
      remote instance drops offline, any references it holds are invalidated.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{i:unreliable-connections}
        \refboth{i:remote-resources}
        \refboth{i:data-structures-can-be-serialized}
        \refboth{i:data-structures-are-immutable}
        \refboth{i:state-ownership}
        \refboth{ica:user-gc}
      - end

    - nitem | ica:user-profiling | ca.userprofiling
      Profiling is implemented as an xh-script library and is compiled into
      each backend automatically.
      - antecedents << end
        \initial
        \refboth{i:compile-to-c}
        \refboth{i:compile-to-perl}
        \refboth{i:compile-to-js}
        \refboth{i:not-slow}
        \refboth{is:relational-evaluation}
      - end

    - nitem | ica:user-relational | ca.userrelational
      Relational evaluation is implemented as an xh-script library that is then
      compiled into each backend automatically. Because of this self reference,
      the xh image contains two implementations of the relational evaluator.
      - antecedents << end
        \initial
        \refboth{i:compile-to-c}
        \refboth{i:compile-to-perl}
        \refboth{i:compile-to-js}
        \refboth{is:relational-evaluation}
      - end
    - nitem | ica:backend-relational | ca.backendrelational
      Because the computational abstraction is xh-script hosted, compiler
      backends assume a relational evaluator.
      - antecedents << end
        \initial
        \refboth{ica:user-relational}
      - end

    - nitem | ica:compiled-instances | ca.compiledinstances
      Every image compiled into a backend becomes a connected xh instance with
      an independently-managed heap, symbol table, etc. Communication is done
      via the usual RPC protocol. In a sense, the default xh image is one that
      has been precompiled into Perl.
      - antecedents << end
        \initial
        \refboth{i:distributed-computation}
        \refboth{i:not-slow}
      - end
    - nitem | ica:compiled-instance-visibility | ca.compiledvisibility
      Compiled images are visible in the global xh network topology.
      - antecedents \refboth{ica:compiled-instances}
    - nitem | ica:self-management | ca.selfmanagement
      Compiled images don't have managing instances; that is, they are expected
      to recompile themselves in response to any profile-guided optimization.
      - antecedents << end
        \refboth{ica:compiled-instances}
        \refboth{ica:compiled-instance-visibility}
      - end
    - nitem | ica:no-speculative-multiplicity | ca.nomultiplicity
      Images can't spontaneously multiply for the purpose of exploring the
      space of possible optimizations. This would require some kind of instance
      GC process, which is beyond the scope of xh. The only exception is that
      every compiler backend can create a new instance, obviously, since
      runtimes in different languages don't tend to work together trivially.
      - antecedents \refboth{ica:self-management}
    - nitem | ica:multiple-instances-per-machine | ca.mipermachine
      Even if xh is careful about the number of instances it creates, there
      will be multiple instances per physical machine.
      - antecedents << end
        \refboth{i:distributed-computation}
        \refboth{ica:compiled-instances}
        \refboth{ica:compiled-instance-visibility}
      - end

    - nitem | ica:machine-id | ca.machineid
      xh instances need a way to unambiguously identify a machine, even when
      the topology spans multiple networks (so there may be hostname
      collisions).
      - antecedents << end
        \refboth{i:remote-resources}
        \refboth{i:opaque-resources}
        \refboth{ica:multiple-instances-per-machine}
      - end
    - nitem | ica:uuid-machine-ids-are-ok | ca.machineiduuid
      Hostnames as aliases for machine UUIDs is an acceptable strategy for
      dealing with machine identification. It's important to make the names as
      human-friendly as possible.
      - antecedents << end
        \refboth{i:ergonomic-limit}
        \refboth{ica:machine-id}
      - end
  - end

- sc feasibility of relational evaluation | chp:relational-feasibility
  Writing a compiler in a relational framework is slightly insane because
  there's a fine line between judiciously combining known strategies for things
  and synthesizing algorithms. The only way for the problem to be remotely
  tractable is for us to either use heuristics, or to cache solutions
  somewhere. xh does the latter.

  The idea of a ``solution'' deserves some discussion. xh doesn't need to know
  answers to questions, but it does need to have something that decreases the
  entropy of the search space. Specifically, xh most likely has a synthesis
  rate of 20 bits per minute if we're lucky, and that number goes up
  exponentially with additional bits (though not if the bits are separable,
  which xh can figure out using differential cryptanalysis).

  Using techniques like cryptanalysis is ideal because it allows the core
  relational evaluator to be unbiased; any optimizations it makes are
  empirically verified first. Verification is itself not quite trivial, since
  xh won't always have a predictive model to prove things (and proving things
  is hard in any case). To get around this, xh is allowed to assume that
  correlations it observes are reproducible.\footnote{This may be suggested by
    Occam's Razor, depending on how you look at it, though it's still a weak
    form of the causation-from-correlation inference fallacy.}

  More specifically, xh needs to deal with:

  - enumerate << end
    - item Black-box systems (so no analytical solutions or proofs)
    - item Time-variant systems
    - item Noisy systems
  - end

  All of these can be mitigated to some extent by repeated observation. In
  particular, $H(\textrm{model}) \le H(\textrm{observations})$ obviously
  applies. In practice, this is unlikely to be a problem; it's fine if xh never
  fully understands the systems it's dealing with as long as it observes the
  most visible/important aspects.

  Fitting a model to observation data is itself subject to optimization; not
  all models are equally probable. xh is more about the expected than the worst
  case, so biasing the space of approximators to reduce modeling entropy is
  fair game.

  Modeling solutions is related to the representational optimization implied by
  \refboth{ir:flat-container-limit}, which gives us a convenient way to
  quantify optimization:~an optimal program has the highest computational
  throughput per unit time. In practical terms, this means that (1) the
  representations of data tend to be small/efficient, and (2) they are moved
  through components that can process them quickly (i.e.~no significant
  bottlenecks). Because this system is modeled as a throughput problem, the
  network routing logic from \refboth{i:network-routing} applies to algorithm
  optimization.

  Success/failure prediction is nontrivial because values don't have to be
  fully realized to be useful. For example, suppose we have two ways to
  generate the first 4KB of a string, one of which also produces the next 4KB
  quickly and one of which never realizes it. If all we need is the first 1KB,
  then the second 4KB of the string doesn't matter. So the question isn't what
  realizes the value as a whole, it's what ends up causing the value to block
  evaluation later on. We want to predict and minimize blocking.

  Another way to put it is that we want to minimize the time until a value can
  be garbage-collected. ({\bf TODO:}~is this true? What are the implications?)

- sc feasibility of representational abstraction | chp:ra-feasibility
  Given \refboth{i:data-structures-are-immutable}, representational abstraction
  is just a question of whole-value encoding; we don't have to worry about
  things like updating a value in place. The goal of representational
  abstraction is to generate value encodings that minimize the expected heap
  size, which can happen easily during garbage collection (since the heap gets
  copied in any case). There will end up being several such encodings for any
  given type of value, and the optimizer will choose different ones depending
  on the use case. The presence of such alternatives implies the existence of
  transcoding functions, which means that $n$ alternatives require $O(n^2)$
  code space (and possibly more because representations are sometimes mutually
  dependent). We can mitigate this slightly by generating these functions
  lazily.

  Concretely speaking, representational abstraction applies to strings and
  lists, which are the only two data types in xh (\refboth{is:data-types}).
  This makes analysis interesting because there isn't much of a distinction
  between types and values; for example, {\tt 3.141592} is a bare string that
  can be interpreted as a number. Most of the typeful semantics of xh are built
  around structured transformations of quoted values, so any type inference
  involves predicting which transformations will apply
  (\Ref{chapter}{chp:quoted-value-relations}).

  We also need to enable recursive abstraction to handle things like
  Church-encoded numbers. Generated representations are subject to exactly the
  same optimization strategies that apply to primitives.

- sc quoted value relations | chp:quoted-value-relations
  xh functions are implemented as string$\rightarrow$string relations whose
  operands bind in ways consistent with the fundamental structure of the
  language. That is, list forms are always fully matched; it isn't possible to
  match an unescaped open bracket alone, for example. Fundamental structure
  includes the following constructs:

  - verbatim << end
    (x1 x2 ... xN)      # paren-list
    [x1 x2 ... xN]      # bracket-list
    {x1 x2 ... xN}      # brace-list
    "stuff"             # double-quoted string atom
    'stuff'             # single-quoted string atom
    word                # unquoted, untyped atom
  - end

  Of these, lists, double-quoted atoms, and unquoted atoms are subject to
  interpolation:

  - verbatim << end
    $x                  # variable value as a single element
    !x                  # quoted variable value
    (f x y ...)         # function result interpolation
    !(f x y ...)        # quoted function result
  - end

  - enumerate << end
    - nitem | iqvr:unwrap | qvr.unwrap
      \verb|@| is a right-associative prefix operator that unwraps one layer of
      lists. For example, if \verb|$x = [[1 2] [3 4]]|, then \verb|@@$x| would
      be \verb|1 2 3 4|. Any scalars are treated as single-element lists.
    - nitem | iqvr:quoted | qvr.quoted
      \verb|!| and \verb|$| are two ways to dereference something; \verb|$|
      (implied if you use \verb|()|) may block until a complete value is
      available, whereas \verb|!| immediately quotes the value in whatever
      state of evaluation it happens to be in
      (\refboth{i:data-structures-can-be-quoted},
      \refboth{i:laziness-serializable}). You can use quoted-value
      introspection and evaluation functions to inspect and progress the state
      of such a value.
    - nitem | iqvr:unquote | qvr.unquote
      \verb|$| is a prefix operator that unquotes things until they converge to
      their asymptotic value limit. \verb|()| is a special form that calls a
      function, returning its unquoted result (\refboth{is:maps-as-relations});
      function calls are different from general unquoting in that unquoting is
      a strictly static operation, whereas function calls cause values to be
      rerun through relations. Within a double-quoted string, \verb|()| must be
      written as \verb|$()| (\refboth{isyn:string-quoting}).
  - end

  Destructuring constructs provide some degree of type selection. For example,
  lists are typeful:

  - verbatim << end
    [@$xs]              # matches [1 2 3], but not (1 2 3) or {1 2 3}
    (amb [@$xs] {@$xs}) # matches [1 2 3] and {1 2 3}, but not (1 2 3)
  - end

  Strings are structure-preserving, which means you can write parsers using
  destructuring notation. For example, the following parses $a^nb^nc$:

  - verbatim << end
    def (rep 0 $x) ''
    def (rep $n $x) "$x$(rep (dec $n) $x)"
    def (parse "$(rep $n a)$(rep $n b)c") ...
  - end

  The same kind of logic applies to lists by the following isomorphism:

  - verbatim << end
    def (list->string []) ''
    def (list->string [$x @$xs]) "$x$(list->string [@$xs])"
  - end

- sp base implementation | part:base-implementation
- sc self-replication | chp:self-replication
  - perl boot/xh-header << end
    #!/usr/bin/env perl
    #<body style='display:none'><script id='self' type='xh'>
    BEGIN {eval($::xh_bootstrap = q{
    # xh | https://github.com/spencertipping/xh
    # Copyright (C) 2014, Spencer Tipping
    # Licensed under the terms of the MIT source code license
    use 5.014;
    package xh;
    our %modules;
    our @module_ordering;
    our %eval_numbers = (1 => '$xh_bootstrap');

    sub with_eval_rewriting(&) {
      my @result = eval {$_[0]->(@_[1..$#_])};
      die $@ =~ s/\(eval (\d+)\)/$eval_numbers{$1}/egr if $@;
      @result;
    }

    sub named_eval {
      my ($name, $code) = @_;
      $eval_numbers{$1 + 1} = $name if eval('__FILE__') =~ /\(eval (\d+)\)/;
      with_eval_rewriting {eval $code; die $@ if $@};
    }

    our %compilers = (
      pl => sub {
        my $package = $_[0] =~ s/\./::/gr;
        eval {named_eval $_[0], "{package ::$package;\n$_[1]\n}"};
        die "error compiling module $_[0]: $@" if $@;
      },
      html => sub {});

    sub defmodule {
      my ($name, $code, @args) = @_;
      chomp($modules{$name} = $code);
      push @module_ordering, $name;
      my ($base, $extension) = split /\.(\w+$)/, $name;
      die "undefined module extension '$extension' for $name"
        unless exists $compilers{$extension};
      $compilers{$extension}->($base, $code, @args);
    }

    chomp($modules{bootstrap} = $::xh_bootstrap);
    undef $::xh_bootstrap;
  - end

  At this point we need a way to reproduce the image. Since the bootstrap code
  is already stored, we can just wrap it and each defined module into an
  appropriate \verb|BEGIN| block.

  - perl >> boot/xh-header << end
    sub serialize_module {
      my ($module)   = @_;
      my $contents   = $modules{$module};
      my $terminator = '_';
      $terminator .= '_' while $contents =~ /^$terminator$/m;
      join "\n", "BEGIN {xh::defmodule('$module', <<'$terminator')}",
                 $contents,
                 $terminator;
    }

    sub image {
      join "\n", "#!/usr/bin/env perl",
                 "#<body style='display:none'><script type='xh'>",
                 "BEGIN {eval(\$::xh_bootstrap = <<'_')}",
                 $modules{bootstrap},
                 '_',
                 map(serialize_module($_), grep !/\.html$/, @module_ordering),
                 "#</" . "script>",
                 map(serialize_module($_), grep  /\.html$/, @module_ordering),
                 "xh::main::main;\n__DATA__";
    }
    })}
  - end

  Here's a quick test implementation of \verb|xh::main::main|; its purpose is
  to make sure replication works. This won't be present in real images:

  - perlmodule xh::main src/test/main.pl << end
    sub main {
      # TESTCODE (FIXME if in a real image)
      print ::xh::image if grep /^--recompile/, @ARGV;

      if (grep /^--repl/, @ARGV) {
        print STDERR "> ";
        while (<STDIN>) {
          chomp;
          if (length) {
            my ($parsed) = xh::corescript::parse $_;
            my $result   = eval {xh::corescript::evaluate $parsed};
            my $error    = $@;
            print STDERR "parsed: ", $parsed->str, "\n";
            print STDERR $error ? "error:  $error\n"
                                : "result: " . $result->str . "\n";
          }
          print STDERR "> ";
        }
      }
    }
  - end

- sc xh-core script | chp:xh-core-script
  xh-script is complicated, and it would be overkill to write a complete parser
  in Perl considering that we'll end up needing a self-hosting parser later on.
  Instead, we define a sub-language called {\em xh-core script} that consists
  of assembly-level commands. This language is a syntactic subset of xh-script
  whose execution semantics are linear and imperative, and as such can be
  trivially compiled to Perl or Javascript (not C because we'll need a GC
  first).

  This sublanguage uses a simplified form of {\tt def} that produces
  traditional functions. As a result, defined things cannot use destructuring
  binds and are monomorphic under the symbol name. xh-core script also doesn't
  support any string interpolation or other magic syntax.

  - perlmodule xh::corescript src/corescript.pl << end
    sub xh::corescript::literal::new  {bless \$_[1], $_[0]}
    sub xh::corescript::var::new      {bless \$_[1], $_[0]}
    sub xh::corescript::list::new     {bless [@_[1..$#_]], $_[0]}
    sub xh::corescript::array::new    {bless [@_[1..$#_]], $_[0]}
    sub xh::corescript::map::new      {bless [@_[1..$#_]], $_[0]}
    sub xh::corescript::bindings::new {bless [$_[1], $_[2]], $_[0]}
    sub xh::corescript::fn::new       {bless [$_[1], $_[2]], $_[0]}
    sub xh::corescript::native::new   {bless [$_[1], $_[2]], $_[0]}

    # shorthands
    use constant literal  => 'xh::corescript::literal';
    use constant var      => 'xh::corescript::var';
    use constant list     => 'xh::corescript::list';
    use constant array    => 'xh::corescript::array';
    use constant bindings => 'xh::corescript::bindings';
    use constant fn       => 'xh::corescript::fn';
    use constant native   => 'xh::corescript::native';

    sub xh::corescript::literal::str {
      my $s = ${$_[0]};
      $s =~ /['()[]{},\s]/ ? "'" . (${$_[0]} =~ s/'/\\'/gr) . "'"
                           : $s;
    }

    sub xh::corescript::var::str     { "\$${$_[0]}" }
    sub xh::corescript::list::str    { '(' . join(' ', map $_->str, @{$_[0]})
                                           . ')' }

    sub xh::corescript::array::str   { '[' . join(' ', map $_->str, @{$_[0]})
                                           . ']' }

    sub xh::corescript::map::str     { '{' . join(' ', map $_->str, @{$_[0]})
                                           . '}' }

    sub xh::corescript::bindings::str {
      my ($self) = @_;
      my ($parent, $h) = @$self;
      '(bindings ' . ($parent ? $parent->str : 'nil ')
                   . join(', ', map "$_ " . $$h{$_}->str, sort keys %$h) . ')';
    }

    sub xh::corescript::fn::str {
      my ($self) = @_;
      my ($formals, $body) = @$self;
      '(' . join(' ', 'fn', $formals->str, $body->str) . ')';
    }

    sub xh::corescript::native::str {
      my ($self) = @_;
      $$self[0];
    }

    sub xh::corescript::bindings::deref {
      my ($self, $x) = @_;
      my ($parent, $h) = @$self;
      $$h{$x} // ($parent && $parent->deref($x));
    }

    sub xh::corescript::var::name { ${$_[0]} }

    sub xh::corescript::literal::eval  { $_[0] }
    sub xh::corescript::native::eval   { $_[0] }
    sub xh::corescript::bindings::eval { $_[0] }

    sub xh::corescript::var::eval { my ($self, $bindings) = @_;
                                    $bindings->deref($self->name) // $self }

    sub xh::corescript::list::eval {
      my ($self, $bindings) = @_;
      my ($f, @xs) = @$self;
      $f = ref($f) eq 'xh::corescript::literal' ? $bindings->deref($$f)
                                                : $f->eval($bindings);
      ref($f) eq 'xh::corescript::var'
        ? $self
        : $f->invoke($bindings, map $_->eval($bindings), @xs);
    }

    sub xh::corescript::array::eval {
      my ($self, $bindings) = @_;
      my $unchanged = 1;
      for (@$self) { last unless $unchanged = $_ eq $_->eval($bindings) }
      $unchanged ? $self : array->new(map $_->eval($bindings), @$self);
    }

    sub xh::corescript::map::eval {
      my ($self, $bindings) = @_;
      my $unchanged = 1;
      for (@$self) { last unless $unchanged = $_ eq $_->eval($bindings) }
      $unchanged ? $self
                 : xh::corescript::map->new(map $_->eval($bindings), @$self);
    }

    sub xh::corescript::fn::eval {
      my ($self, $bindings) = @_;
      my ($args, $body) = @$self;
      my $newbody = $body->eval($bindings);
      $body eq $newbody ? $self
                        : fn->new($args, $newbody);
    }

    sub xh::corescript::fn::invoke {
      my ($self, $bindings, @args) = @_;
      my ($formals, $body) = @$self;
      my %scope;
      $scope{$$formals[$_]} = $args[$_] for 0..$#args;
      $body->eval(bindings->new($bindings, \%scope));
    }

    sub xh::corescript::native::invoke { $_[0]->[1]->(@_[1..$#_]) }

    our %brackets = (')' => 'xh::corescript::list',
                     ']' => 'xh::corescript::array',
                     '}' => 'xh::corescript::map');

    our %globals;
    our $global_bindings = bindings->new(undef, \%globals);

    sub defnglobal { $globals{$_[0]} = native->new($_[0], $_[1]) }

    defnglobal 'bindings', sub {
      my ($bindings, $parent, @xs) = @_;
      my %h;
      for (my $i = 0; $i < @xs; $i += 2) {
        $h{$xs[$i]->name} = $xs[$i + 1];
      }
      bindings->new($parent, \%h);
    };

    defnglobal 'def', sub {
      my ($bindings, $var, $x) = @_;
      $globals{$var->name} = $x;
      $var;
    };

    defnglobal 'fn', sub {
      my ($bindings, $formals, $body) = @_;
      fn->new($formals, $body);
    };

    defnglobal 'str', sub {
      literal->new(join '', map $_->str, @_[1..$#_]);
    };

    sub parse {
      my @stack = [];
      local $_;
      while ($_[0] =~ / \G
                        (?: (?<comment> \#.*)
                          | (?<ws>      [\s,]+)
                          | (?<str>     '(?:[^\\']|\\.)*' | [^\$'()\[\]{}\s,]+)
                          | (?<var>     \$[^\$'\s()\[\]{},]+)
                          | (?<opener>  [(\[{])
                          | (?<closer>  [)\]}])) /gx) {
        next if $+{comment} || $+{ws};
        my $s = $+{str};
        if (defined $s)            {push @{$stack[-1]}, literal->new($s)}
        elsif ($s = $+{var})       {push @{$stack[-1]}, var->new(substr $s, 1)}
        elsif ($+{opener})         {push @stack, []}
        elsif ($s = $+{closer}) {
          my $last = pop @stack;
          die "too many closers" unless @stack;
          push @{$stack[-1]}, $brackets{$s}->new(@$last);
        } else {
          die "unrecognized token: $_";
        }
      }
      die "unbalanced brackets: " . scalar(@stack) . " != 1"
        unless @stack == 1;
      @{$stack[0]};
    }

    sub evaluate {
      my ($expr, $bindings) = @_;
      local $_;
      $bindings //= $global_bindings;
      $expr->eval($bindings);
    }
  - end

- sc html introspection | chp:base-html-introspection
  xh images can be opened as self-inspecting HTML files. This strategy of
  embedding xh module definitions in comments isn't very elegant, but it makes
  the Javascript parser easier to write. (A better system would be to have the
  Javascript parse everything in a single \verb|<script>| tag, then build all
  of the HTML that way; but due to browser security restrictions, this would
  break local viewing.)

  - htmlmodule js-dependencies src/introspect/dependencies.html << end
    <script>
    -- include deps/jquery.min.js
    -- include deps/caterwaul.min.js
    -- include deps/caterwaul.std.min.js
    -- include deps/caterwaul.ui.min.js
    </script>
  - end

  - htmlmodule css src/introspect/css.html << end
    <style>
    /*BEGIN {xh::defmodule('introspection.css', <<'_')}*/
    @import url(http://fonts.googleapis.com/css?family=Abel|Fira+Mono);
    body {background:   #080808;
          color:        #eae8e4;
          margin:       auto;
          max-width:    600px;
          overflow-y:   scroll;
          padding-left: 14px;
          border-left:  solid 1px #383736}

    h1 {font-family: 'Abel', monospace;
        font-weight: normal;
        font-size:   16px;
        color:       #878177;
        margin:      0}

    h1:hover, h1.active {color: #eae8e4}
    h1 .suffix {color: #878177}
    h1 .suffix:before {content: '.'; color: #878177}

    pre {font-family: 'Fira Mono', monospace;
         font-size:  10px}

    .module {border-top: solid 1px #383736;
             overflow:   hidden}
    .module pre {margin: 0}

    #dom   {margin: 20px 0}
    #dom, #dom a {font-family:     'Abel', sans-serif;
                  font-size:       16px;
                  text-decoration: none;
                  color:           #878177}
    #dom a:hover {color: #eae8e4}
    .title {color: #f89421}
    /*_*/
    </style>
  - end

  - htmlmodule dom src/introspect/dom.html << end
    <div id='dom'>
    <a href='https://github.com/spencertipping/xh' target='_blank'>
      <span class='title'>xh</span></a>
    <div>$ curl http://xh.spencertipping.com | perl</div>
    </div>
  - end

  - jsmodule introspection src/introspect/js.html << end
    // TESTCODE (should contain a functioning repl)
    $(caterwaul(':all')(function () {
      $.fn.toggle_vertically(v) = $(this).each(toggle)
      -where [toggle(t = $(this).stop()) =
                cs /~animate/ {top:    v ? 0 : -0.3 * h}
         -then- t  /~animate/ {height: v ? h : 0}
    /{opacity: +v} /~animate/ {queue: false, duration: 300}
         -where [cs = t.children().stop() /~css/ {position: 'relative'},
                 h  = cs.first().height()]],

      $('body').empty() /~before/ jquery[head /append(css)]
                        /~append/ dom
                        /~append/ ui_for(parsed_modules)
                        /~css/    {display: 'block'},
      where [
      css               = $('style'),
      dom               = $('#dom'),
      self              = +$('script, style') *[$(x).html()] /seq /~join/ '\n',
      parse_modules(ls) = xs -se [ls *!process_line -seq] -where [
        xs              = {__ordering: []},
        name            = null,
        text            = '',
        process_line(s) = /^(?:\/\*)?BEGIN.*defmodule\('([^']+)'/.exec(s)
                -re [it ? name /eq[it[1]] -then- text /eq['']
                        : /^(?:\/\*)?_+(?:\*\/)?$/.test(s)
                          ? name -ocq- 'bootstrap.pl'
                            -then- xs[name] /eq [text /~substr/ 1]
                            -then- xs.__ordering /~push/ name
                        : text += '\n#{s}']],

      parsed_modules    = self.split(/\n/) /!parse_modules,
      ui_for(modules)   = ui -se [sections *![ui /~append/ x] -seq] -where [
        ui              = jquery in div.modules,
        toggle()        = $(this).toggleClass('active').next().stop()
                          /~toggle_vertically/ $(this).hasClass('active'),
        module_name(x)  = jquery [span.prefix /text(pieces[0])
                                + span.suffix /text(pieces[1])]
                          -where [pieces = x.split(/\./, 2)],
        sections        = seq in
                          modules.__ordering
                          *[jquery in h1 /append(x /!module_name)
                                         /css({cursor: 'pointer'})
                                         /click(toggle)
                                    + div.module(pre /text(modules[x]))
                                      /toggle_vertically(false)]]]}));
  - end

- sp self-hosting implementation | part:self-hosting-implementation

__
meta::resource('header', <<'__');
- include resource::header-packages
- include resource::header-listings

- include resource::header-refs

- include resource::header-languages
- include resource::header-resource
__
meta::resource('header-languages', <<'__');
\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}
\lstnewenvironment{pythoncode}    {\lstset{language=python}}{}

__
meta::resource('header-listings', <<'__');
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}
__
meta::resource('header-packages', <<'__');
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
__
meta::resource('header-refs', <<'__');
\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

% Shamelessly swiped from
% http://compgroups.net/comp.text.tex/using-ref-and-label-so-that-ref-points-to-the-l/245066
\makeatletter
\newcommand*{\Label}[2]{%
  \@bsphack
  \begingroup
    \label{#1-original}%
    \def\@currentlabel{#2}%
    \label{#1}%
  \endgroup
  \@esphack
}
\makeatother

__
meta::resource('header-resource', '\\lstnewenvironment{resourcecode}{}{}');
meta::retriever('code-sdoc', <<'__');
# Lets you specify the SDoc extension manually. For instance:
# code.js::sdoc::foo causes sdoc::foo to be SDoc-rendered using Javascript comments.
my ($name) = @_;
return undef unless $name =~ s/^code\.(\w+)::// and defined retrieve($name);
sdoc($name, $1);
__
meta::retriever('file', '-f $_[0] ? file::read($_[0]) : undef;');
meta::retriever('global', <<'__');
# Returns the global data stashed at the end of this perl object
$_[0] eq 'self' ? $global_data : undef;
__
meta::retriever('html-sdoc', <<'__');
my ($attribute) = @_;
return undef unless $attribute =~ s/^html::/sdoc::/ and defined retrieve($attribute) || $attribute =~ s/^sdoc::// && defined retrieve($attribute);
sdoc_html($attribute);
__
meta::retriever('id', '$_[0] =~ /^id::/ ? substr($_[0], 4) : undef;');
meta::retriever('markdown-sdoc', <<'__');
my ($attribute) = @_;
return undef unless $attribute =~ s/^markdown(?:\.(\d+))?(\.q)?::/sdoc::/;
my ($adjust, $quote_code) = ($1, $2);
return undef unless defined retrieve($attribute) || $attribute =~ s/^sdoc::// && defined retrieve($attribute);
sdoc_markdown($attribute, adjust     => $adjust,
                          quote_code => $quote_code);
__
meta::retriever('object', <<'__');
# Fetch a property from another Perl object. This uses the 'cat' function.
return undef unless $_[0] =~ /^object::(.*?)::(.*)$/ && -x $1 && qx|$1 is '$2'|;
join '', qx|$1 cat '$2'|;
__
meta::retriever('perl', <<'__');
# Lets you use the result of evaluating some Perl expression
return undef unless $_[0] =~ /^perl::(.*)$/;
eval $1;
__
meta::retriever('pod-sdoc', <<'__');
my ($attribute) = @_;
return undef unless $attribute =~ s/^pod(?:\.(\d+))?(\.q)?::/sdoc::/;
my ($adjust, $quote_code) = ($1, $2);

return undef unless defined retrieve($attribute) || $attribute =~ s/^sdoc::// && defined retrieve($attribute);
sdoc_pod($attribute, adjust     => $adjust,
                     quote_code => $quote_code);
__
meta::retriever('pp', <<'__');
return undef unless namespace($_[0]) eq 'pp';
my $attr = retrieve(attribute($_[0]));
defined $attr ? preprocess($attr) : undef;
__
meta::retriever('sdoc', 'exists $data{"sdoc::$_[0]"} ? sdoc("sdoc::$_[0]", extension_for($_[0])) : undef;');
meta::retriever('sdoc-packed', <<'__');
return undef unless $_[0] =~ /^sdoc-packed::(.*)$/;
exists $data{"sdoc::$1"} ? sdoc_packed("sdoc::$1") : undef;
__
meta::retriever('sdocp', <<'__');
return undef unless $_[0] =~ /^sdocp::(.*)$/;
exists $data{"sdoc::$1"} ? sdocp("sdoc::$1") : undef;
__
meta::sdoc('xh', <<'__9');
- include boot/xh-header
- include src/test/main.pl
- include src/corescript.pl
- include src/introspect/dom.html
- include src/introspect/dependencies.html
- include src/introspect/css.html
- include src/introspect/js.html
xh::main::main;
__DATA__

__9
meta::section('main', <<'__');
- documentclass report
- include resource::header

\newcommand{\bs}{\textbackslash}
\setcounter{tocdepth}{0}
\lstnewenvironment{xhcode}{}{}

\newcommand{\initial}{{\em initial assumption}}
\newcommand{\refboth}[1]{{\em \ref{#1}} \ref{#1-original}}

- title  xh
- author Spencer Tipping

- document << end
  - maketitle
  - tableofcontents

  - include psection::implementation
- end

__
meta::template('antecedents', <<'__');
my ($line, $block) = @_;
my @antecedents = length $block ? grep(length, split /\v+/, $block)
                                : grep(length, split /\s+/, $line);

if (@antecedents > 2) {
  join "\n", "\\begin{itemize}",
             map("\\item $_", @antecedents),
             "\\end{itemize}";
} else {
  "(" . join(', ', @antecedents) . ")";
}

__
meta::template('comment', '\'\';     # A mechanism for line or block comments.');
meta::template('def', <<'__');
# Define a new template. Analogous to the C preprocessor's #define directive.
# For example:
#
# - def foo x, y, z << end
#   hello $x, $y, and $z!
#   This is an ${x}message.
# - end
#
# You can then use that template immediately:
#
# - foo 3, 4, 5
#
# Interpolation is achieved by evaling a Perl heredoc; the usual caveats apply.
# A variable called $body is automatically bound to the body contents if there
# are any; for example:
#
# - def named x << end
#   name $x {
#   $body
#   }
# - end
#
# - named 'foo' << end
#   woohoo
# - end
#
# You can define a "plural" form like this:
#
# - def -p say_hi_to << end
#   Hi $_!
# - end
#
# - say_hi_to Foo, Bar, Baz
#
# Plural forms still have the $body variable (which doesn't change across
# arguments), but they can't take formal parameters.

my ($options, $name, @args) = separate_options(split /\s+/, $_[0]);
my @formals                 = map split(/,\s*/), @args;
my $body                    = $_[1];

my $formal_list             = join(', ', map "\$$_", @formals);
my $parameter_bindings      = "my ($formal_list) = split /,\\s*/, \$_[0]";
my $body_binding            = "my \$body = \$_[1]";
my $heredoc_delimiter       = state();

# This will work great unless you put large hexadecimal barewords on otherwise
# blank lines in your code. At that point there's a 2^-128 chance that it will
# bomb out horribly.
my $plural = $$options{'--plural'} || $$options{'-p'};

die "- def $name: cannot use formal parameters with the -p option"
if $plural && @formals;

$plural ? meta::externalize "template::$name", "- def -p $name",
            eval "sub {\n$body_binding;\n" .
                 "join \"\\n\", map <<$heredoc_delimiter, " .
                                    "split /,\\s*/, \$_[0];\n" .
                 "$body\n" .
                 "$heredoc_delimiter\n}"

        : meta::externalize "template::$name", "- def $name @formals",
            eval "sub {\n$parameter_bindings;\n$body_binding;\n" .
                 "<<$heredoc_delimiter\n$body\n$heredoc_delimiter\n}";

die $@ if $@;

# No output from this template.
'';

__
meta::template('eval', <<'__');
my ($line, $block) = @_;
if (length $block) {
  my $result = eval $block;
  die "failed to template::eval $block (line was $line): $@" if $@;
  $result;
} else {
  my $result = eval $line;
  die "failed to template::eval $line: $@" if $@;
  $result;
}

__
meta::template('failing_conditional', <<'__');
my ($commands)    = @_;
my $should_return = $commands =~ / if (.*)$/ && ! eval $1;
terminal::warning("eval of template condition failed: $@") if $@;
$should_return;
__
meta::template('htmlmodule', <<'__');
my ($line, $block) = @_;
my ($name, $line)  = split /\s+/, $line, 2;
my $append         = $line =~ s/^\h*>>\h*//;
my $preprocessed   = preprocess($block =~ s/^\s*--/-/mgr);
my $wrap           = sub {"BEGIN {xh::defmodule('$name.html', <<'_')}\n$_[0]\n_"};
my $display        = $wrap->($block);

$line =~ s/\s+.*$//o;
file::write($line, ($append && "\n") . $wrap->($preprocessed), mkpath => 1, append => $append);
"\\lstset{caption={$line" . ($append && ' (continued)') . "},name={$line}}\\begin{javascriptcode}\n$display \\end{javascriptcode}";

__
meta::template('include', <<'__');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_), split /\s+/, $commands;
__
meta::template('include!', <<'__');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_) // die "include!: not found: $_",
               split /\s+/, $commands;

__
meta::template('item[]', <<'__');
my ($line, $block) = @_;
my ($name, $label) = split /\h*\|\h*/, $line, 2;
"\\item[$name]" . template::label($label)
                . (length $block ? "\n$block" : '');

__
meta::template('jsmodule', <<'__');
my ($line, $block) = @_;
my ($name, $line)  = split /\s+/, $line, 2;
my $append         = $line =~ s/^\h*>>\h*//;

# The extra module-wrapping is just to help the JS-based introspection library.
my $wrapped = qq{BEGIN {xh::defmodule('$name.html', <<'_')}
<script>
/*BEGIN {xh::defmodule('$name.js', <<'_')}*/
$block
/*_*/
</script>
_
};

$line =~ s/\s+.*$//o;
file::write($line, ($append && "\n") . $wrapped, mkpath => 1, append => $append);
"\\lstset{caption={$line" . ($append && ' (continued)') . "},name={$line}}\\begin{javascriptcode}\n$wrapped \\end{javascriptcode}";

__
meta::template('label', <<'__');
my ($line) = @_;
my ($tex_label, $nominal_label) = split /\h*\|\h*/, $line;

length $nominal_label ? "\\Label{$tex_label}{$nominal_label}"
                      : "\\label{$tex_label}" if length $line;

__
meta::template('logical', <<'__');
# Creates a logical section that is delimited only by TeX comments.
my ($name, $body) = @_;
$body =~ s/^\s*(.*\S)\s*$/\1/;
"% ${name}\n$body";

__
meta::template('nitem', <<'__');
# Named item
my ($line) = @_;
my (undef, $label, $name) = split /\h*\|\h*/, $line;

template::item($line) . (length $name ? "{\\em\\ref{$label}}" : '');

__
meta::template('perlmodule', <<'__');
my ($line, $block) = @_;
my ($name, $line)  = split /\s+/, $line, 2;
my $append         = $line =~ s/^\h*>>\h*//;
my $preprocessed   = preprocess($block =~ s/^(\s*)--(\s)/\1-\2/mgr);

my $wrapped = qq{BEGIN {xh::defmodule('$name.pl', <<'_')}
$preprocessed
_
};

$line =~ s/\s+.*$//o;
file::write($line, ($append && "\n") . $wrapped, mkpath => 1, append => $append);

qq[\\lstset{caption={$line] . ($append && ' (continued)') . qq[},name={$line}}\\begin{perlcode}
BEGIN {xh::defmodule('$name.pl', <<'_')}
$block
_ \\end{perlcode}];

__
meta::template('pinclude', <<'__');
# Just like the regular include, but makes sure to insert paragraph boundaries
# (this is required for SDoc to function properly).

my ($commands) = @_;
return '' if template::failing_conditional($commands);
my $text = join "\n\n", map retrieve($_), split /\s+/, $commands;
"\n\n$text\n\n";
__
meta::template('xh', <<'__');
my ($line, $block) = @_;
my $append         = $line =~ s/^\h*>>\h*//;

$line =~ s/\s+.*$//o;
file::write($line, ($append && "\n") . $block, mkpath => 1, append => $append);
"\\lstset{caption={$line" . ($append && ' (continued)') . "},name={$line}}\\begin{xhcode}\n$block \\end{xhcode}";

__
meta::template('xhmodule', <<'__');
my ($line, $block) = @_;
my ($name, $line)  = split /\s+/, $line, 2;
my $append         = $line =~ s/^\h*>>\h*//;

my $wrapped = qq{BEGIN {xh::defmodule('$name.xh', <<'_')}
$block
_
};

$line =~ s/\s+.*$//o;
file::write($line, ($append && "\n") . $wrapped, mkpath => 1, append => $append);
"\\lstset{caption={$line" . ($append && ' (continued)') . "},name={$line}}\\begin{xhcode}\n$block \\end{xhcode}";

__
meta::vim_highlighter('cltex', <<'__');
" Cleaner TeX
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   Cleaner TeX (a variant of LaTeX with support for a bunch of embedded languages)

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn match   cltEofMarker      /<<\s*\w\+/ contained
syn region  cltLineComment    matchgroup=cltCode start=/^\s*- comment / end=/$/ contained
syn region  cltLogicalComment matchgroup=cltCode start=/^\s*- logical / end=/<</ contained
syn match   cltLine           /^\s*- .*$/ contains=cltEofMarker,cltLineComment,cltLogicalComment

syn case match | syn include @cpp           syntax/cpp.vim        | unlet b:current_syntax
syn case match | syn include @java          syntax/java.vim       | unlet b:current_syntax
syn case match | syn include @asm           syntax/asm.vim        | unlet b:current_syntax
syn case match | syn include @javascript    syntax/javascript.vim | unlet b:current_syntax
syn case match | syn include @html          syntax/html.vim       | unlet b:current_syntax
syn case match | syn include @perl          syntax/perl.vim       | unlet b:current_syntax
syn case match | syn include @ruby          syntax/ruby.vim       | unlet b:current_syntax
syn case match | syn include @python        syntax/python.vim     | unlet b:current_syntax

syn case match

syn region  cltCpp         matchgroup=cltCode start=/^\z(\s*\)- cpp .*<<\s*\z(\w\+\)$/        end=/^\z1- \z2$/ contains=@cpp
syn region  cltJava        matchgroup=cltCode start=/^\z(\s*\)- java .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@java
syn region  cltAsm         matchgroup=cltCode start=/^\z(\s*\)- asm .*<<\s*\z(\w\+\)$/        end=/^\z1- \z2$/ contains=@asm
syn region  cltJavascript  matchgroup=cltCode start=/^\z(\s*\)- javascript .*<<\s*\z(\w\+\)$/ end=/^\z1- \z2$/ contains=@javascript
syn region  cltHtml        matchgroup=cltCode start=/^\z(\s*\)- html .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@html
syn region  cltPerl        matchgroup=cltCode start=/^\z(\s*\)- perl .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@perl
syn region  cltRuby        matchgroup=cltCode start=/^\z(\s*\)- ruby .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@ruby
syn region  cltPython      matchgroup=cltCode start=/^\z(\s*\)- python .*<<\s*\z(\w\+\)$/     end=/^\z1- \z2$/ contains=@python
syn region  cltResource    matchgroup=cltCode start=/^\z(\s*\)- resource .*<<\s*\z(\w\+\)$/   end=/^\z1- \z2$/
syn region  cltComment     matchgroup=cltCode start=/^\z(\s*\)- comment .*<<\s*\z(\w\+\)$/    end=/^\z1- \z2$/

syn cluster cltStuff       add=cltCpp,cltJava,cltAsm,cltJavascript,cltHtml,cltResource,cltComment,cltLine,cltPerl,cltRuby,cltPython

syn region  cltDocument    start=/\%^/ end=/\%$/ contains=@cltStuff

hi link cltLine            Special
hi link cltKeyword         String
hi link cltResource        String
hi link cltEofMarker       String

hi link cltCode            Special
hi link cltDocument        Comment
hi link cltComment         Type
hi link cltLineComment     Type
hi link cltLogicalComment  Type

let b:current_syntax = "cltex"

__
meta::vim_highlighter('perltex', <<'__');
" Literate Perl in TeX
" Maintainer: Spencer Tipping <spencer@spencertipping.com>

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn include @xh syntax/xh.vim
if exists("b:current_syntax")
  unlet b:current_syntax
endif

syn include @js syntax/caterwaul.vim
if exists("b:current_syntax")
  unlet b:current_syntax
endif

syn include @html syntax/html.vim
if exists("b:current_syntax")
  unlet b:current_syntax
endif

runtime syntax/perl.vim

syn case match
syn match  pltPreprocessor /^\s*- .*$/ containedin=pltImpliedComment
syn region pltImpliedComment matchgroup=pltPreprocessor start=/\%^\|^\s*- end$/ end=/^\s*- perl.*$\|\%$/ keepend containedin=ALL
syn region pltXhRegion       matchgroup=pltPreprocessor start=/^\s*- xh.*$/ end=/^\s*- end$/ contained containedin=pltImpliedComment contains=@xh keepend
syn region pltJsRegion       matchgroup=pltPreprocessor start=/^\s*- js.*$/ end=/^\s*- end$/ contained containedin=pltImpliedComment contains=@js keepend
syn region pltHtmlRegion     matchgroup=pltPreprocessor start=/^\s*- html.*$/ end=/^\s*- end$/ contained containedin=pltImpliedComment contains=@html keepend

hi link pltImpliedComment Comment
hi link pltPreprocessor   PreProc

let b:current_syntax = "perltex"

__
meta::vim_highlighter('xh', <<'__');
" Language:   xh
" Maintainer: Spencer Tipping

if !exists("main_syntax")
  if version < 600
    syntax clear
  elseif exists("b:current_syntax")
    finish
  endif
  let main_syntax = 'xh'
endif

syn case match
set iskeyword=37,38,42-63,65-90,94-122,124,127-255

syn region xhShebang start=/\%^#!/ end=/$/
syn region xhList             matchgroup=xhInterpolationParens start=/\(@!\|@\|!\)\?\k*(/   end=/)/ contains=@xhTop
syn region xhInterpolatedList matchgroup=xhInterpolationParens start=/\(@!\|@\|!\|\$\)\k*(/ end=/)/ contains=@xhTop
syn region xhVector           matchgroup=xhParens              start=/\k*\[/                end=/]/ contains=@xhTop
syn region xhMap              matchgroup=xhParens              start=/\k*{/                 end=/}/ contains=@xhTop
syn region xhSoftString       matchgroup=xhQuoteMarks          start=/\k*"/                 end=/"/ contains=xhSoftEscape,@xhStringInterpolable
syn region xhHardString       matchgroup=xhQuoteMarks          start=/\k*'/                 end=/'/ contains=xhHardEscape

syn cluster xhTop add=xhList,xhVector,xhMap,xhSoftString,xhHardString,xhInterpolatedWord,xhBuiltin,xhLooksLikeABuiltin,xhEscapedWord,xhLineComment
syn cluster xhInterpolable add=xhList,xhInterpolatedWord
syn cluster xhStringInterpolable add=xhInterpolatedList,xhInterpolatedWord

syn match xhSoftEscape /\\./     contained
syn match xhHardEscape /\\[\\']/ contained

syn keyword xhBuiltin def
syn match xhLooksLikeABuiltin /def\k*/
syn match xhInterpolatedWord /\(@!\|[!@$]\)\k\+/

syn match xhLineComment /#.*/
syn match xhEscapedWord /\^\+\k\+/

hi def link xhShebang             Special
hi def link xhBuiltin             Keyword
hi def link xhLooksLikeABuiltin   Keyword
hi def link xhParens              Special
hi def link xhQuoteMarks          Special
hi def link xhSoftString          String
hi def link xhHardString          String
hi def link xhInterpolatedWord    Identifier
hi def link xhInterpolationParens Type
hi def link xhLineComment         Comment
hi def link xhEscapedWord         Special

hi def link xhSoftEscape          Special
hi def link xhHardEscape          Special

__
internal::main();
__DATA__
